[
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildmac/Resources/env/lib/python2.7/site-packages/obfsproxy/transports/scramblesuit/ticket.py",
    "code": [
      "    and the ticket's issue date is returned.  If any of these steps fail,\n",
      "    `None' is returned.\n",
      "    \"\"\"\n",
      "\n",
      "    assert (ticket is not None) and (len(ticket) == const.TICKET_LENGTH)\n",
      "    assert (srvState.hmacKey is not None) and (srvState.aesKey is not None)\n",
      "\n",
      "    log.debug(\"Attempting to decrypt and verify ticket.\")\n",
      "\n",
      "    checkKeys(srvState)\n",
      "\n",
      "    # Verify the ticket's authenticity before decrypting.\n",
      "    hmac = HMAC.new(srvState.hmacKey, ticket[0:80], digestmod=SHA256).digest()\n",
      "    if util.isValidHMAC(hmac, ticket[80:const.TICKET_LENGTH],\n",
      "                        srvState.hmacKey):\n",
      "        aesKey = srvState.aesKey\n",
      "    else:\n",
      "        if srvState.oldHmacKey is None:\n",
      "            return None\n",
      "\n",
      "        # Was the HMAC created using the rotated key material?\n",
      "        oldHmac = HMAC.new(srvState.oldHmacKey, ticket[0:80],\n",
      "                           digestmod=SHA256).digest()\n",
      "        if util.isValidHMAC(oldHmac, ticket[80:const.TICKET_LENGTH],\n",
      "                            srvState.oldHmacKey):\n",
      "            aesKey = srvState.oldAesKey\n",
      "        else:\n",
      "            return None\n",
      "\n",
      "    # Decrypt the ticket to extract the state information.\n",
      "    aes = AES.new(aesKey, mode=AES.MODE_CBC,\n",
      "                  IV=ticket[0:const.TICKET_AES_CBC_IV_LENGTH])\n",
      "    plainTicket = aes.decrypt(ticket[const.TICKET_AES_CBC_IV_LENGTH:80])\n",
      "\n",
      "    issueDate = struct.unpack('I', plainTicket[0:4])[0]\n",
      "    identifier = plainTicket[4:22]\n",
      "    masterKey = plainTicket[22:54]\n",
      "\n",
      "    if not (identifier == const.TICKET_IDENTIFIER):\n",
      "        log.error(\"The ticket's HMAC is valid but the identifier is invalid.  \"\n",
      "                  \"The ticket could be corrupt.\")\n",
      "        return None\n",
      "\n",
      "    return ProtocolState(masterKey, issueDate=issueDate)\n",
      "\n",
      "\n",
      "class ProtocolState( object ):\n",
      "\n",
      "    \"\"\"\n",
      "    Defines a ScrambleSuit protocol state contained in a session ticket.\n",
      "\n",
      "    A protocol state is essentially a master key which can then be used by the\n",
      "    server to derive session keys.  Besides, a state object contains an issue\n",
      "    date which specifies the expiry date of a ticket.  This class contains\n",
      "    methods to check the expiry status of a ticket and to dump it in its raw\n",
      "    form.\n",
      "    \"\"\"\n",
      "\n",
      "    def __init__( self, masterKey, issueDate=int(time.time()) ):\n",
      "        \"\"\"\n",
      "        The constructor of the `ProtocolState' class.\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildmac/Resources/env/lib/python2.7/site-packages/obfsproxy/transports/scramblesuit/ticket.py",
    "code": [
      "        keys for the session tickets is checked.\n",
      "        \"\"\"\n",
      "\n",
      "        assert (masterKey is not None) and \\\n",
      "               len(masterKey) == const.MASTER_KEY_LENGTH\n",
      "\n",
      "        checkKeys(srvState)\n",
      "\n",
      "        # Initialisation vector for AES-CBC.\n",
      "        self.IV = mycrypto.strongRandom(const.TICKET_AES_CBC_IV_LENGTH)\n",
      "\n",
      "        # The server's (encrypted) protocol state.\n",
      "        self.state = ProtocolState(masterKey)\n",
      "\n",
      "        # AES and HMAC keys to encrypt and authenticate the ticket.\n",
      "        self.symmTicketKey = srvState.aesKey\n",
      "        self.hmacTicketKey = srvState.hmacKey\n",
      "\n",
      "    def issue( self ):\n",
      "        \"\"\"\n",
      "        Returns a ready-to-use session ticket after prior initialisation.\n",
      "\n",
      "        After the `SessionTicket()' class was initialised with a master key,\n",
      "        this method encrypts and authenticates the protocol state and returns\n",
      "        the final result which is ready to be sent over the wire.\n",
      "        \"\"\"\n",
      "\n",
      "        self.state.issueDate = int(time.time())\n",
      "\n",
      "        # Encrypt the protocol state.\n",
      "        aes = AES.new(self.symmTicketKey, mode=AES.MODE_CBC, IV=self.IV)\n",
      "        state = repr(self.state)\n",
      "        assert (len(state) % AES.block_size) == 0\n",
      "        cryptedState = aes.encrypt(state)\n",
      "\n",
      "        # Authenticate the encrypted state and the IV.\n",
      "        hmac = HMAC.new(self.hmacTicketKey,\n",
      "                        self.IV + cryptedState, digestmod=SHA256).digest()\n",
      "\n",
      "        finalTicket = self.IV + cryptedState + hmac\n",
      "        log.debug(\"Returning %d-byte ticket.\" % len(finalTicket))\n",
      "\n",
      "        return finalTicket\n",
      "\n",
      "\n",
      "# Alias class name in order to provide a more intuitive API.\n",
      "new = SessionTicket\n",
      "\n",
      "\n",
      "# Give ScrambleSuit server operators a way to manually issue new session\n",
      "# tickets for out-of-band distribution.\n",
      "if __name__ == \"__main__\":\n",
      "\n",
      "    import argparse\n",
      "\n",
      "    parser = argparse.ArgumentParser()\n",
      "    parser.add_argument(\"ip_addr\", type=str, help=\"The IPv4 address of the \"\n",
      "                        \"%s server.\" % const.TRANSPORT_NAME)\n",
      "    parser.add_argument(\"tcp_port\", type=int, help=\"The TCP port of the %s \"\n",
      "                        \"server.\" % const.TRANSPORT_NAME)\n",
      "    parser.add_argument(\"ticket_file\", type=str, help=\"The file, the newly \"\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildmac/Resources/env/lib/python2.7/site-packages/obfsproxy/test/test_aes.py",
    "code": [
      "import unittest\n",
      "\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto.Util import Counter\n",
      "\n",
      "import obfsproxy.common.aes as aes\n",
      "import twisted.trial.unittest\n",
      "\n",
      "class testAES_CTR_128_NIST(twisted.trial.unittest.TestCase):\n",
      "    def _helper_test_vector(self, input_block, output_block, plaintext, ciphertext):\n",
      "        self.assertEqual(long(input_block.encode('hex'), 16), self.ctr.next_value())\n",
      "\n",
      "        ct = self.cipher.encrypt(plaintext)\n",
      "        self.assertEqual(ct, ciphertext)\n",
      "\n",
      "        # XXX how do we extract the keystream out of the AES object?\n",
      "\n",
      "    def test_nist(self):\n",
      "        # Prepare the cipher\n",
      "        key = \"\\x2b\\x7e\\x15\\x16\\x28\\xae\\xd2\\xa6\\xab\\xf7\\x15\\x88\\x09\\xcf\\x4f\\x3c\"\n",
      "        iv = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\"\n",
      "\n",
      "        self.ctr = Counter.new(128, initial_value=long(iv.encode('hex'), 16))\n",
      "        self.cipher = AES.new(key, AES.MODE_CTR, counter=self.ctr)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\"\n",
      "        output_block = \"\\xec\\x8c\\xdf\\x73\\x98\\x60\\x7c\\xb0\\xf2\\xd2\\x16\\x75\\xea\\x9e\\xa1\\xe4\"\n",
      "        plaintext = \"\\x6b\\xc1\\xbe\\xe2\\x2e\\x40\\x9f\\x96\\xe9\\x3d\\x7e\\x11\\x73\\x93\\x17\\x2a\"\n",
      "        ciphertext = \"\\x87\\x4d\\x61\\x91\\xb6\\x20\\xe3\\x26\\x1b\\xef\\x68\\x64\\x99\\x0d\\xb6\\xce\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xff\\x00\"\n",
      "        output_block = \"\\x36\\x2b\\x7c\\x3c\\x67\\x73\\x51\\x63\\x18\\xa0\\x77\\xd7\\xfc\\x50\\x73\\xae\"\n",
      "        plaintext = \"\\xae\\x2d\\x8a\\x57\\x1e\\x03\\xac\\x9c\\x9e\\xb7\\x6f\\xac\\x45\\xaf\\x8e\\x51\"\n",
      "        ciphertext = \"\\x98\\x06\\xf6\\x6b\\x79\\x70\\xfd\\xff\\x86\\x17\\x18\\x7b\\xb9\\xff\\xfd\\xff\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xff\\x01\"\n",
      "        output_block = \"\\x6a\\x2c\\xc3\\x78\\x78\\x89\\x37\\x4f\\xbe\\xb4\\xc8\\x1b\\x17\\xba\\x6c\\x44\"\n",
      "        plaintext = \"\\x30\\xc8\\x1c\\x46\\xa3\\x5c\\xe4\\x11\\xe5\\xfb\\xc1\\x19\\x1a\\x0a\\x52\\xef\"\n",
      "        ciphertext = \"\\x5a\\xe4\\xdf\\x3e\\xdb\\xd5\\xd3\\x5e\\x5b\\x4f\\x09\\x02\\x0d\\xb0\\x3e\\xab\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xff\\x02\"\n",
      "        output_block = \"\\xe8\\x9c\\x39\\x9f\\xf0\\xf1\\x98\\xc6\\xd4\\x0a\\x31\\xdb\\x15\\x6c\\xab\\xfe\"\n",
      "        plaintext = \"\\xf6\\x9f\\x24\\x45\\xdf\\x4f\\x9b\\x17\\xad\\x2b\\x41\\x7b\\xe6\\x6c\\x37\\x10\"\n",
      "        ciphertext = \"\\x1e\\x03\\x1d\\xda\\x2f\\xbe\\x03\\xd1\\x79\\x21\\x70\\xa0\\xf3\\x00\\x9c\\xee\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "class testAES_CTR_128_simple(twisted.trial.unittest.TestCase):\n",
      "    def test_encrypt_decrypt_small_ASCII(self):\n",
      "        \"\"\"\n",
      "        Validate that decryption and encryption work as intended on a small ASCII string.\n",
      "        \"\"\"\n",
      "        self.key = \"\\xe3\\xb0\\xc4\\x42\\x98\\xfc\\x1c\\x14\\x9a\\xfb\\xf4\\xc8\\x99\\x6f\\xb9\\x24\"\n",
      "        self.iv = \"\\x27\\xae\\x41\\xe4\\x64\\x9b\\x93\\x4c\\xa4\\x95\\x99\\x1b\\x78\\x52\\xb8\\x55\"\n",
      "\n"
    ],
    "target": 23,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildmac/Resources/env/lib/python2.7/site-packages/obfsproxy/common/aes.py",
    "code": [
      "#!/usr/bin/python\n",
      "# -*- coding: utf-8 -*-\n",
      "\n",
      "\"\"\" This module is a convenience wrapper for the AES cipher in CTR mode. \"\"\"\n",
      "\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto.Util import Counter\n",
      "\n",
      "class AES_CTR_128(object):\n",
      "    \"\"\"An AES-CTR-128 PyCrypto wrapper.\"\"\"\n",
      "\n",
      "    def __init__(self, key, iv, counter_wraparound=False):\n",
      "        \"\"\"Initialize AES with the given key and IV.\n",
      "\n",
      "        If counter_wraparound is set to True, the AES-CTR counter will\n",
      "        wraparound to 0 when it overflows.\n",
      "        \"\"\"\n",
      "\n",
      "        assert(len(key) == 16)\n",
      "        assert(len(iv) == 16)\n",
      "\n",
      "        self.ctr = Counter.new(128, initial_value=long(iv.encode('hex'), 16),\n",
      "                               allow_wraparound=counter_wraparound)\n",
      "        self.cipher = AES.new(key, AES.MODE_CTR, counter=self.ctr)\n",
      "\n",
      "    def crypt(self, data):\n",
      "        \"\"\"\n",
      "        Encrypt or decrypt 'data'.\n",
      "        \"\"\"\n",
      "        return self.cipher.encrypt(data)\n",
      "\n"
    ],
    "target": 23,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildmac/Resources/env/lib/python2.7/site-packages/Crypto/Util/Counter.py",
    "code": [
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"Fast counter functions for CTR cipher modes.\n",
      "\n",
      "CTR is a chaining mode for symmetric block encryption or decryption.\n",
      "Messages are divideded into blocks, and the cipher operation takes\n",
      "place on each block using the secret key and a unique *counter block*.\n",
      "\n",
      "The most straightforward way to fulfil the uniqueness property is\n",
      "to start with an initial, random *counter block* value, and increment it as\n",
      "the next block is processed.\n",
      "\n",
      "The block ciphers from `Crypto.Cipher` (when configured in *MODE_CTR* mode)\n",
      "invoke a callable object (the *counter* parameter) to get the next *counter block*.\n",
      "Unfortunately, the Python calling protocol leads to major performance degradations.\n",
      "\n",
      "The counter functions instantiated by this module will be invoked directly\n",
      "by the ciphers in `Crypto.Cipher`. The fact that the Python layer is bypassed\n",
      "lead to more efficient (and faster) execution of CTR cipher modes.\n",
      "\n",
      "An example of usage is the following:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto.Util import Counter\n",
      "    >>>\n",
      "    >>> pt = b'\\x00'*1000000\n",
      "    >>> ctr = Counter.new(128)\n",
      "    >>> cipher = AES.new(b'\\x00'*16, AES.MODE_CTR, counter=ctr)\n",
      "    >>> ct = cipher.encrypt(pt)\n",
      "\n",
      ":undocumented: __package__\n",
      "\"\"\"\n",
      "import sys\n",
      "if sys.version_info[0] == 2 and sys.version_info[1] == 1:\n",
      "    from Crypto.Util.py21compat import *\n",
      "from Crypto.Util.py3compat import *\n",
      "\n",
      "from Crypto.Util import _counter\n",
      "import struct\n",
      "\n",
      "# Factory function\n",
      "def new(nbits, prefix=b(\"\"), suffix=b(\"\"), initial_value=1, overflow=0, little_endian=False, allow_wraparound=False, disable_shortcut=False):\n",
      "    \"\"\"Create a stateful counter block function suitable for CTR encryption modes.\n",
      "\n",
      "    Each call to the function returns the next counter block.\n",
      "    Each counter block is made up by three parts::\n",
      " \n",
      "      prefix || counter value || postfix\n",
      "\n",
      "    The counter value is incremented by one at each call.\n",
      "\n",
      "    :Parameters:\n",
      "      nbits : integer\n",
      "        Length of the desired counter, in bits. It must be a multiple of 8.\n",
      "      prefix : byte string\n",
      "        The constant prefix of the counter block. By default, no prefix is\n",
      "        used.\n",
      "      suffix : byte string\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildlinux/env32/lib/python2.7/site-packages/obfsproxy/transports/scramblesuit/mycrypto.py",
    "code": [
      "    Return `size' bytes of strong randomness suitable for cryptographic use.\n",
      "    \"\"\"\n",
      "\n",
      "    return os.urandom(size)\n",
      "\n",
      "\n",
      "class PayloadCrypter:\n",
      "\n",
      "    \"\"\"\n",
      "    Provides methods to encrypt data using AES in counter mode.\n",
      "\n",
      "    This class provides methods to set a session key as well as an\n",
      "    initialisation vector and to encrypt and decrypt data.\n",
      "    \"\"\"\n",
      "\n",
      "    def __init__( self ):\n",
      "        \"\"\"\n",
      "        Initialise a PayloadCrypter object.\n",
      "        \"\"\"\n",
      "\n",
      "        log.debug(\"Initialising AES-CTR instance.\")\n",
      "\n",
      "        self.sessionKey = None\n",
      "        self.crypter = None\n",
      "        self.counter = None\n",
      "\n",
      "    def setSessionKey( self, key, iv ):\n",
      "        \"\"\"\n",
      "        Set AES' session key and the initialisation vector for counter mode.\n",
      "\n",
      "        The given `key' and `iv' are used as 256-bit AES key and as 128-bit\n",
      "        initialisation vector for counter mode.  Both, the key as well as the\n",
      "        IV must come from a CSPRNG.\n",
      "        \"\"\"\n",
      "\n",
      "        self.sessionKey = key\n",
      "\n",
      "        # Our 128-bit counter has the following format:\n",
      "        # [ 64-bit static and random IV ] [ 64-bit incrementing counter ]\n",
      "        # Counter wrapping is not allowed which makes it possible to transfer\n",
      "        # 2^64 * 16 bytes of data while avoiding counter reuse.  That amount is\n",
      "        # effectively out of reach given today's networking performance.\n",
      "        log.debug(\"Setting IV for AES-CTR.\")\n",
      "        self.counter = Crypto.Util.Counter.new(64,\n",
      "                                               prefix = iv,\n",
      "                                               initial_value = 1,\n",
      "                                               allow_wraparound = False)\n",
      "\n",
      "        log.debug(\"Setting session key for AES-CTR.\")\n",
      "        self.crypter = Crypto.Cipher.AES.new(key, Crypto.Cipher.AES.MODE_CTR,\n",
      "                                             counter=self.counter)\n",
      "\n",
      "    def encrypt( self, data ):\n",
      "        \"\"\"\n",
      "        Encrypts the given `data' using AES in counter mode.\n",
      "        \"\"\"\n",
      "\n",
      "        return self.crypter.encrypt(data)\n",
      "\n",
      "    # Encryption equals decryption in AES-CTR.\n",
      "    decrypt = encrypt\n"
    ],
    "target": 49,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildlinux/env32/lib/python2.7/site-packages/obfsproxy/test/test_aes.py",
    "code": [
      "import unittest\n",
      "\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto.Util import Counter\n",
      "\n",
      "import obfsproxy.common.aes as aes\n",
      "import twisted.trial.unittest\n",
      "\n",
      "class testAES_CTR_128_NIST(twisted.trial.unittest.TestCase):\n",
      "    def _helper_test_vector(self, input_block, output_block, plaintext, ciphertext):\n",
      "        self.assertEqual(long(input_block.encode('hex'), 16), self.ctr.next_value())\n",
      "\n",
      "        ct = self.cipher.encrypt(plaintext)\n",
      "        self.assertEqual(ct, ciphertext)\n",
      "\n",
      "        # XXX how do we extract the keystream out of the AES object?\n",
      "\n",
      "    def test_nist(self):\n",
      "        # Prepare the cipher\n",
      "        key = \"\\x2b\\x7e\\x15\\x16\\x28\\xae\\xd2\\xa6\\xab\\xf7\\x15\\x88\\x09\\xcf\\x4f\\x3c\"\n",
      "        iv = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\"\n",
      "\n",
      "        self.ctr = Counter.new(128, initial_value=long(iv.encode('hex'), 16))\n",
      "        self.cipher = AES.new(key, AES.MODE_CTR, counter=self.ctr)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\"\n",
      "        output_block = \"\\xec\\x8c\\xdf\\x73\\x98\\x60\\x7c\\xb0\\xf2\\xd2\\x16\\x75\\xea\\x9e\\xa1\\xe4\"\n",
      "        plaintext = \"\\x6b\\xc1\\xbe\\xe2\\x2e\\x40\\x9f\\x96\\xe9\\x3d\\x7e\\x11\\x73\\x93\\x17\\x2a\"\n",
      "        ciphertext = \"\\x87\\x4d\\x61\\x91\\xb6\\x20\\xe3\\x26\\x1b\\xef\\x68\\x64\\x99\\x0d\\xb6\\xce\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xff\\x00\"\n",
      "        output_block = \"\\x36\\x2b\\x7c\\x3c\\x67\\x73\\x51\\x63\\x18\\xa0\\x77\\xd7\\xfc\\x50\\x73\\xae\"\n",
      "        plaintext = \"\\xae\\x2d\\x8a\\x57\\x1e\\x03\\xac\\x9c\\x9e\\xb7\\x6f\\xac\\x45\\xaf\\x8e\\x51\"\n",
      "        ciphertext = \"\\x98\\x06\\xf6\\x6b\\x79\\x70\\xfd\\xff\\x86\\x17\\x18\\x7b\\xb9\\xff\\xfd\\xff\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xff\\x01\"\n",
      "        output_block = \"\\x6a\\x2c\\xc3\\x78\\x78\\x89\\x37\\x4f\\xbe\\xb4\\xc8\\x1b\\x17\\xba\\x6c\\x44\"\n",
      "        plaintext = \"\\x30\\xc8\\x1c\\x46\\xa3\\x5c\\xe4\\x11\\xe5\\xfb\\xc1\\x19\\x1a\\x0a\\x52\\xef\"\n",
      "        ciphertext = \"\\x5a\\xe4\\xdf\\x3e\\xdb\\xd5\\xd3\\x5e\\x5b\\x4f\\x09\\x02\\x0d\\xb0\\x3e\\xab\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xff\\x02\"\n",
      "        output_block = \"\\xe8\\x9c\\x39\\x9f\\xf0\\xf1\\x98\\xc6\\xd4\\x0a\\x31\\xdb\\x15\\x6c\\xab\\xfe\"\n",
      "        plaintext = \"\\xf6\\x9f\\x24\\x45\\xdf\\x4f\\x9b\\x17\\xad\\x2b\\x41\\x7b\\xe6\\x6c\\x37\\x10\"\n",
      "        ciphertext = \"\\x1e\\x03\\x1d\\xda\\x2f\\xbe\\x03\\xd1\\x79\\x21\\x70\\xa0\\xf3\\x00\\x9c\\xee\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "class testAES_CTR_128_simple(twisted.trial.unittest.TestCase):\n",
      "    def test_encrypt_decrypt_small_ASCII(self):\n",
      "        \"\"\"\n",
      "        Validate that decryption and encryption work as intended on a small ASCII string.\n",
      "        \"\"\"\n",
      "        self.key = \"\\xe3\\xb0\\xc4\\x42\\x98\\xfc\\x1c\\x14\\x9a\\xfb\\xf4\\xc8\\x99\\x6f\\xb9\\x24\"\n",
      "        self.iv = \"\\x27\\xae\\x41\\xe4\\x64\\x9b\\x93\\x4c\\xa4\\x95\\x99\\x1b\\x78\\x52\\xb8\\x55\"\n",
      "\n"
    ],
    "target": 23,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildlinux/env32/lib/python2.7/site-packages/Crypto/Cipher/AES.py",
    "code": [
      "# everyone is granted a worldwide, perpetual, royalty-free,\n",
      "# non-exclusive license to exercise all rights associated with the\n",
      "# contents of this file for any purpose whatsoever.\n",
      "# No rights are reserved.\n",
      "#\n",
      "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n",
      "# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n",
      "# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n",
      "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n",
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"AES symmetric cipher\n",
      "\n",
      "AES `(Advanced Encryption Standard)`__ is a symmetric block cipher standardized\n",
      "by NIST_ . It has a fixed data block size of 16 bytes.\n",
      "Its keys can be 128, 192, or 256 bits long.\n",
      "\n",
      "AES is very fast and secure, and it is the de facto standard for symmetric\n",
      "encryption.\n",
      "\n",
      "As an example, encryption can be done as follows:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto import Random\n",
      "    >>>\n",
      "    >>> key = b'Sixteen byte key'\n",
      "    >>> iv = Random.new().read(AES.block_size)\n",
      "    >>> cipher = AES.new(key, AES.MODE_CFB, iv)\n",
      "    >>> msg = iv + cipher.encrypt(b'Attack at dawn')\n",
      "\n",
      ".. __: http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n",
      ".. _NIST: http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf\n",
      "\n",
      ":undocumented: __revision__, __package__\n",
      "\"\"\"\n",
      "\n",
      "__revision__ = \"$Id$\"\n",
      "\n",
      "from Crypto.Cipher import blockalgo\n",
      "from Crypto.Cipher import _AES\n",
      "\n",
      "class AESCipher (blockalgo.BlockAlgo):\n",
      "    \"\"\"AES cipher object\"\"\"\n",
      "\n",
      "    def __init__(self, key, *args, **kwargs):\n",
      "        \"\"\"Initialize an AES cipher object\n",
      "        \n",
      "        See also `new()` at the module level.\"\"\"\n",
      "        blockalgo.BlockAlgo.__init__(self, _AES, key, *args, **kwargs)\n",
      "\n",
      "def new(key, *args, **kwargs):\n",
      "    \"\"\"Create a new AES cipher\n",
      "\n",
      "    :Parameters:\n",
      "      key : byte string\n",
      "        The secret key to use in the symmetric cipher.\n",
      "        It must be 16 (*AES-128*), 24 (*AES-192*), or 32 (*AES-256*) bytes long.\n",
      "    :Keywords:\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildlinux/env64/lib/python2.7/site-packages/obfsproxy/transports/scramblesuit/mycrypto.py",
    "code": [
      "    Return `size' bytes of strong randomness suitable for cryptographic use.\n",
      "    \"\"\"\n",
      "\n",
      "    return os.urandom(size)\n",
      "\n",
      "\n",
      "class PayloadCrypter:\n",
      "\n",
      "    \"\"\"\n",
      "    Provides methods to encrypt data using AES in counter mode.\n",
      "\n",
      "    This class provides methods to set a session key as well as an\n",
      "    initialisation vector and to encrypt and decrypt data.\n",
      "    \"\"\"\n",
      "\n",
      "    def __init__( self ):\n",
      "        \"\"\"\n",
      "        Initialise a PayloadCrypter object.\n",
      "        \"\"\"\n",
      "\n",
      "        log.debug(\"Initialising AES-CTR instance.\")\n",
      "\n",
      "        self.sessionKey = None\n",
      "        self.crypter = None\n",
      "        self.counter = None\n",
      "\n",
      "    def setSessionKey( self, key, iv ):\n",
      "        \"\"\"\n",
      "        Set AES' session key and the initialisation vector for counter mode.\n",
      "\n",
      "        The given `key' and `iv' are used as 256-bit AES key and as 128-bit\n",
      "        initialisation vector for counter mode.  Both, the key as well as the\n",
      "        IV must come from a CSPRNG.\n",
      "        \"\"\"\n",
      "\n",
      "        self.sessionKey = key\n",
      "\n",
      "        # Our 128-bit counter has the following format:\n",
      "        # [ 64-bit static and random IV ] [ 64-bit incrementing counter ]\n",
      "        # Counter wrapping is not allowed which makes it possible to transfer\n",
      "        # 2^64 * 16 bytes of data while avoiding counter reuse.  That amount is\n",
      "        # effectively out of reach given today's networking performance.\n",
      "        log.debug(\"Setting IV for AES-CTR.\")\n",
      "        self.counter = Crypto.Util.Counter.new(64,\n",
      "                                               prefix = iv,\n",
      "                                               initial_value = 1,\n",
      "                                               allow_wraparound = False)\n",
      "\n",
      "        log.debug(\"Setting session key for AES-CTR.\")\n",
      "        self.crypter = Crypto.Cipher.AES.new(key, Crypto.Cipher.AES.MODE_CTR,\n",
      "                                             counter=self.counter)\n",
      "\n",
      "    def encrypt( self, data ):\n",
      "        \"\"\"\n",
      "        Encrypts the given `data' using AES in counter mode.\n",
      "        \"\"\"\n",
      "\n",
      "        return self.crypter.encrypt(data)\n",
      "\n",
      "    # Encryption equals decryption in AES-CTR.\n",
      "    decrypt = encrypt\n"
    ],
    "target": 49,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildlinux/env64/lib/python2.7/site-packages/obfsproxy/common/aes.py",
    "code": [
      "#!/usr/bin/python\n",
      "# -*- coding: utf-8 -*-\n",
      "\n",
      "\"\"\" This module is a convenience wrapper for the AES cipher in CTR mode. \"\"\"\n",
      "\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto.Util import Counter\n",
      "\n",
      "class AES_CTR_128(object):\n",
      "    \"\"\"An AES-CTR-128 PyCrypto wrapper.\"\"\"\n",
      "\n",
      "    def __init__(self, key, iv, counter_wraparound=False):\n",
      "        \"\"\"Initialize AES with the given key and IV.\n",
      "\n",
      "        If counter_wraparound is set to True, the AES-CTR counter will\n",
      "        wraparound to 0 when it overflows.\n",
      "        \"\"\"\n",
      "\n",
      "        assert(len(key) == 16)\n",
      "        assert(len(iv) == 16)\n",
      "\n",
      "        self.ctr = Counter.new(128, initial_value=long(iv.encode('hex'), 16),\n",
      "                               allow_wraparound=counter_wraparound)\n",
      "        self.cipher = AES.new(key, AES.MODE_CTR, counter=self.ctr)\n",
      "\n",
      "    def crypt(self, data):\n",
      "        \"\"\"\n",
      "        Encrypt or decrypt 'data'.\n",
      "        \"\"\"\n",
      "        return self.cipher.encrypt(data)\n",
      "\n"
    ],
    "target": 23,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildlinux/env64/lib/python2.7/site-packages/Crypto/Cipher/AES.py",
    "code": [
      "# everyone is granted a worldwide, perpetual, royalty-free,\n",
      "# non-exclusive license to exercise all rights associated with the\n",
      "# contents of this file for any purpose whatsoever.\n",
      "# No rights are reserved.\n",
      "#\n",
      "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n",
      "# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n",
      "# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n",
      "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n",
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"AES symmetric cipher\n",
      "\n",
      "AES `(Advanced Encryption Standard)`__ is a symmetric block cipher standardized\n",
      "by NIST_ . It has a fixed data block size of 16 bytes.\n",
      "Its keys can be 128, 192, or 256 bits long.\n",
      "\n",
      "AES is very fast and secure, and it is the de facto standard for symmetric\n",
      "encryption.\n",
      "\n",
      "As an example, encryption can be done as follows:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto import Random\n",
      "    >>>\n",
      "    >>> key = b'Sixteen byte key'\n",
      "    >>> iv = Random.new().read(AES.block_size)\n",
      "    >>> cipher = AES.new(key, AES.MODE_CFB, iv)\n",
      "    >>> msg = iv + cipher.encrypt(b'Attack at dawn')\n",
      "\n",
      ".. __: http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n",
      ".. _NIST: http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf\n",
      "\n",
      ":undocumented: __revision__, __package__\n",
      "\"\"\"\n",
      "\n",
      "__revision__ = \"$Id$\"\n",
      "\n",
      "from Crypto.Cipher import blockalgo\n",
      "from Crypto.Cipher import _AES\n",
      "\n",
      "class AESCipher (blockalgo.BlockAlgo):\n",
      "    \"\"\"AES cipher object\"\"\"\n",
      "\n",
      "    def __init__(self, key, *args, **kwargs):\n",
      "        \"\"\"Initialize an AES cipher object\n",
      "        \n",
      "        See also `new()` at the module level.\"\"\"\n",
      "        blockalgo.BlockAlgo.__init__(self, _AES, key, *args, **kwargs)\n",
      "\n",
      "def new(key, *args, **kwargs):\n",
      "    \"\"\"Create a new AES cipher\n",
      "\n",
      "    :Parameters:\n",
      "      key : byte string\n",
      "        The secret key to use in the symmetric cipher.\n",
      "        It must be 16 (*AES-128*), 24 (*AES-192*), or 32 (*AES-256*) bytes long.\n",
      "    :Keywords:\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Mac/buildmac/Resources/env/lib/python2.7/site-packages/obfsproxy/test/test_aes.py",
    "code": [
      "import unittest\n",
      "\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto.Util import Counter\n",
      "\n",
      "import obfsproxy.common.aes as aes\n",
      "import twisted.trial.unittest\n",
      "\n",
      "class testAES_CTR_128_NIST(twisted.trial.unittest.TestCase):\n",
      "    def _helper_test_vector(self, input_block, output_block, plaintext, ciphertext):\n",
      "        self.assertEqual(long(input_block.encode('hex'), 16), self.ctr.next_value())\n",
      "\n",
      "        ct = self.cipher.encrypt(plaintext)\n",
      "        self.assertEqual(ct, ciphertext)\n",
      "\n",
      "        # XXX how do we extract the keystream out of the AES object?\n",
      "\n",
      "    def test_nist(self):\n",
      "        # Prepare the cipher\n",
      "        key = \"\\x2b\\x7e\\x15\\x16\\x28\\xae\\xd2\\xa6\\xab\\xf7\\x15\\x88\\x09\\xcf\\x4f\\x3c\"\n",
      "        iv = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\"\n",
      "\n",
      "        self.ctr = Counter.new(128, initial_value=long(iv.encode('hex'), 16))\n",
      "        self.cipher = AES.new(key, AES.MODE_CTR, counter=self.ctr)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\"\n",
      "        output_block = \"\\xec\\x8c\\xdf\\x73\\x98\\x60\\x7c\\xb0\\xf2\\xd2\\x16\\x75\\xea\\x9e\\xa1\\xe4\"\n",
      "        plaintext = \"\\x6b\\xc1\\xbe\\xe2\\x2e\\x40\\x9f\\x96\\xe9\\x3d\\x7e\\x11\\x73\\x93\\x17\\x2a\"\n",
      "        ciphertext = \"\\x87\\x4d\\x61\\x91\\xb6\\x20\\xe3\\x26\\x1b\\xef\\x68\\x64\\x99\\x0d\\xb6\\xce\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xff\\x00\"\n",
      "        output_block = \"\\x36\\x2b\\x7c\\x3c\\x67\\x73\\x51\\x63\\x18\\xa0\\x77\\xd7\\xfc\\x50\\x73\\xae\"\n",
      "        plaintext = \"\\xae\\x2d\\x8a\\x57\\x1e\\x03\\xac\\x9c\\x9e\\xb7\\x6f\\xac\\x45\\xaf\\x8e\\x51\"\n",
      "        ciphertext = \"\\x98\\x06\\xf6\\x6b\\x79\\x70\\xfd\\xff\\x86\\x17\\x18\\x7b\\xb9\\xff\\xfd\\xff\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xff\\x01\"\n",
      "        output_block = \"\\x6a\\x2c\\xc3\\x78\\x78\\x89\\x37\\x4f\\xbe\\xb4\\xc8\\x1b\\x17\\xba\\x6c\\x44\"\n",
      "        plaintext = \"\\x30\\xc8\\x1c\\x46\\xa3\\x5c\\xe4\\x11\\xe5\\xfb\\xc1\\x19\\x1a\\x0a\\x52\\xef\"\n",
      "        ciphertext = \"\\x5a\\xe4\\xdf\\x3e\\xdb\\xd5\\xd3\\x5e\\x5b\\x4f\\x09\\x02\\x0d\\xb0\\x3e\\xab\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xff\\x02\"\n",
      "        output_block = \"\\xe8\\x9c\\x39\\x9f\\xf0\\xf1\\x98\\xc6\\xd4\\x0a\\x31\\xdb\\x15\\x6c\\xab\\xfe\"\n",
      "        plaintext = \"\\xf6\\x9f\\x24\\x45\\xdf\\x4f\\x9b\\x17\\xad\\x2b\\x41\\x7b\\xe6\\x6c\\x37\\x10\"\n",
      "        ciphertext = \"\\x1e\\x03\\x1d\\xda\\x2f\\xbe\\x03\\xd1\\x79\\x21\\x70\\xa0\\xf3\\x00\\x9c\\xee\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "class testAES_CTR_128_simple(twisted.trial.unittest.TestCase):\n",
      "    def test_encrypt_decrypt_small_ASCII(self):\n",
      "        \"\"\"\n",
      "        Validate that decryption and encryption work as intended on a small ASCII string.\n",
      "        \"\"\"\n",
      "        self.key = \"\\xe3\\xb0\\xc4\\x42\\x98\\xfc\\x1c\\x14\\x9a\\xfb\\xf4\\xc8\\x99\\x6f\\xb9\\x24\"\n",
      "        self.iv = \"\\x27\\xae\\x41\\xe4\\x64\\x9b\\x93\\x4c\\xa4\\x95\\x99\\x1b\\x78\\x52\\xb8\\x55\"\n",
      "\n"
    ],
    "target": 23,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Mac/buildmac/Resources/env/lib/python2.7/site-packages/obfsproxy/common/aes.py",
    "code": [
      "#!/usr/bin/python\n",
      "# -*- coding: utf-8 -*-\n",
      "\n",
      "\"\"\" This module is a convenience wrapper for the AES cipher in CTR mode. \"\"\"\n",
      "\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto.Util import Counter\n",
      "\n",
      "class AES_CTR_128(object):\n",
      "    \"\"\"An AES-CTR-128 PyCrypto wrapper.\"\"\"\n",
      "\n",
      "    def __init__(self, key, iv, counter_wraparound=False):\n",
      "        \"\"\"Initialize AES with the given key and IV.\n",
      "\n",
      "        If counter_wraparound is set to True, the AES-CTR counter will\n",
      "        wraparound to 0 when it overflows.\n",
      "        \"\"\"\n",
      "\n",
      "        assert(len(key) == 16)\n",
      "        assert(len(iv) == 16)\n",
      "\n",
      "        self.ctr = Counter.new(128, initial_value=long(iv.encode('hex'), 16),\n",
      "                               allow_wraparound=counter_wraparound)\n",
      "        self.cipher = AES.new(key, AES.MODE_CTR, counter=self.ctr)\n",
      "\n",
      "    def crypt(self, data):\n",
      "        \"\"\"\n",
      "        Encrypt or decrypt 'data'.\n",
      "        \"\"\"\n",
      "        return self.cipher.encrypt(data)\n",
      "\n"
    ],
    "target": 23,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Mac/buildmac/Resources/env/lib/python2.7/site-packages/Crypto/Util/Counter.py",
    "code": [
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"Fast counter functions for CTR cipher modes.\n",
      "\n",
      "CTR is a chaining mode for symmetric block encryption or decryption.\n",
      "Messages are divideded into blocks, and the cipher operation takes\n",
      "place on each block using the secret key and a unique *counter block*.\n",
      "\n",
      "The most straightforward way to fulfil the uniqueness property is\n",
      "to start with an initial, random *counter block* value, and increment it as\n",
      "the next block is processed.\n",
      "\n",
      "The block ciphers from `Crypto.Cipher` (when configured in *MODE_CTR* mode)\n",
      "invoke a callable object (the *counter* parameter) to get the next *counter block*.\n",
      "Unfortunately, the Python calling protocol leads to major performance degradations.\n",
      "\n",
      "The counter functions instantiated by this module will be invoked directly\n",
      "by the ciphers in `Crypto.Cipher`. The fact that the Python layer is bypassed\n",
      "lead to more efficient (and faster) execution of CTR cipher modes.\n",
      "\n",
      "An example of usage is the following:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto.Util import Counter\n",
      "    >>>\n",
      "    >>> pt = b'\\x00'*1000000\n",
      "    >>> ctr = Counter.new(128)\n",
      "    >>> cipher = AES.new(b'\\x00'*16, AES.MODE_CTR, counter=ctr)\n",
      "    >>> ct = cipher.encrypt(pt)\n",
      "\n",
      ":undocumented: __package__\n",
      "\"\"\"\n",
      "import sys\n",
      "if sys.version_info[0] == 2 and sys.version_info[1] == 1:\n",
      "    from Crypto.Util.py21compat import *\n",
      "from Crypto.Util.py3compat import *\n",
      "\n",
      "from Crypto.Util import _counter\n",
      "import struct\n",
      "\n",
      "# Factory function\n",
      "def new(nbits, prefix=b(\"\"), suffix=b(\"\"), initial_value=1, overflow=0, little_endian=False, allow_wraparound=False, disable_shortcut=False):\n",
      "    \"\"\"Create a stateful counter block function suitable for CTR encryption modes.\n",
      "\n",
      "    Each call to the function returns the next counter block.\n",
      "    Each counter block is made up by three parts::\n",
      " \n",
      "      prefix || counter value || postfix\n",
      "\n",
      "    The counter value is incremented by one at each call.\n",
      "\n",
      "    :Parameters:\n",
      "      nbits : integer\n",
      "        Length of the desired counter, in bits. It must be a multiple of 8.\n",
      "      prefix : byte string\n",
      "        The constant prefix of the counter block. By default, no prefix is\n",
      "        used.\n",
      "      suffix : byte string\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Mac/buildlinux/env32/lib/python2.7/site-packages/Crypto/Cipher/AES.py",
    "code": [
      "# everyone is granted a worldwide, perpetual, royalty-free,\n",
      "# non-exclusive license to exercise all rights associated with the\n",
      "# contents of this file for any purpose whatsoever.\n",
      "# No rights are reserved.\n",
      "#\n",
      "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n",
      "# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n",
      "# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n",
      "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n",
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"AES symmetric cipher\n",
      "\n",
      "AES `(Advanced Encryption Standard)`__ is a symmetric block cipher standardized\n",
      "by NIST_ . It has a fixed data block size of 16 bytes.\n",
      "Its keys can be 128, 192, or 256 bits long.\n",
      "\n",
      "AES is very fast and secure, and it is the de facto standard for symmetric\n",
      "encryption.\n",
      "\n",
      "As an example, encryption can be done as follows:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto import Random\n",
      "    >>>\n",
      "    >>> key = b'Sixteen byte key'\n",
      "    >>> iv = Random.new().read(AES.block_size)\n",
      "    >>> cipher = AES.new(key, AES.MODE_CFB, iv)\n",
      "    >>> msg = iv + cipher.encrypt(b'Attack at dawn')\n",
      "\n",
      ".. __: http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n",
      ".. _NIST: http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf\n",
      "\n",
      ":undocumented: __revision__, __package__\n",
      "\"\"\"\n",
      "\n",
      "__revision__ = \"$Id$\"\n",
      "\n",
      "from Crypto.Cipher import blockalgo\n",
      "from Crypto.Cipher import _AES\n",
      "\n",
      "class AESCipher (blockalgo.BlockAlgo):\n",
      "    \"\"\"AES cipher object\"\"\"\n",
      "\n",
      "    def __init__(self, key, *args, **kwargs):\n",
      "        \"\"\"Initialize an AES cipher object\n",
      "        \n",
      "        See also `new()` at the module level.\"\"\"\n",
      "        blockalgo.BlockAlgo.__init__(self, _AES, key, *args, **kwargs)\n",
      "\n",
      "def new(key, *args, **kwargs):\n",
      "    \"\"\"Create a new AES cipher\n",
      "\n",
      "    :Parameters:\n",
      "      key : byte string\n",
      "        The secret key to use in the symmetric cipher.\n",
      "        It must be 16 (*AES-128*), 24 (*AES-192*), or 32 (*AES-256*) bytes long.\n",
      "    :Keywords:\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Mac/buildlinux/env32/lib/python2.7/site-packages/Crypto/Util/Counter.py",
    "code": [
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"Fast counter functions for CTR cipher modes.\n",
      "\n",
      "CTR is a chaining mode for symmetric block encryption or decryption.\n",
      "Messages are divideded into blocks, and the cipher operation takes\n",
      "place on each block using the secret key and a unique *counter block*.\n",
      "\n",
      "The most straightforward way to fulfil the uniqueness property is\n",
      "to start with an initial, random *counter block* value, and increment it as\n",
      "the next block is processed.\n",
      "\n",
      "The block ciphers from `Crypto.Cipher` (when configured in *MODE_CTR* mode)\n",
      "invoke a callable object (the *counter* parameter) to get the next *counter block*.\n",
      "Unfortunately, the Python calling protocol leads to major performance degradations.\n",
      "\n",
      "The counter functions instantiated by this module will be invoked directly\n",
      "by the ciphers in `Crypto.Cipher`. The fact that the Python layer is bypassed\n",
      "lead to more efficient (and faster) execution of CTR cipher modes.\n",
      "\n",
      "An example of usage is the following:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto.Util import Counter\n",
      "    >>>\n",
      "    >>> pt = b'\\x00'*1000000\n",
      "    >>> ctr = Counter.new(128)\n",
      "    >>> cipher = AES.new(b'\\x00'*16, AES.MODE_CTR, counter=ctr)\n",
      "    >>> ct = cipher.encrypt(pt)\n",
      "\n",
      ":undocumented: __package__\n",
      "\"\"\"\n",
      "import sys\n",
      "if sys.version_info[0] == 2 and sys.version_info[1] == 1:\n",
      "    from Crypto.Util.py21compat import *\n",
      "from Crypto.Util.py3compat import *\n",
      "\n",
      "from Crypto.Util import _counter\n",
      "import struct\n",
      "\n",
      "# Factory function\n",
      "def new(nbits, prefix=b(\"\"), suffix=b(\"\"), initial_value=1, overflow=0, little_endian=False, allow_wraparound=False, disable_shortcut=False):\n",
      "    \"\"\"Create a stateful counter block function suitable for CTR encryption modes.\n",
      "\n",
      "    Each call to the function returns the next counter block.\n",
      "    Each counter block is made up by three parts::\n",
      " \n",
      "      prefix || counter value || postfix\n",
      "\n",
      "    The counter value is incremented by one at each call.\n",
      "\n",
      "    :Parameters:\n",
      "      nbits : integer\n",
      "        Length of the desired counter, in bits. It must be a multiple of 8.\n",
      "      prefix : byte string\n",
      "        The constant prefix of the counter block. By default, no prefix is\n",
      "        used.\n",
      "      suffix : byte string\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Mac/buildlinux/env32/lib/python2.7/site-packages/Crypto/Random/Fortuna/FortunaGenerator.py",
    "code": [
      "        assert (1 << self.block_size_shift) == self.block_size\n",
      "\n",
      "        self.blocks_per_key = exact_div(self.key_size, self.block_size)\n",
      "        assert self.key_size == self.blocks_per_key * self.block_size\n",
      "\n",
      "        self.max_bytes_per_request = self.max_blocks_per_request * self.block_size\n",
      "\n",
      "    def reseed(self, seed):\n",
      "        if self.key is None:\n",
      "            self.key = b(\"\\0\") * self.key_size\n",
      "\n",
      "        self._set_key(SHAd256.new(self.key + seed).digest())\n",
      "        self.counter()  # increment counter\n",
      "        assert len(self.key) == self.key_size\n",
      "\n",
      "    def pseudo_random_data(self, bytes):\n",
      "        assert bytes >= 0\n",
      "\n",
      "        num_full_blocks = bytes >> 20\n",
      "        remainder = bytes & ((1<<20)-1)\n",
      "\n",
      "        retval = []\n",
      "        for i in xrange(num_full_blocks):\n",
      "            retval.append(self._pseudo_random_data(1<<20))\n",
      "        retval.append(self._pseudo_random_data(remainder))\n",
      "        \n",
      "        return b(\"\").join(retval)  \n",
      "\n",
      "    def _set_key(self, key):\n",
      "        self.key = key\n",
      "        self._cipher = AES.new(key, AES.MODE_CTR, counter=self.counter)\n",
      "\n",
      "    def _pseudo_random_data(self, bytes):\n",
      "        if not (0 <= bytes <= self.max_bytes_per_request):\n",
      "            raise AssertionError(\"You cannot ask for more than 1 MiB of data per request\")\n",
      "\n",
      "        num_blocks = ceil_shift(bytes, self.block_size_shift)   # num_blocks = ceil(bytes / self.block_size)\n",
      "\n",
      "        # Compute the output\n",
      "        retval = self._generate_blocks(num_blocks)[:bytes]\n",
      "\n",
      "        # Switch to a new key to avoid later compromises of this output (i.e.\n",
      "        # state compromise extension attacks)\n",
      "        self._set_key(self._generate_blocks(self.blocks_per_key))\n",
      "\n",
      "        assert len(retval) == bytes\n",
      "        assert len(self.key) == self.key_size\n",
      "\n",
      "        return retval\n",
      "\n",
      "    def _generate_blocks(self, num_blocks):\n",
      "        if self.key is None:\n",
      "            raise AssertionError(\"generator must be seeded before use\")\n",
      "        assert 0 <= num_blocks <= self.max_blocks_per_request\n",
      "        retval = []\n",
      "        for i in xrange(num_blocks >> 12):      # xrange(num_blocks / 4096)\n",
      "            retval.append(self._cipher.encrypt(self._four_kiblocks_of_zeros))\n",
      "        remaining_bytes = (num_blocks & 4095) << self.block_size_shift  # (num_blocks % 4095) * self.block_size\n",
      "        retval.append(self._cipher.encrypt(self._four_kiblocks_of_zeros[:remaining_bytes]))\n",
      "        return b(\"\").join(retval)\n",
      "\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Mac/buildlinux/env64/lib/python2.7/site-packages/Crypto/Cipher/AES.py",
    "code": [
      "# everyone is granted a worldwide, perpetual, royalty-free,\n",
      "# non-exclusive license to exercise all rights associated with the\n",
      "# contents of this file for any purpose whatsoever.\n",
      "# No rights are reserved.\n",
      "#\n",
      "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n",
      "# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n",
      "# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n",
      "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n",
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"AES symmetric cipher\n",
      "\n",
      "AES `(Advanced Encryption Standard)`__ is a symmetric block cipher standardized\n",
      "by NIST_ . It has a fixed data block size of 16 bytes.\n",
      "Its keys can be 128, 192, or 256 bits long.\n",
      "\n",
      "AES is very fast and secure, and it is the de facto standard for symmetric\n",
      "encryption.\n",
      "\n",
      "As an example, encryption can be done as follows:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto import Random\n",
      "    >>>\n",
      "    >>> key = b'Sixteen byte key'\n",
      "    >>> iv = Random.new().read(AES.block_size)\n",
      "    >>> cipher = AES.new(key, AES.MODE_CFB, iv)\n",
      "    >>> msg = iv + cipher.encrypt(b'Attack at dawn')\n",
      "\n",
      ".. __: http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n",
      ".. _NIST: http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf\n",
      "\n",
      ":undocumented: __revision__, __package__\n",
      "\"\"\"\n",
      "\n",
      "__revision__ = \"$Id$\"\n",
      "\n",
      "from Crypto.Cipher import blockalgo\n",
      "from Crypto.Cipher import _AES\n",
      "\n",
      "class AESCipher (blockalgo.BlockAlgo):\n",
      "    \"\"\"AES cipher object\"\"\"\n",
      "\n",
      "    def __init__(self, key, *args, **kwargs):\n",
      "        \"\"\"Initialize an AES cipher object\n",
      "        \n",
      "        See also `new()` at the module level.\"\"\"\n",
      "        blockalgo.BlockAlgo.__init__(self, _AES, key, *args, **kwargs)\n",
      "\n",
      "def new(key, *args, **kwargs):\n",
      "    \"\"\"Create a new AES cipher\n",
      "\n",
      "    :Parameters:\n",
      "      key : byte string\n",
      "        The secret key to use in the symmetric cipher.\n",
      "        It must be 16 (*AES-128*), 24 (*AES-192*), or 32 (*AES-256*) bytes long.\n",
      "    :Keywords:\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/Hackplayers/Empire-mod-Hpys-tests/lib/common/encryption.py",
    "code": [
      "        # parse the xml DOM and extract the exponent/modulus\n",
      "        dom = parseString(xml)\n",
      "        e = base64.b64decode(dom.getElementsByTagName('Exponent')[0].childNodes[0].data)\n",
      "        n = base64.b64decode(dom.getElementsByTagName('Modulus')[0].childNodes[0].data)\n",
      "\n",
      "        # build the new key\n",
      "        key = M2Crypto.RSA.new_pub_key((\n",
      "            M2Crypto.m2.bn_to_mpi(M2Crypto.m2.hex_to_bn(hexlify(e))),\n",
      "            M2Crypto.m2.bn_to_mpi(M2Crypto.m2.hex_to_bn(hexlify(n))),\n",
      "            ))\n",
      "\n",
      "        return key\n",
      "    # if there's an XML parsing error, return None\n",
      "    except:\n",
      "        return None\n",
      "\n",
      "\n",
      "def rsa_encrypt(key, data):\n",
      "    \"\"\"\n",
      "    Take a M2Crypto key object and use it to encrypt the passed data.\n",
      "    \"\"\"\n",
      "    return key.public_encrypt(data, M2Crypto.RSA.pkcs1_padding)\n",
      "\n",
      "\n",
      "def aes_encrypt(key, data):\n",
      "    \"\"\"\n",
      "    Generate a random IV and new AES cipher object with the given\n",
      "    key, and return IV + encryptedData.\n",
      "    \"\"\"\n",
      "    IV = Random.new().read(16)\n",
      "    cipher = AES.new(key, AES.MODE_CBC, IV)\n",
      "    return IV + cipher.encrypt(pad(data))\n",
      "\n",
      "\n",
      "def aes_encrypt_then_hmac(key, data):\n",
      "    \"\"\"\n",
      "    Encrypt the data then calculate HMAC over the ciphertext.\n",
      "    \"\"\"\n",
      "    data = aes_encrypt(key, data)\n",
      "    mac = hmac.new(str(key), data, hashlib.sha256).digest()\n",
      "    return data + mac[0:10]\n",
      "\n",
      "\n",
      "def aes_decrypt(key, data):\n",
      "    \"\"\"\n",
      "    Generate an AES cipher object, pull out the IV from the data\n",
      "    and return the unencrypted data.\n",
      "    \"\"\"\n",
      "    if len(data) > 16:\n",
      "        IV = data[0:16]\n",
      "        cipher = AES.new(key, AES.MODE_CBC, IV)\n",
      "        return depad(cipher.decrypt(data[16:]))\n",
      "\n",
      "\n",
      "def verify_hmac(key, data):\n",
      "    \"\"\"\n",
      "    Verify the HMAC supplied in the data with the given key.\n",
      "    \"\"\"\n",
      "    if len(data) > 20:\n",
      "        mac = data[-10:]\n",
      "        data = data[:-10]\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/Hackplayers/Empire-mod-Hpys-tests/lib/common/encryption.py",
    "code": [
      "    \"\"\"\n",
      "    return key.public_encrypt(data, M2Crypto.RSA.pkcs1_padding)\n",
      "\n",
      "\n",
      "def aes_encrypt(key, data):\n",
      "    \"\"\"\n",
      "    Generate a random IV and new AES cipher object with the given\n",
      "    key, and return IV + encryptedData.\n",
      "    \"\"\"\n",
      "    IV = Random.new().read(16)\n",
      "    cipher = AES.new(key, AES.MODE_CBC, IV)\n",
      "    return IV + cipher.encrypt(pad(data))\n",
      "\n",
      "\n",
      "def aes_encrypt_then_hmac(key, data):\n",
      "    \"\"\"\n",
      "    Encrypt the data then calculate HMAC over the ciphertext.\n",
      "    \"\"\"\n",
      "    data = aes_encrypt(key, data)\n",
      "    mac = hmac.new(str(key), data, hashlib.sha256).digest()\n",
      "    return data + mac[0:10]\n",
      "\n",
      "\n",
      "def aes_decrypt(key, data):\n",
      "    \"\"\"\n",
      "    Generate an AES cipher object, pull out the IV from the data\n",
      "    and return the unencrypted data.\n",
      "    \"\"\"\n",
      "    if len(data) > 16:\n",
      "        IV = data[0:16]\n",
      "        cipher = AES.new(key, AES.MODE_CBC, IV)\n",
      "        return depad(cipher.decrypt(data[16:]))\n",
      "\n",
      "\n",
      "def verify_hmac(key, data):\n",
      "    \"\"\"\n",
      "    Verify the HMAC supplied in the data with the given key.\n",
      "    \"\"\"\n",
      "    if len(data) > 20:\n",
      "        mac = data[-10:]\n",
      "        data = data[:-10]\n",
      "        expected = hmac.new(key, data, hashlib.sha256).digest()[0:10]\n",
      "        # Double HMAC to prevent timing attacks. hmac.compare_digest() is\n",
      "        # preferable, but only available since Python 2.7.7.\n",
      "        return hmac.new(str(key), expected).digest() == hmac.new(str(key), mac).digest()\n",
      "    else:\n",
      "        return False\n",
      "\n",
      "\n",
      "def aes_decrypt_and_verify(key, data):\n",
      "    \"\"\"\n",
      "    Decrypt the data, but only if it has a valid MAC.\n",
      "    \"\"\"\n",
      "    if len(data) > 32 and verify_hmac(key, data):\n",
      "        return aes_decrypt(key, data[:-10])\n",
      "    raise Exception(\"Invalid ciphertext received.\")\n",
      "\n",
      "\n",
      "def generate_aes_key():\n",
      "    \"\"\"\n",
      "    Generate a random new 128-bit AES key using Pycrypto's secure Random functions.\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/frankyrumple/smc/modules/paramiko/transport.py",
    "code": [
      "\n",
      "def _join_lingering_threads():\n",
      "    for thr in _active_threads:\n",
      "        thr.stop_thread()\n",
      "\n",
      "import atexit\n",
      "atexit.register(_join_lingering_threads)\n",
      "\n",
      "\n",
      "class Transport (threading.Thread, ClosingContextManager):\n",
      "    \"\"\"\n",
      "    An SSH Transport attaches to a stream (usually a socket), negotiates an\n",
      "    encrypted session, authenticates, and then creates stream tunnels, called\n",
      "    `channels <.Channel>`, across the session.  Multiple channels can be\n",
      "    multiplexed across a single session (and often are, in the case of port\n",
      "    forwardings).\n",
      "\n",
      "    Instances of this class may be used as context managers.\n",
      "    \"\"\"\n",
      "    _PROTO_ID = '2.0'\n",
      "    _CLIENT_ID = 'paramiko_%s' % paramiko.__version__\n",
      "\n",
      "    _preferred_ciphers = ('aes128-ctr', 'aes256-ctr', 'aes128-cbc', 'blowfish-cbc',\n",
      "                          'aes256-cbc', '3des-cbc', 'arcfour128', 'arcfour256')\n",
      "    _preferred_macs = ('hmac-sha1', 'hmac-md5', 'hmac-sha1-96', 'hmac-md5-96')\n",
      "    _preferred_keys = ('ssh-rsa', 'ssh-dss', 'ecdsa-sha2-nistp256')\n",
      "    _preferred_kex =  ( 'diffie-hellman-group14-sha1', 'diffie-hellman-group-exchange-sha1' , 'diffie-hellman-group1-sha1')\n",
      "    _preferred_compression = ('none',)\n",
      "\n",
      "    _cipher_info = {\n",
      "        'aes128-ctr': {'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 16},\n",
      "        'aes256-ctr': {'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 32},\n",
      "        'blowfish-cbc': {'class': Blowfish, 'mode': Blowfish.MODE_CBC, 'block-size': 8, 'key-size': 16},\n",
      "        'aes128-cbc': {'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 16},\n",
      "        'aes256-cbc': {'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 32},\n",
      "        '3des-cbc': {'class': DES3, 'mode': DES3.MODE_CBC, 'block-size': 8, 'key-size': 24},\n",
      "        'arcfour128': {'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 16},\n",
      "        'arcfour256': {'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 32},\n",
      "    }\n",
      "\n",
      "    _mac_info = {\n",
      "        'hmac-sha1': {'class': sha1, 'size': 20},\n",
      "        'hmac-sha1-96': {'class': sha1, 'size': 12},\n",
      "        'hmac-md5': {'class': md5, 'size': 16},\n",
      "        'hmac-md5-96': {'class': md5, 'size': 12},\n",
      "    }\n",
      "\n",
      "    _key_info = {\n",
      "        'ssh-rsa': RSAKey,\n",
      "        'ssh-dss': DSSKey,\n",
      "        'ecdsa-sha2-nistp256': ECDSAKey,\n",
      "    }\n",
      "\n",
      "    _kex_info = {\n",
      "        'diffie-hellman-group1-sha1': KexGroup1,\n",
      "        'diffie-hellman-group14-sha1': KexGroup14,\n",
      "        'diffie-hellman-group-exchange-sha1': KexGex,\n",
      "        'gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup1,\n",
      "        'gss-group14-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup14,\n",
      "        'gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGex\n",
      "    }\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/frankyrumple/smc/modules/paramiko/transport.py",
    "code": [
      "def _join_lingering_threads():\n",
      "    for thr in _active_threads:\n",
      "        thr.stop_thread()\n",
      "\n",
      "import atexit\n",
      "atexit.register(_join_lingering_threads)\n",
      "\n",
      "\n",
      "class Transport (threading.Thread, ClosingContextManager):\n",
      "    \"\"\"\n",
      "    An SSH Transport attaches to a stream (usually a socket), negotiates an\n",
      "    encrypted session, authenticates, and then creates stream tunnels, called\n",
      "    `channels <.Channel>`, across the session.  Multiple channels can be\n",
      "    multiplexed across a single session (and often are, in the case of port\n",
      "    forwardings).\n",
      "\n",
      "    Instances of this class may be used as context managers.\n",
      "    \"\"\"\n",
      "    _PROTO_ID = '2.0'\n",
      "    _CLIENT_ID = 'paramiko_%s' % paramiko.__version__\n",
      "\n",
      "    _preferred_ciphers = ('aes128-ctr', 'aes256-ctr', 'aes128-cbc', 'blowfish-cbc',\n",
      "                          'aes256-cbc', '3des-cbc', 'arcfour128', 'arcfour256')\n",
      "    _preferred_macs = ('hmac-sha1', 'hmac-md5', 'hmac-sha1-96', 'hmac-md5-96')\n",
      "    _preferred_keys = ('ssh-rsa', 'ssh-dss', 'ecdsa-sha2-nistp256')\n",
      "    _preferred_kex =  ( 'diffie-hellman-group14-sha1', 'diffie-hellman-group-exchange-sha1' , 'diffie-hellman-group1-sha1')\n",
      "    _preferred_compression = ('none',)\n",
      "\n",
      "    _cipher_info = {\n",
      "        'aes128-ctr': {'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 16},\n",
      "        'aes256-ctr': {'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 32},\n",
      "        'blowfish-cbc': {'class': Blowfish, 'mode': Blowfish.MODE_CBC, 'block-size': 8, 'key-size': 16},\n",
      "        'aes128-cbc': {'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 16},\n",
      "        'aes256-cbc': {'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 32},\n",
      "        '3des-cbc': {'class': DES3, 'mode': DES3.MODE_CBC, 'block-size': 8, 'key-size': 24},\n",
      "        'arcfour128': {'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 16},\n",
      "        'arcfour256': {'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 32},\n",
      "    }\n",
      "\n",
      "    _mac_info = {\n",
      "        'hmac-sha1': {'class': sha1, 'size': 20},\n",
      "        'hmac-sha1-96': {'class': sha1, 'size': 12},\n",
      "        'hmac-md5': {'class': md5, 'size': 16},\n",
      "        'hmac-md5-96': {'class': md5, 'size': 12},\n",
      "    }\n",
      "\n",
      "    _key_info = {\n",
      "        'ssh-rsa': RSAKey,\n",
      "        'ssh-dss': DSSKey,\n",
      "        'ecdsa-sha2-nistp256': ECDSAKey,\n",
      "    }\n",
      "\n",
      "    _kex_info = {\n",
      "        'diffie-hellman-group1-sha1': KexGroup1,\n",
      "        'diffie-hellman-group14-sha1': KexGroup14,\n",
      "        'diffie-hellman-group-exchange-sha1': KexGex,\n",
      "        'gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup1,\n",
      "        'gss-group14-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup14,\n",
      "        'gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGex\n",
      "    }\n",
      "\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/frankyrumple/smc/modules/paramiko/transport.py",
    "code": [
      "        thr.stop_thread()\n",
      "\n",
      "import atexit\n",
      "atexit.register(_join_lingering_threads)\n",
      "\n",
      "\n",
      "class Transport (threading.Thread, ClosingContextManager):\n",
      "    \"\"\"\n",
      "    An SSH Transport attaches to a stream (usually a socket), negotiates an\n",
      "    encrypted session, authenticates, and then creates stream tunnels, called\n",
      "    `channels <.Channel>`, across the session.  Multiple channels can be\n",
      "    multiplexed across a single session (and often are, in the case of port\n",
      "    forwardings).\n",
      "\n",
      "    Instances of this class may be used as context managers.\n",
      "    \"\"\"\n",
      "    _PROTO_ID = '2.0'\n",
      "    _CLIENT_ID = 'paramiko_%s' % paramiko.__version__\n",
      "\n",
      "    _preferred_ciphers = ('aes128-ctr', 'aes256-ctr', 'aes128-cbc', 'blowfish-cbc',\n",
      "                          'aes256-cbc', '3des-cbc', 'arcfour128', 'arcfour256')\n",
      "    _preferred_macs = ('hmac-sha1', 'hmac-md5', 'hmac-sha1-96', 'hmac-md5-96')\n",
      "    _preferred_keys = ('ssh-rsa', 'ssh-dss', 'ecdsa-sha2-nistp256')\n",
      "    _preferred_kex =  ( 'diffie-hellman-group14-sha1', 'diffie-hellman-group-exchange-sha1' , 'diffie-hellman-group1-sha1')\n",
      "    _preferred_compression = ('none',)\n",
      "\n",
      "    _cipher_info = {\n",
      "        'aes128-ctr': {'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 16},\n",
      "        'aes256-ctr': {'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 32},\n",
      "        'blowfish-cbc': {'class': Blowfish, 'mode': Blowfish.MODE_CBC, 'block-size': 8, 'key-size': 16},\n",
      "        'aes128-cbc': {'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 16},\n",
      "        'aes256-cbc': {'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 32},\n",
      "        '3des-cbc': {'class': DES3, 'mode': DES3.MODE_CBC, 'block-size': 8, 'key-size': 24},\n",
      "        'arcfour128': {'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 16},\n",
      "        'arcfour256': {'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 32},\n",
      "    }\n",
      "\n",
      "    _mac_info = {\n",
      "        'hmac-sha1': {'class': sha1, 'size': 20},\n",
      "        'hmac-sha1-96': {'class': sha1, 'size': 12},\n",
      "        'hmac-md5': {'class': md5, 'size': 16},\n",
      "        'hmac-md5-96': {'class': md5, 'size': 12},\n",
      "    }\n",
      "\n",
      "    _key_info = {\n",
      "        'ssh-rsa': RSAKey,\n",
      "        'ssh-dss': DSSKey,\n",
      "        'ecdsa-sha2-nistp256': ECDSAKey,\n",
      "    }\n",
      "\n",
      "    _kex_info = {\n",
      "        'diffie-hellman-group1-sha1': KexGroup1,\n",
      "        'diffie-hellman-group14-sha1': KexGroup14,\n",
      "        'diffie-hellman-group-exchange-sha1': KexGex,\n",
      "        'gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup1,\n",
      "        'gss-group14-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup14,\n",
      "        'gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGex\n",
      "    }\n",
      "\n",
      "    _compression_info = {\n",
      "        # zlib@openssh.com is just zlib, but only turned on after a successful\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/frankyrumple/smc/modules/paramiko/transport.py",
    "code": [
      "\n",
      "import atexit\n",
      "atexit.register(_join_lingering_threads)\n",
      "\n",
      "\n",
      "class Transport (threading.Thread, ClosingContextManager):\n",
      "    \"\"\"\n",
      "    An SSH Transport attaches to a stream (usually a socket), negotiates an\n",
      "    encrypted session, authenticates, and then creates stream tunnels, called\n",
      "    `channels <.Channel>`, across the session.  Multiple channels can be\n",
      "    multiplexed across a single session (and often are, in the case of port\n",
      "    forwardings).\n",
      "\n",
      "    Instances of this class may be used as context managers.\n",
      "    \"\"\"\n",
      "    _PROTO_ID = '2.0'\n",
      "    _CLIENT_ID = 'paramiko_%s' % paramiko.__version__\n",
      "\n",
      "    _preferred_ciphers = ('aes128-ctr', 'aes256-ctr', 'aes128-cbc', 'blowfish-cbc',\n",
      "                          'aes256-cbc', '3des-cbc', 'arcfour128', 'arcfour256')\n",
      "    _preferred_macs = ('hmac-sha1', 'hmac-md5', 'hmac-sha1-96', 'hmac-md5-96')\n",
      "    _preferred_keys = ('ssh-rsa', 'ssh-dss', 'ecdsa-sha2-nistp256')\n",
      "    _preferred_kex =  ( 'diffie-hellman-group14-sha1', 'diffie-hellman-group-exchange-sha1' , 'diffie-hellman-group1-sha1')\n",
      "    _preferred_compression = ('none',)\n",
      "\n",
      "    _cipher_info = {\n",
      "        'aes128-ctr': {'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 16},\n",
      "        'aes256-ctr': {'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 32},\n",
      "        'blowfish-cbc': {'class': Blowfish, 'mode': Blowfish.MODE_CBC, 'block-size': 8, 'key-size': 16},\n",
      "        'aes128-cbc': {'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 16},\n",
      "        'aes256-cbc': {'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 32},\n",
      "        '3des-cbc': {'class': DES3, 'mode': DES3.MODE_CBC, 'block-size': 8, 'key-size': 24},\n",
      "        'arcfour128': {'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 16},\n",
      "        'arcfour256': {'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 32},\n",
      "    }\n",
      "\n",
      "    _mac_info = {\n",
      "        'hmac-sha1': {'class': sha1, 'size': 20},\n",
      "        'hmac-sha1-96': {'class': sha1, 'size': 12},\n",
      "        'hmac-md5': {'class': md5, 'size': 16},\n",
      "        'hmac-md5-96': {'class': md5, 'size': 12},\n",
      "    }\n",
      "\n",
      "    _key_info = {\n",
      "        'ssh-rsa': RSAKey,\n",
      "        'ssh-dss': DSSKey,\n",
      "        'ecdsa-sha2-nistp256': ECDSAKey,\n",
      "    }\n",
      "\n",
      "    _kex_info = {\n",
      "        'diffie-hellman-group1-sha1': KexGroup1,\n",
      "        'diffie-hellman-group14-sha1': KexGroup14,\n",
      "        'diffie-hellman-group-exchange-sha1': KexGex,\n",
      "        'gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup1,\n",
      "        'gss-group14-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup14,\n",
      "        'gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGex\n",
      "    }\n",
      "\n",
      "    _compression_info = {\n",
      "        # zlib@openssh.com is just zlib, but only turned on after a successful\n",
      "        # authentication.  openssh servers may only offer this type because\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/frankyrumple/ope/libs/paramiko/pkey.py",
    "code": [
      "# details.\n",
      "#\n",
      "# You should have received a copy of the GNU Lesser General Public License\n",
      "# along with Paramiko; if not, write to the Free Software Foundation, Inc.,\n",
      "# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n",
      "\n",
      "\"\"\"\n",
      "Common API for all public keys.\n",
      "\"\"\"\n",
      "\n",
      "import base64\n",
      "from binascii import hexlify, unhexlify\n",
      "import os\n",
      "from hashlib import md5\n",
      "\n",
      "from Crypto.Cipher import DES3, AES\n",
      "\n",
      "from paramiko import util\n",
      "from paramiko.common import o600, zero_byte\n",
      "from paramiko.py3compat import u, encodebytes, decodebytes, b\n",
      "from paramiko.ssh_exception import SSHException, PasswordRequiredException\n",
      "\n",
      "\n",
      "class PKey (object):\n",
      "    \"\"\"\n",
      "    Base class for public keys.\n",
      "    \"\"\"\n",
      "\n",
      "    # known encryption types for private key files:\n",
      "    _CIPHER_TABLE = {\n",
      "        'AES-128-CBC': {'cipher': AES, 'keysize': 16, 'blocksize': 16, 'mode': AES.MODE_CBC},\n",
      "        'DES-EDE3-CBC': {'cipher': DES3, 'keysize': 24, 'blocksize': 8, 'mode': DES3.MODE_CBC},\n",
      "    }\n",
      "\n",
      "    def __init__(self, msg=None, data=None):\n",
      "        \"\"\"\n",
      "        Create a new instance of this public key type.  If ``msg`` is given,\n",
      "        the key's public part(s) will be filled in from the message.  If\n",
      "        ``data`` is given, the key's public part(s) will be filled in from\n",
      "        the string.\n",
      "\n",
      "        :param .Message msg:\n",
      "            an optional SSH `.Message` containing a public key of this type.\n",
      "        :param str data: an optional string containing a public key of this type\n",
      "\n",
      "        :raises SSHException:\n",
      "            if a key cannot be created from the ``data`` or ``msg`` given, or\n",
      "            no key was passed in.\n",
      "        \"\"\"\n",
      "        pass\n",
      "\n",
      "    def asbytes(self):\n",
      "        \"\"\"\n",
      "        Return a string of an SSH `.Message` made up of the public part(s) of\n",
      "        this key.  This string is suitable for passing to `__init__` to\n",
      "        re-create the key object later.\n",
      "        \"\"\"\n",
      "        return bytes()\n",
      "\n",
      "    def __str__(self):\n",
      "        return self.asbytes()\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/frankyrumple/ope/admin_app/paramiko/pkey.py",
    "code": [
      "# details.\n",
      "#\n",
      "# You should have received a copy of the GNU Lesser General Public License\n",
      "# along with Paramiko; if not, write to the Free Software Foundation, Inc.,\n",
      "# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n",
      "\n",
      "\"\"\"\n",
      "Common API for all public keys.\n",
      "\"\"\"\n",
      "\n",
      "import base64\n",
      "from binascii import hexlify, unhexlify\n",
      "import os\n",
      "from hashlib import md5\n",
      "\n",
      "from Crypto.Cipher import DES3, AES\n",
      "\n",
      "from paramiko import util\n",
      "from paramiko.common import o600, zero_byte\n",
      "from paramiko.py3compat import u, encodebytes, decodebytes, b\n",
      "from paramiko.ssh_exception import SSHException, PasswordRequiredException\n",
      "\n",
      "\n",
      "class PKey (object):\n",
      "    \"\"\"\n",
      "    Base class for public keys.\n",
      "    \"\"\"\n",
      "\n",
      "    # known encryption types for private key files:\n",
      "    _CIPHER_TABLE = {\n",
      "        'AES-128-CBC': {'cipher': AES, 'keysize': 16, 'blocksize': 16, 'mode': AES.MODE_CBC},\n",
      "        'DES-EDE3-CBC': {'cipher': DES3, 'keysize': 24, 'blocksize': 8, 'mode': DES3.MODE_CBC},\n",
      "    }\n",
      "\n",
      "    def __init__(self, msg=None, data=None):\n",
      "        \"\"\"\n",
      "        Create a new instance of this public key type.  If ``msg`` is given,\n",
      "        the key's public part(s) will be filled in from the message.  If\n",
      "        ``data`` is given, the key's public part(s) will be filled in from\n",
      "        the string.\n",
      "\n",
      "        :param .Message msg:\n",
      "            an optional SSH `.Message` containing a public key of this type.\n",
      "        :param str data: an optional string containing a public key of this type\n",
      "\n",
      "        :raises SSHException:\n",
      "            if a key cannot be created from the ``data`` or ``msg`` given, or\n",
      "            no key was passed in.\n",
      "        \"\"\"\n",
      "        pass\n",
      "\n",
      "    def asbytes(self):\n",
      "        \"\"\"\n",
      "        Return a string of an SSH `.Message` made up of the public part(s) of\n",
      "        this key.  This string is suitable for passing to `__init__` to\n",
      "        re-create the key object later.\n",
      "        \"\"\"\n",
      "        return bytes()\n",
      "\n",
      "    def __str__(self):\n",
      "        return self.asbytes()\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/frankyrumple/ope/admin_app/gluon/utils.py",
    "code": [
      "        return hashlib.pbkdf2_hmac(hashfunc().name,\n",
      "                           data, salt, iterations,\n",
      "                           keylen).encode(\"hex\")\n",
      "    HAVE_PBKDF2 = True\n",
      "else:\n",
      "    try:\n",
      "        try:\n",
      "            from gluon.contrib.pbkdf2_ctypes import pbkdf2_hex\n",
      "        except (ImportError, AttributeError):\n",
      "            from gluon.contrib.pbkdf2 import pbkdf2_hex\n",
      "        HAVE_PBKDF2 = True\n",
      "    except ImportError:\n",
      "        try:\n",
      "            from .pbkdf2 import pbkdf2_hex\n",
      "            HAVE_PBKDF2 = True\n",
      "        except (ImportError, ValueError):\n",
      "            HAVE_PBKDF2 = False\n",
      "\n",
      "HAVE_COMPARE_DIGEST = False\n",
      "if hasattr(hmac, 'compare_digest'):\n",
      "    HAVE_COMPARE_DIGEST = True\n",
      "\n",
      "logger = logging.getLogger(\"web2py\")\n",
      "\n",
      "\n",
      "def AES_new(key, IV=None):\n",
      "    \"\"\" Returns an AES cipher object and random IV if None specified \"\"\"\n",
      "    if IV is None:\n",
      "        IV = fast_urandom16()\n",
      "\n",
      "    return AES.new(key, AES.MODE_CBC, IV), IV\n",
      "\n",
      "\n",
      "def compare(a, b):\n",
      "    \"\"\" Compares two strings and not vulnerable to timing attacks \"\"\"\n",
      "    if HAVE_COMPARE_DIGEST:\n",
      "        return hmac.compare_digest(a, b)\n",
      "    result = len(a) ^ len(b)\n",
      "    for i in xrange(len(b)):\n",
      "\t\tresult |= ord(a[i%len(a)]) ^ ord(b[i])\n",
      "    return result == 0\n",
      "\n",
      "\n",
      "def md5_hash(text):\n",
      "    \"\"\" Generates a md5 hash with the given text \"\"\"\n",
      "    return md5(text).hexdigest()\n",
      "\n",
      "\n",
      "def simple_hash(text, key='', salt='', digest_alg='md5'):\n",
      "    \"\"\"\n",
      "    Generates hash with the given text using the specified\n",
      "    digest hashing algorithm\n",
      "    \"\"\"\n",
      "    if not digest_alg:\n",
      "        raise RuntimeError(\"simple_hash with digest_alg=None\")\n",
      "    elif not isinstance(digest_alg, str):  # manual approach\n",
      "        h = digest_alg(text + key + salt)\n",
      "    elif digest_alg.startswith('pbkdf2'):  # latest and coolest!\n",
      "        iterations, keylen, alg = digest_alg[7:-1].split(',')\n",
      "        return pbkdf2_hex(text, salt, int(iterations),\n",
      "                          int(keylen), get_digest(alg))\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/frankyrumple/ope/laptop_credential/win_util.py",
    "code": [
      "        return urandom.pop()\n",
      "    except IndexError:\n",
      "        try:\n",
      "            locker.acquire()\n",
      "            ur = os.urandom(16 * 1024)\n",
      "            urandom += [ur[i:i + 16] for i in xrange(16, 1024 * 16, 16)]\n",
      "            return ur[0:16]\n",
      "        finally:\n",
      "            locker.release()\n",
      "\n",
      "\n",
      "def pad(s, n=32, padchar=' '):\n",
      "    if len(s) == 0:\n",
      "        # Handle empty value - pad it out w empty data\n",
      "        s += padchar * n\n",
      "        return s\n",
      "    while ((len(s) % n) != 0):\n",
      "        s += padchar\n",
      "    #pad_len = len(s) % 32 # How many characters do we need to pad out to a multiple of 32\n",
      "    #if (pad_len != 0):\n",
      "    #    #return s + (32 - len(s) % 32) * padchar\n",
      "    #    return s + (\n",
      "    return s\n",
      "\n",
      "\n",
      "def AES_new(key, iv=None):\n",
      "    \"\"\" Returns an AES cipher object and random IV if None specified \"\"\"\n",
      "    if iv is None:\n",
      "        iv = fast_urandom16()\n",
      "\n",
      "    # return AES.new(key, AES.MODE_CBC, IV), IV\n",
      "    # Util.aes = pyaes.AESModeOfOperationCBC(key, iv = iv)\n",
      "    # plaintext = \"TextMustBe16Byte\"\n",
      "    # ciphertext = aes.encrypt(plaintext)\n",
      "    return AES.AESModeOfOperationCBC(key, iv = iv), iv\n",
      "\n",
      "\n",
      "def encrypt(data, key):\n",
      "    key = pad(key[:32])\n",
      "    cipher, iv = AES_new(key)\n",
      "    encrypted_data = iv + cipher.encrypt(pad(data, 16))\n",
      "    return base64.urlsafe_b64encode(encrypted_data)\n",
      "\n",
      "\n",
      "def decrypt(data, key):\n",
      "    key = pad(key[:32])\n",
      "    if data is None:\n",
      "        data = \"\"\n",
      "    try:\n",
      "        data = base64.urlsafe_b64decode(data)\n",
      "    except TypeError as ex:\n",
      "        # Don't let error blow things up\n",
      "        pass\n",
      "    iv, data = data[:16], data[16:]\n",
      "    try:\n",
      "        cipher, _ = AES_new(key, iv=iv)\n",
      "    except:\n",
      "        # bad IV = bad data\n",
      "        return data\n",
      "    try:\n",
      "        data = cipher.decrypt(data)\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/frankyrumple/ope/laptop_credential/gluon/utils.py",
    "code": [
      "        return hashlib.pbkdf2_hmac(hashfunc().name,\n",
      "                           data, salt, iterations,\n",
      "                           keylen).encode(\"hex\")\n",
      "    HAVE_PBKDF2 = True\n",
      "else:\n",
      "    try:\n",
      "        try:\n",
      "            from gluon.contrib.pbkdf2_ctypes import pbkdf2_hex\n",
      "        except (ImportError, AttributeError):\n",
      "            from gluon.contrib.pbkdf2 import pbkdf2_hex\n",
      "        HAVE_PBKDF2 = True\n",
      "    except ImportError:\n",
      "        try:\n",
      "            from .pbkdf2 import pbkdf2_hex\n",
      "            HAVE_PBKDF2 = True\n",
      "        except (ImportError, ValueError):\n",
      "            HAVE_PBKDF2 = False\n",
      "\n",
      "HAVE_COMPARE_DIGEST = False\n",
      "if hasattr(hmac, 'compare_digest'):\n",
      "    HAVE_COMPARE_DIGEST = True\n",
      "\n",
      "logger = logging.getLogger(\"web2py\")\n",
      "\n",
      "\n",
      "def AES_new(key, IV=None):\n",
      "    \"\"\" Returns an AES cipher object and random IV if None specified \"\"\"\n",
      "    if IV is None:\n",
      "        IV = fast_urandom16()\n",
      "\n",
      "    return AES.new(key, AES.MODE_CBC, IV), IV\n",
      "\n",
      "\n",
      "def compare(a, b):\n",
      "    \"\"\" Compares two strings and not vulnerable to timing attacks \"\"\"\n",
      "    if HAVE_COMPARE_DIGEST:\n",
      "        return hmac.compare_digest(a, b)\n",
      "    result = len(a) ^ len(b)\n",
      "    for i in xrange(len(b)):\n",
      "\t\tresult |= ord(a[i%len(a)]) ^ ord(b[i])\n",
      "    return result == 0\n",
      "\n",
      "\n",
      "def md5_hash(text):\n",
      "    \"\"\" Generates a md5 hash with the given text \"\"\"\n",
      "    return md5(text).hexdigest()\n",
      "\n",
      "\n",
      "def simple_hash(text, key='', salt='', digest_alg='md5'):\n",
      "    \"\"\"\n",
      "    Generates hash with the given text using the specified\n",
      "    digest hashing algorithm\n",
      "    \"\"\"\n",
      "    if not digest_alg:\n",
      "        raise RuntimeError(\"simple_hash with digest_alg=None\")\n",
      "    elif not isinstance(digest_alg, str):  # manual approach\n",
      "        h = digest_alg(text + key + salt)\n",
      "    elif digest_alg.startswith('pbkdf2'):  # latest and coolest!\n",
      "        iterations, keylen, alg = digest_alg[7:-1].split(',')\n",
      "        return pbkdf2_hex(text, salt, int(iterations),\n",
      "                          int(keylen), get_digest(alg))\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/todaychi/hue/desktop/core/ext-py/pycrypto-2.6.1/lib/Crypto/Util/Counter.py",
    "code": [
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"Fast counter functions for CTR cipher modes.\n",
      "\n",
      "CTR is a chaining mode for symmetric block encryption or decryption.\n",
      "Messages are divideded into blocks, and the cipher operation takes\n",
      "place on each block using the secret key and a unique *counter block*.\n",
      "\n",
      "The most straightforward way to fulfil the uniqueness property is\n",
      "to start with an initial, random *counter block* value, and increment it as\n",
      "the next block is processed.\n",
      "\n",
      "The block ciphers from `Crypto.Cipher` (when configured in *MODE_CTR* mode)\n",
      "invoke a callable object (the *counter* parameter) to get the next *counter block*.\n",
      "Unfortunately, the Python calling protocol leads to major performance degradations.\n",
      "\n",
      "The counter functions instantiated by this module will be invoked directly\n",
      "by the ciphers in `Crypto.Cipher`. The fact that the Python layer is bypassed\n",
      "lead to more efficient (and faster) execution of CTR cipher modes.\n",
      "\n",
      "An example of usage is the following:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto.Util import Counter\n",
      "    >>>\n",
      "    >>> pt = b'\\x00'*1000000\n",
      "    >>> ctr = Counter.new(128)\n",
      "    >>> cipher = AES.new(b'\\x00'*16, AES.MODE_CTR, counter=ctr)\n",
      "    >>> ct = cipher.encrypt(pt)\n",
      "\n",
      ":undocumented: __package__\n",
      "\"\"\"\n",
      "import sys\n",
      "if sys.version_info[0] == 2 and sys.version_info[1] == 1:\n",
      "    from Crypto.Util.py21compat import *\n",
      "from Crypto.Util.py3compat import *\n",
      "\n",
      "from Crypto.Util import _counter\n",
      "import struct\n",
      "\n",
      "# Factory function\n",
      "def new(nbits, prefix=b(\"\"), suffix=b(\"\"), initial_value=1, overflow=0, little_endian=False, allow_wraparound=False, disable_shortcut=False):\n",
      "    \"\"\"Create a stateful counter block function suitable for CTR encryption modes.\n",
      "\n",
      "    Each call to the function returns the next counter block.\n",
      "    Each counter block is made up by three parts::\n",
      " \n",
      "      prefix || counter value || postfix\n",
      "\n",
      "    The counter value is incremented by one at each call.\n",
      "\n",
      "    :Parameters:\n",
      "      nbits : integer\n",
      "        Length of the desired counter, in bits. It must be a multiple of 8.\n",
      "      prefix : byte string\n",
      "        The constant prefix of the counter block. By default, no prefix is\n",
      "        used.\n",
      "      suffix : byte string\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/nccgroup/featherduster/tests/test_padding_oracle_decrypt.py",
    "code": [
      "from Crypto.Cipher import AES\n",
      "from Crypto import Random\n",
      "import cryptanalib as ca\n",
      "from time import sleep\n",
      "\n",
      "plaintext = 'I am the very model of a modern major-general'\n",
      "plaintext = ca.pkcs7_pad(plaintext, AES.block_size)\n",
      "print \"Plaintext is \" + plaintext\n",
      "\n",
      "key = b'YELLOW SUBMARINE' #<3 matasano crypto challenges\n",
      "iv = Random.new().read(AES.block_size)\n",
      "\n",
      "def my_padding_oracle(ciphertext):\n",
      "   dat_cipher = AES.new(key,AES.MODE_CBC,iv)\n",
      "   if ca.pkcs7_padding_remove(dat_cipher.decrypt(ciphertext),AES.block_size) == False:\n",
      "      return False\n",
      "   else:\n",
      "      return True\n",
      "\n",
      "cipher = AES.new(key,AES.MODE_CBC,iv)\n",
      "ciphertext = cipher.encrypt(plaintext)\n",
      "\n",
      "print 'Running the attack with known IV:'\n",
      "result = ca.padding_oracle_decrypt(my_padding_oracle, ciphertext, block_size=AES.block_size, verbose=True, iv=iv)\n",
      "print result\n",
      "if result != plaintext:\n",
      "   raise Exception('Vaudenay\\'s padding oracle attack with IV knowledge is broken.')\n",
      "print ''\n",
      "print 'Running the attack without knowledge of the IV:'\n",
      "result = ca.padding_oracle_decrypt(my_padding_oracle, ciphertext, block_size=AES.block_size, verbose=True)\n",
      "print result\n",
      "if result[AES.block_size:] != plaintext[AES.block_size:]:\n",
      "   raise Exception('Vaudenay\\'s padding oracle attack without IV knowledge is broken.')"
    ],
    "target": 12,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/nccgroup/featherduster/tests/test_padding_oracle_decrypt.py",
    "code": [
      "from Crypto.Cipher import AES\n",
      "from Crypto import Random\n",
      "import cryptanalib as ca\n",
      "from time import sleep\n",
      "\n",
      "plaintext = 'I am the very model of a modern major-general'\n",
      "plaintext = ca.pkcs7_pad(plaintext, AES.block_size)\n",
      "print \"Plaintext is \" + plaintext\n",
      "\n",
      "key = b'YELLOW SUBMARINE' #<3 matasano crypto challenges\n",
      "iv = Random.new().read(AES.block_size)\n",
      "\n",
      "def my_padding_oracle(ciphertext):\n",
      "   dat_cipher = AES.new(key,AES.MODE_CBC,iv)\n",
      "   if ca.pkcs7_padding_remove(dat_cipher.decrypt(ciphertext),AES.block_size) == False:\n",
      "      return False\n",
      "   else:\n",
      "      return True\n",
      "\n",
      "cipher = AES.new(key,AES.MODE_CBC,iv)\n",
      "ciphertext = cipher.encrypt(plaintext)\n",
      "\n",
      "print 'Running the attack with known IV:'\n",
      "result = ca.padding_oracle_decrypt(my_padding_oracle, ciphertext, block_size=AES.block_size, verbose=True, iv=iv)\n",
      "print result\n",
      "if result != plaintext:\n",
      "   raise Exception('Vaudenay\\'s padding oracle attack with IV knowledge is broken.')\n",
      "print ''\n",
      "print 'Running the attack without knowledge of the IV:'\n",
      "result = ca.padding_oracle_decrypt(my_padding_oracle, ciphertext, block_size=AES.block_size, verbose=True)\n",
      "print result\n",
      "if result[AES.block_size:] != plaintext[AES.block_size:]:\n",
      "   raise Exception('Vaudenay\\'s padding oracle attack without IV knowledge is broken.')"
    ],
    "target": 18,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/nccgroup/featherduster/feathermodules/block/aes_key_brute.py",
    "code": [
      "         keys = open(options['keyfile'],'r').readlines()\n",
      "      except:\n",
      "         print '[*] Key file is not a set of hex encoded 16 byte values. Using default key list.'\n",
      "   else:\n",
      "      keys = default_keylist\n",
      "   \n",
      "   # filter samples into one-block samples and multi-block samples\n",
      "   one_block_samples = filter(lambda x: len(x)==16, samples)\n",
      "   multi_block_samples = filter(lambda x: len(x) > 16, samples)\n",
      "   \n",
      "   if len(multi_block_samples) == 1:\n",
      "      print '[*] One a single multi-block sample exists. This has a 1 in 256 chance of false positives with the CBC test.'\n",
      "   if len(one_block_samples) == 1:\n",
      "      print '[*] One a single one-block sample exists. This has a 1 in 256 chance of false positives with the ECB, CBC key-as-IV, and CBC known IV tests.'\n",
      "   \n",
      "   for key in keys:\n",
      "      try:\n",
      "         key = key.decode('hex')\n",
      "      except:\n",
      "         print '[*] Bad key provided, bailing out.'\n",
      "         return False\n",
      "\n",
      "      # set all bad_decryption flags to False\n",
      "      ecb_bad_decrypt = cbc_key_as_iv_bad_decrypt = cbc_bad_decrypt = cbc_known_iv_bad_decrypt = False\n",
      "\n",
      "      # ECB\n",
      "      for sample in samples:\n",
      "         cipher = AES.new(key, AES.MODE_ECB)\n",
      "         # If any decryption fails to produce valid padding, flag bad ECB decryption and break\n",
      "         if decrypt_and_check(cipher, sample[-16:]) == False:\n",
      "            ecb_bad_decrypt = True\n",
      "            break\n",
      "\n",
      "      # CBC last block with second to last block as IV\n",
      "      if len(multi_block_samples) != 0:\n",
      "         for sample in multi_block_samples:\n",
      "            cipher = AES.new(key, AES.MODE_CBC, sample[-32:-16])\n",
      "            # If any decryption fails to produce valid padding, flag bad CBC decryption and break\n",
      "            if decrypt_and_check(cipher, sample[-16:]) == False:\n",
      "               cbc_bad_decrypt = True\n",
      "               break\n",
      "      else:\n",
      "         cbc_bad_decrypt = True\n",
      "      \n",
      "      if len(one_block_samples) != 0:\n",
      "         if options['known_iv'] != '':\n",
      "            cbc_key_as_iv_bad_decrypt = True\n",
      "            # CBC with entered IV\n",
      "            for sample in one_block_samples:\n",
      "               cipher = AES.new(key, AES.MODE_CBC, options['known_iv'].decode('hex'))\n",
      "               # If any decryption fails to produce valid padding, flag bad CBC decryption and break\n",
      "               if decrypt_and_check(cipher, sample) == False:\n",
      "                  cbc_known_iv_bad_decrypt = True\n",
      "                  break\n",
      "         else:\n",
      "            cbc_known_iv_bad_decrypt = True\n",
      "            # CBC with key as IV\n",
      "            for sample in one_block_samples:\n",
      "               cipher = AES.new(key, AES.MODE_CBC, key)\n"
    ],
    "target": 26,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/nccgroup/featherduster/feathermodules/block/aes_key_brute.py",
    "code": [
      "   \n",
      "   if len(multi_block_samples) == 1:\n",
      "      print '[*] One a single multi-block sample exists. This has a 1 in 256 chance of false positives with the CBC test.'\n",
      "   if len(one_block_samples) == 1:\n",
      "      print '[*] One a single one-block sample exists. This has a 1 in 256 chance of false positives with the ECB, CBC key-as-IV, and CBC known IV tests.'\n",
      "   \n",
      "   for key in keys:\n",
      "      try:\n",
      "         key = key.decode('hex')\n",
      "      except:\n",
      "         print '[*] Bad key provided, bailing out.'\n",
      "         return False\n",
      "\n",
      "      # set all bad_decryption flags to False\n",
      "      ecb_bad_decrypt = cbc_key_as_iv_bad_decrypt = cbc_bad_decrypt = cbc_known_iv_bad_decrypt = False\n",
      "\n",
      "      # ECB\n",
      "      for sample in samples:\n",
      "         cipher = AES.new(key, AES.MODE_ECB)\n",
      "         # If any decryption fails to produce valid padding, flag bad ECB decryption and break\n",
      "         if decrypt_and_check(cipher, sample[-16:]) == False:\n",
      "            ecb_bad_decrypt = True\n",
      "            break\n",
      "\n",
      "      # CBC last block with second to last block as IV\n",
      "      if len(multi_block_samples) != 0:\n",
      "         for sample in multi_block_samples:\n",
      "            cipher = AES.new(key, AES.MODE_CBC, sample[-32:-16])\n",
      "            # If any decryption fails to produce valid padding, flag bad CBC decryption and break\n",
      "            if decrypt_and_check(cipher, sample[-16:]) == False:\n",
      "               cbc_bad_decrypt = True\n",
      "               break\n",
      "      else:\n",
      "         cbc_bad_decrypt = True\n",
      "      \n",
      "      if len(one_block_samples) != 0:\n",
      "         if options['known_iv'] != '':\n",
      "            cbc_key_as_iv_bad_decrypt = True\n",
      "            # CBC with entered IV\n",
      "            for sample in one_block_samples:\n",
      "               cipher = AES.new(key, AES.MODE_CBC, options['known_iv'].decode('hex'))\n",
      "               # If any decryption fails to produce valid padding, flag bad CBC decryption and break\n",
      "               if decrypt_and_check(cipher, sample) == False:\n",
      "                  cbc_known_iv_bad_decrypt = True\n",
      "                  break\n",
      "         else:\n",
      "            cbc_known_iv_bad_decrypt = True\n",
      "            # CBC with key as IV\n",
      "            for sample in one_block_samples:\n",
      "               cipher = AES.new(key, AES.MODE_CBC, key)\n",
      "               # If any decryption fails to produce valid padding, flag bad CBC_key_as_IV decryption and break\n",
      "               if decrypt_and_check(cipher, sample) == False:\n",
      "                  cbc_key_as_iv_bad_decrypt = True\n",
      "                  break\n",
      "      else:\n",
      "         cbc_known_iv_bad_decrypt = cbc_key_as_iv_bad_decrypt = True\n",
      "\n",
      "      if not ecb_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key in ECB mode or CBC mode with static all-NUL IV.')\n"
    ],
    "target": 26,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/nccgroup/featherduster/feathermodules/block/aes_key_brute.py",
    "code": [
      "      # set all bad_decryption flags to False\n",
      "      ecb_bad_decrypt = cbc_key_as_iv_bad_decrypt = cbc_bad_decrypt = cbc_known_iv_bad_decrypt = False\n",
      "\n",
      "      # ECB\n",
      "      for sample in samples:\n",
      "         cipher = AES.new(key, AES.MODE_ECB)\n",
      "         # If any decryption fails to produce valid padding, flag bad ECB decryption and break\n",
      "         if decrypt_and_check(cipher, sample[-16:]) == False:\n",
      "            ecb_bad_decrypt = True\n",
      "            break\n",
      "\n",
      "      # CBC last block with second to last block as IV\n",
      "      if len(multi_block_samples) != 0:\n",
      "         for sample in multi_block_samples:\n",
      "            cipher = AES.new(key, AES.MODE_CBC, sample[-32:-16])\n",
      "            # If any decryption fails to produce valid padding, flag bad CBC decryption and break\n",
      "            if decrypt_and_check(cipher, sample[-16:]) == False:\n",
      "               cbc_bad_decrypt = True\n",
      "               break\n",
      "      else:\n",
      "         cbc_bad_decrypt = True\n",
      "      \n",
      "      if len(one_block_samples) != 0:\n",
      "         if options['known_iv'] != '':\n",
      "            cbc_key_as_iv_bad_decrypt = True\n",
      "            # CBC with entered IV\n",
      "            for sample in one_block_samples:\n",
      "               cipher = AES.new(key, AES.MODE_CBC, options['known_iv'].decode('hex'))\n",
      "               # If any decryption fails to produce valid padding, flag bad CBC decryption and break\n",
      "               if decrypt_and_check(cipher, sample) == False:\n",
      "                  cbc_known_iv_bad_decrypt = True\n",
      "                  break\n",
      "         else:\n",
      "            cbc_known_iv_bad_decrypt = True\n",
      "            # CBC with key as IV\n",
      "            for sample in one_block_samples:\n",
      "               cipher = AES.new(key, AES.MODE_CBC, key)\n",
      "               # If any decryption fails to produce valid padding, flag bad CBC_key_as_IV decryption and break\n",
      "               if decrypt_and_check(cipher, sample) == False:\n",
      "                  cbc_key_as_iv_bad_decrypt = True\n",
      "                  break\n",
      "      else:\n",
      "         cbc_known_iv_bad_decrypt = cbc_key_as_iv_bad_decrypt = True\n",
      "\n",
      "      if not ecb_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key in ECB mode or CBC mode with static all-NUL IV.')\n",
      "      if not cbc_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key in CBC mode, IV unknown.')\n",
      "      if not cbc_key_as_iv_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key and static IV in CBC mode.')\n",
      "      if not cbc_known_iv_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key in CBC mode using the provided IV.')\n",
      "         \n",
      "            \n",
      "   print 'Potentially correct AES keys:'\n",
      "   print '-' * 80\n",
      "   print '\\n'.join(results)\n",
      "   return results\n",
      "\n"
    ],
    "target": 26,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/nccgroup/featherduster/feathermodules/block/aes_key_brute.py",
    "code": [
      "            break\n",
      "\n",
      "      # CBC last block with second to last block as IV\n",
      "      if len(multi_block_samples) != 0:\n",
      "         for sample in multi_block_samples:\n",
      "            cipher = AES.new(key, AES.MODE_CBC, sample[-32:-16])\n",
      "            # If any decryption fails to produce valid padding, flag bad CBC decryption and break\n",
      "            if decrypt_and_check(cipher, sample[-16:]) == False:\n",
      "               cbc_bad_decrypt = True\n",
      "               break\n",
      "      else:\n",
      "         cbc_bad_decrypt = True\n",
      "      \n",
      "      if len(one_block_samples) != 0:\n",
      "         if options['known_iv'] != '':\n",
      "            cbc_key_as_iv_bad_decrypt = True\n",
      "            # CBC with entered IV\n",
      "            for sample in one_block_samples:\n",
      "               cipher = AES.new(key, AES.MODE_CBC, options['known_iv'].decode('hex'))\n",
      "               # If any decryption fails to produce valid padding, flag bad CBC decryption and break\n",
      "               if decrypt_and_check(cipher, sample) == False:\n",
      "                  cbc_known_iv_bad_decrypt = True\n",
      "                  break\n",
      "         else:\n",
      "            cbc_known_iv_bad_decrypt = True\n",
      "            # CBC with key as IV\n",
      "            for sample in one_block_samples:\n",
      "               cipher = AES.new(key, AES.MODE_CBC, key)\n",
      "               # If any decryption fails to produce valid padding, flag bad CBC_key_as_IV decryption and break\n",
      "               if decrypt_and_check(cipher, sample) == False:\n",
      "                  cbc_key_as_iv_bad_decrypt = True\n",
      "                  break\n",
      "      else:\n",
      "         cbc_known_iv_bad_decrypt = cbc_key_as_iv_bad_decrypt = True\n",
      "\n",
      "      if not ecb_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key in ECB mode or CBC mode with static all-NUL IV.')\n",
      "      if not cbc_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key in CBC mode, IV unknown.')\n",
      "      if not cbc_key_as_iv_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key and static IV in CBC mode.')\n",
      "      if not cbc_known_iv_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key in CBC mode using the provided IV.')\n",
      "         \n",
      "            \n",
      "   print 'Potentially correct AES keys:'\n",
      "   print '-' * 80\n",
      "   print '\\n'.join(results)\n",
      "   return results\n",
      "\n",
      "\n",
      "feathermodules.module_list['aes_key_brute'] = {\n",
      "   'attack_function': aes_key_brute,\n",
      "   'type':'brute',\n",
      "   'keywords':['block'],\n",
      "   'description':'Try a list of potential AES keys (or user-provided list of hex-encoded keys) against a list of AES ciphertexts.',\n",
      "   'options': {\n",
      "      'known_iv': '',\n",
      "      'keyfile': ''\n"
    ],
    "target": 26,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/nccgroup/redsnarf/redsnarf.py",
    "code": [
      "\n",
      "\t\tprint(colored(\"[+] Using: \"+line,'yellow'))\n",
      "\t\ten = b64encode(line.encode('UTF-16LE'))\n",
      "\t\tprint(colored(\"[+] Encoding command: \"+en,'yellow'))\n",
      "\n",
      "\t\tif system==\"system\":\n",
      "\t\t\tos.system(\"/usr/bin/pth-winexe -U \\\"\"+domain_name+\"\\\\\"+user+\"%\"+passw+\"\\\" --uninstall --system \\/\\/\"+chost+\" \\\"cmd /c echo . | pow^eRSheLL^.eX^e -NonI -NoP -ExecutionPolicy ByPass -E \"+en+\"\\\" 2>/dev/null\")\n",
      "\t\telse:\n",
      "\t\t\tos.system(\"/usr/bin/pth-winexe -U \\\"\"+domain_name+\"\\\\\"+user+\"%\"+passw+\"\\\" --uninstall \\/\\/\"+chost+\" \\\"cmd /c echo . | pow^eRSheLL^.eX^e -NonI -NoP -ExecutionPolicy ByPass -E \"+en+\"\\\" 2>/dev/null\")\n",
      "\n",
      "\t\tif flag==\"AV\":\n",
      "\t\t\t#If Windows Defender AV status was on, turn it back on\n",
      "\t\t\tif AVstatus=='On':\n",
      "\t\t\t\tif response in yesanswers:\n",
      "\t\t\t\t\tprint(colored(\"[+]Turning back on Windows Defender Realtime Monitoring...\",'blue'))\n",
      "\t\t\t\t\tline=\"Set-MpPreference -DisableRealtimeMonitoring $false\\n\"\n",
      "\t\t\t\t\ten = b64encode(line.encode('UTF-16LE'))\n",
      "\t\t\t\t\tos.system(\"/usr/bin/pth-winexe -U \\\"\"+domain_name+\"\\\\\"+user+\"%\"+passw+\"\\\" --uninstall --system \\/\\/\"+chost+\" \\\"cmd /c echo . | pow^eRSheLL^.eX^e -NonI -NoP -ExecutionPolicy ByPass -E \"+en+\"\\\" 2>/dev/null\")\n",
      "\n",
      "\texcept IOError as e:\n",
      "\t\tprint(\"I/O error({0}): {1}\".format(e.errno, e.strerror))\n",
      "\n",
      "\n",
      "#Routine decrypts cpassword values\n",
      "def gppdecrypt(cpassword_pass):\n",
      "\t#Original code taken from the resource below.\n",
      "\t#https://github.com/leonteale/pentestpackage/blob/master/Gpprefdecrypt.py\n",
      "\tkey = binascii.unhexlify(\"4e9906e8fcb66cc9faf49310620ffee8f496e806cc057990209b09a433b66c1b\")\n",
      "\tcpassword = cpassword_pass\n",
      "\tcpassword += \"=\" * ((4 - len(sys.argv[1]) % 4) % 4)\n",
      "\tpassword = b64decode(cpassword)\n",
      "\to = AES.new(key, AES.MODE_CBC, \"\\x00\" * 16).decrypt(password)\n",
      "\tprint(colored('Your cpassword is '+o[:-ord(o[-1])].decode('utf16'),'green'))\n",
      "\n",
      "def bashversion():\n",
      "\n",
      "\tinstalledversion = bashcompleteversioncheck(\"/etc/bash_completion.d/redsnarf.rc\")\n",
      "\tbundleversion = bashcompleteversioncheck(\"redsnarf.rc\")\n",
      "\n",
      "\tif installedversion==\"NoExist\" or installedversion==\"Unknown\":\n",
      "\t\treturn \"Bash Tab Completion Not Configured\"\n",
      "\telif installedversion<bundleversion:\n",
      "\t\treturn \"You need to update your Bash Tab Completion file, Version \"+bundleversion+\" is available.\"\n",
      "\telif installedversion==bundleversion:\n",
      "\t\treturn \"Bash Tab Completion Installed & Up-to-date\"\n",
      "\n",
      "def bashcompleteversioncheck(FilePath):\n",
      "\t#/etc/bash_completion.d/redsnarf.rc\n",
      "\tif not os.path.isfile(FilePath):\n",
      "\t\treturn \"NoExist\"\n",
      "\telif os.path.isfile(FilePath):\n",
      "\t\tbashlines = []\n",
      "\n",
      "\t\twith open(FilePath,'r') as inifile:\n",
      "\t\t\tdata=inifile.read()\n",
      "\t\t\tbashlines=data.splitlines()\n",
      "\n",
      "\t\t#Make sure that the list of bashlines is greater than 0\n",
      "\t\tif len(bashlines)>0:\n",
      "\t\t\tif 'Version' in bashlines[0]:\n",
      "\t\t\t\tversionnum=bashlines[0].split(\",\", 1)[1]\n",
      "\t\telse:\n",
      "\t\t\tversionnum=\"Unknown\"\n"
    ],
    "target": 30,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/lex128/mtasa-blue/vendor/curl/tests/python_dependencies/impacket/smb3.py",
    "code": [
      "        packet['SessionID'] = self._Session['SessionID']\n",
      "\n",
      "        # Default the credit charge to 1 unless set by the caller\n",
      "        if packet.fields.has_key('CreditCharge') is False:\n",
      "            packet['CreditCharge'] = 1\n",
      "\n",
      "        # Standard credit request after negotiating protocol\n",
      "        if self._Connection['SequenceWindow'] > 3:\n",
      "            packet['CreditRequestResponse'] = 127\n",
      "\n",
      "        messageId = packet['MessageID']\n",
      "\n",
      "        if self._Session['SigningActivated'] is True and self._Connection['SequenceWindow'] > 2:\n",
      "            if packet['TreeID'] > 0 and self._Session['TreeConnectTable'].has_key(packet['TreeID']) is True:\n",
      "                if self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is False:\n",
      "                    packet['Flags'] = SMB2_FLAGS_SIGNED\n",
      "                    self.signSMB(packet)\n",
      "            elif packet['TreeID'] == 0:\n",
      "                packet['Flags'] = SMB2_FLAGS_SIGNED\n",
      "                self.signSMB(packet)\n",
      "\n",
      "        if (self._Session['SessionFlags'] & SMB2_SESSION_FLAG_ENCRYPT_DATA) or ( packet['TreeID'] != 0 and self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is True):\n",
      "            plainText = str(packet)\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER()\n",
      "            transformHeader['Nonce'] = ''.join([random.choice(string.letters) for i in range(11)])\n",
      "            transformHeader['OriginalMessageSize'] = len(plainText)\n",
      "            transformHeader['EncryptionAlgorithm'] = SMB2_ENCRYPTION_AES128_CCM\n",
      "            transformHeader['SessionID'] = self._Session['SessionID'] \n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['EncryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            cipherText = cipher.encrypt(plainText)\n",
      "            transformHeader['Signature'] = cipher.digest()\n",
      "            packet = str(transformHeader) + cipherText\n",
      "\n",
      "        self._NetBIOSSession.send_packet(str(packet))\n",
      "        return messageId\n",
      "\n",
      "    def recvSMB(self, packetID = None):\n",
      "        # First, verify we don't have the packet already\n",
      "        if self._Connection['OutstandingResponses'].has_key(packetID):\n",
      "            return self._Connection['OutstandingResponses'].pop(packetID) \n",
      "\n",
      "        data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "\n",
      "        if data.get_trailer().startswith('\\xfdSMB'):\n",
      "            # Packet is encrypted\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "            cipher.update(str(transformHeader)[20:])\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/lex128/mtasa-blue/vendor/curl/tests/python_dependencies/impacket/smb3.py",
    "code": [
      "        # Default the credit charge to 1 unless set by the caller\n",
      "        if packet.fields.has_key('CreditCharge') is False:\n",
      "            packet['CreditCharge'] = 1\n",
      "\n",
      "        # Standard credit request after negotiating protocol\n",
      "        if self._Connection['SequenceWindow'] > 3:\n",
      "            packet['CreditRequestResponse'] = 127\n",
      "\n",
      "        messageId = packet['MessageID']\n",
      "\n",
      "        if self._Session['SigningActivated'] is True and self._Connection['SequenceWindow'] > 2:\n",
      "            if packet['TreeID'] > 0 and self._Session['TreeConnectTable'].has_key(packet['TreeID']) is True:\n",
      "                if self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is False:\n",
      "                    packet['Flags'] = SMB2_FLAGS_SIGNED\n",
      "                    self.signSMB(packet)\n",
      "            elif packet['TreeID'] == 0:\n",
      "                packet['Flags'] = SMB2_FLAGS_SIGNED\n",
      "                self.signSMB(packet)\n",
      "\n",
      "        if (self._Session['SessionFlags'] & SMB2_SESSION_FLAG_ENCRYPT_DATA) or ( packet['TreeID'] != 0 and self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is True):\n",
      "            plainText = str(packet)\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER()\n",
      "            transformHeader['Nonce'] = ''.join([random.choice(string.letters) for i in range(11)])\n",
      "            transformHeader['OriginalMessageSize'] = len(plainText)\n",
      "            transformHeader['EncryptionAlgorithm'] = SMB2_ENCRYPTION_AES128_CCM\n",
      "            transformHeader['SessionID'] = self._Session['SessionID'] \n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['EncryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            cipherText = cipher.encrypt(plainText)\n",
      "            transformHeader['Signature'] = cipher.digest()\n",
      "            packet = str(transformHeader) + cipherText\n",
      "\n",
      "        self._NetBIOSSession.send_packet(str(packet))\n",
      "        return messageId\n",
      "\n",
      "    def recvSMB(self, packetID = None):\n",
      "        # First, verify we don't have the packet already\n",
      "        if self._Connection['OutstandingResponses'].has_key(packetID):\n",
      "            return self._Connection['OutstandingResponses'].pop(packetID) \n",
      "\n",
      "        data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "\n",
      "        if data.get_trailer().startswith('\\xfdSMB'):\n",
      "            # Packet is encrypted\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "            #cipher.verify(transformHeader['Signature'])\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/lex128/mtasa-blue/vendor/curl/tests/python_dependencies/impacket/smb3.py",
    "code": [
      "            packet['CreditCharge'] = 1\n",
      "\n",
      "        # Standard credit request after negotiating protocol\n",
      "        if self._Connection['SequenceWindow'] > 3:\n",
      "            packet['CreditRequestResponse'] = 127\n",
      "\n",
      "        messageId = packet['MessageID']\n",
      "\n",
      "        if self._Session['SigningActivated'] is True and self._Connection['SequenceWindow'] > 2:\n",
      "            if packet['TreeID'] > 0 and self._Session['TreeConnectTable'].has_key(packet['TreeID']) is True:\n",
      "                if self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is False:\n",
      "                    packet['Flags'] = SMB2_FLAGS_SIGNED\n",
      "                    self.signSMB(packet)\n",
      "            elif packet['TreeID'] == 0:\n",
      "                packet['Flags'] = SMB2_FLAGS_SIGNED\n",
      "                self.signSMB(packet)\n",
      "\n",
      "        if (self._Session['SessionFlags'] & SMB2_SESSION_FLAG_ENCRYPT_DATA) or ( packet['TreeID'] != 0 and self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is True):\n",
      "            plainText = str(packet)\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER()\n",
      "            transformHeader['Nonce'] = ''.join([random.choice(string.letters) for i in range(11)])\n",
      "            transformHeader['OriginalMessageSize'] = len(plainText)\n",
      "            transformHeader['EncryptionAlgorithm'] = SMB2_ENCRYPTION_AES128_CCM\n",
      "            transformHeader['SessionID'] = self._Session['SessionID'] \n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['EncryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            cipherText = cipher.encrypt(plainText)\n",
      "            transformHeader['Signature'] = cipher.digest()\n",
      "            packet = str(transformHeader) + cipherText\n",
      "\n",
      "        self._NetBIOSSession.send_packet(str(packet))\n",
      "        return messageId\n",
      "\n",
      "    def recvSMB(self, packetID = None):\n",
      "        # First, verify we don't have the packet already\n",
      "        if self._Connection['OutstandingResponses'].has_key(packetID):\n",
      "            return self._Connection['OutstandingResponses'].pop(packetID) \n",
      "\n",
      "        data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "\n",
      "        if data.get_trailer().startswith('\\xfdSMB'):\n",
      "            # Packet is encrypted\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "            #cipher.verify(transformHeader['Signature'])\n",
      "            packet = SMB2Packet(plainText)\n",
      "        else:\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/lex128/mtasa-blue/vendor/curl/tests/python_dependencies/impacket/smb3.py",
    "code": [
      "            transformHeader['OriginalMessageSize'] = len(plainText)\n",
      "            transformHeader['EncryptionAlgorithm'] = SMB2_ENCRYPTION_AES128_CCM\n",
      "            transformHeader['SessionID'] = self._Session['SessionID'] \n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['EncryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            cipherText = cipher.encrypt(plainText)\n",
      "            transformHeader['Signature'] = cipher.digest()\n",
      "            packet = str(transformHeader) + cipherText\n",
      "\n",
      "        self._NetBIOSSession.send_packet(str(packet))\n",
      "        return messageId\n",
      "\n",
      "    def recvSMB(self, packetID = None):\n",
      "        # First, verify we don't have the packet already\n",
      "        if self._Connection['OutstandingResponses'].has_key(packetID):\n",
      "            return self._Connection['OutstandingResponses'].pop(packetID) \n",
      "\n",
      "        data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "\n",
      "        if data.get_trailer().startswith('\\xfdSMB'):\n",
      "            # Packet is encrypted\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "            #cipher.verify(transformHeader['Signature'])\n",
      "            packet = SMB2Packet(plainText)\n",
      "        else:\n",
      "            # In all SMB dialects for a response this field is interpreted as the Status field. \n",
      "            # This field can be set to any value. For a list of valid status codes, \n",
      "            # see [MS-ERREF] section 2.3.\n",
      "            packet = SMB2Packet(data.get_trailer())\n",
      "\n",
      "        # Loop while we receive pending requests\n",
      "        if packet['Status'] == STATUS_PENDING:\n",
      "            status = STATUS_PENDING\n",
      "            while status == STATUS_PENDING:\n",
      "                data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "                if data.get_trailer().startswith('\\xfeSMB'):\n",
      "                    packet = SMB2Packet(data.get_trailer())\n",
      "                else:\n",
      "                    # Packet is encrypted\n",
      "                    transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "                    from Crypto.Cipher import AES\n",
      "                    try: \n",
      "                        AES.MODE_CCM\n",
      "                    except:\n",
      "                        LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                        raise \n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/lex128/mtasa-blue/vendor/curl/tests/python_dependencies/impacket/smb3.py",
    "code": [
      "            transformHeader['SessionID'] = self._Session['SessionID'] \n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['EncryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            cipherText = cipher.encrypt(plainText)\n",
      "            transformHeader['Signature'] = cipher.digest()\n",
      "            packet = str(transformHeader) + cipherText\n",
      "\n",
      "        self._NetBIOSSession.send_packet(str(packet))\n",
      "        return messageId\n",
      "\n",
      "    def recvSMB(self, packetID = None):\n",
      "        # First, verify we don't have the packet already\n",
      "        if self._Connection['OutstandingResponses'].has_key(packetID):\n",
      "            return self._Connection['OutstandingResponses'].pop(packetID) \n",
      "\n",
      "        data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "\n",
      "        if data.get_trailer().startswith('\\xfdSMB'):\n",
      "            # Packet is encrypted\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "            #cipher.verify(transformHeader['Signature'])\n",
      "            packet = SMB2Packet(plainText)\n",
      "        else:\n",
      "            # In all SMB dialects for a response this field is interpreted as the Status field. \n",
      "            # This field can be set to any value. For a list of valid status codes, \n",
      "            # see [MS-ERREF] section 2.3.\n",
      "            packet = SMB2Packet(data.get_trailer())\n",
      "\n",
      "        # Loop while we receive pending requests\n",
      "        if packet['Status'] == STATUS_PENDING:\n",
      "            status = STATUS_PENDING\n",
      "            while status == STATUS_PENDING:\n",
      "                data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "                if data.get_trailer().startswith('\\xfeSMB'):\n",
      "                    packet = SMB2Packet(data.get_trailer())\n",
      "                else:\n",
      "                    # Packet is encrypted\n",
      "                    transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "                    from Crypto.Cipher import AES\n",
      "                    try: \n",
      "                        AES.MODE_CCM\n",
      "                    except:\n",
      "                        LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                        raise \n",
      "                    cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "                    cipher.update(str(transformHeader)[20:])\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/lex128/mtasa-blue/vendor/curl/tests/python_dependencies/impacket/smb3.py",
    "code": [
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['EncryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            cipherText = cipher.encrypt(plainText)\n",
      "            transformHeader['Signature'] = cipher.digest()\n",
      "            packet = str(transformHeader) + cipherText\n",
      "\n",
      "        self._NetBIOSSession.send_packet(str(packet))\n",
      "        return messageId\n",
      "\n",
      "    def recvSMB(self, packetID = None):\n",
      "        # First, verify we don't have the packet already\n",
      "        if self._Connection['OutstandingResponses'].has_key(packetID):\n",
      "            return self._Connection['OutstandingResponses'].pop(packetID) \n",
      "\n",
      "        data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "\n",
      "        if data.get_trailer().startswith('\\xfdSMB'):\n",
      "            # Packet is encrypted\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "            #cipher.verify(transformHeader['Signature'])\n",
      "            packet = SMB2Packet(plainText)\n",
      "        else:\n",
      "            # In all SMB dialects for a response this field is interpreted as the Status field. \n",
      "            # This field can be set to any value. For a list of valid status codes, \n",
      "            # see [MS-ERREF] section 2.3.\n",
      "            packet = SMB2Packet(data.get_trailer())\n",
      "\n",
      "        # Loop while we receive pending requests\n",
      "        if packet['Status'] == STATUS_PENDING:\n",
      "            status = STATUS_PENDING\n",
      "            while status == STATUS_PENDING:\n",
      "                data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "                if data.get_trailer().startswith('\\xfeSMB'):\n",
      "                    packet = SMB2Packet(data.get_trailer())\n",
      "                else:\n",
      "                    # Packet is encrypted\n",
      "                    transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "                    from Crypto.Cipher import AES\n",
      "                    try: \n",
      "                        AES.MODE_CCM\n",
      "                    except:\n",
      "                        LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                        raise \n",
      "                    cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "                    cipher.update(str(transformHeader)[20:])\n",
      "                    plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "                    #cipher.verify(transformHeader['Signature'])\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/lex128/mtasa-blue/vendor/curl/tests/python_dependencies/impacket/smb3.py",
    "code": [
      "            transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "            #cipher.verify(transformHeader['Signature'])\n",
      "            packet = SMB2Packet(plainText)\n",
      "        else:\n",
      "            # In all SMB dialects for a response this field is interpreted as the Status field. \n",
      "            # This field can be set to any value. For a list of valid status codes, \n",
      "            # see [MS-ERREF] section 2.3.\n",
      "            packet = SMB2Packet(data.get_trailer())\n",
      "\n",
      "        # Loop while we receive pending requests\n",
      "        if packet['Status'] == STATUS_PENDING:\n",
      "            status = STATUS_PENDING\n",
      "            while status == STATUS_PENDING:\n",
      "                data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "                if data.get_trailer().startswith('\\xfeSMB'):\n",
      "                    packet = SMB2Packet(data.get_trailer())\n",
      "                else:\n",
      "                    # Packet is encrypted\n",
      "                    transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "                    from Crypto.Cipher import AES\n",
      "                    try: \n",
      "                        AES.MODE_CCM\n",
      "                    except:\n",
      "                        LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                        raise \n",
      "                    cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "                    cipher.update(str(transformHeader)[20:])\n",
      "                    plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "                    #cipher.verify(transformHeader['Signature'])\n",
      "                    packet = SMB2Packet(plainText)\n",
      "                status = packet['Status']\n",
      "\n",
      "        if packet['MessageID'] == packetID or packetID is None:\n",
      "        #    if self._Session['SigningRequired'] is True:\n",
      "        #        self.signSMB(packet)\n",
      "            # Let's update the sequenceWindow based on the CreditsCharged\n",
      "            self._Connection['SequenceWindow'] += (packet['CreditCharge'] - 1)\n",
      "            return packet\n",
      "        else:\n",
      "            self._Connection['OutstandingResponses'][packet['MessageID']] = packet\n",
      "            return self.recvSMB(packetID) \n",
      "\n",
      "    def negotiateSession(self, preferredDialect = None):\n",
      "        packet = self.SMB_PACKET()\n",
      "        packet['Command'] = SMB2_NEGOTIATE\n",
      "        negSession = SMB2Negotiate()\n",
      "\n",
      "        negSession['SecurityMode'] = SMB2_NEGOTIATE_SIGNING_ENABLED \n",
      "        if self.RequireMessageSigning is True:\n",
      "            negSession['SecurityMode'] |= SMB2_NEGOTIATE_SIGNING_REQUIRED\n",
      "        negSession['Capabilities'] = SMB2_GLOBAL_CAP_ENCRYPTION\n",
      "        negSession['ClientGuid'] = self.ClientGuid\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/lex128/mtasa-blue/vendor/curl/tests/python_dependencies/impacket/smb3.py",
    "code": [
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "            #cipher.verify(transformHeader['Signature'])\n",
      "            packet = SMB2Packet(plainText)\n",
      "        else:\n",
      "            # In all SMB dialects for a response this field is interpreted as the Status field. \n",
      "            # This field can be set to any value. For a list of valid status codes, \n",
      "            # see [MS-ERREF] section 2.3.\n",
      "            packet = SMB2Packet(data.get_trailer())\n",
      "\n",
      "        # Loop while we receive pending requests\n",
      "        if packet['Status'] == STATUS_PENDING:\n",
      "            status = STATUS_PENDING\n",
      "            while status == STATUS_PENDING:\n",
      "                data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "                if data.get_trailer().startswith('\\xfeSMB'):\n",
      "                    packet = SMB2Packet(data.get_trailer())\n",
      "                else:\n",
      "                    # Packet is encrypted\n",
      "                    transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "                    from Crypto.Cipher import AES\n",
      "                    try: \n",
      "                        AES.MODE_CCM\n",
      "                    except:\n",
      "                        LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                        raise \n",
      "                    cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "                    cipher.update(str(transformHeader)[20:])\n",
      "                    plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "                    #cipher.verify(transformHeader['Signature'])\n",
      "                    packet = SMB2Packet(plainText)\n",
      "                status = packet['Status']\n",
      "\n",
      "        if packet['MessageID'] == packetID or packetID is None:\n",
      "        #    if self._Session['SigningRequired'] is True:\n",
      "        #        self.signSMB(packet)\n",
      "            # Let's update the sequenceWindow based on the CreditsCharged\n",
      "            self._Connection['SequenceWindow'] += (packet['CreditCharge'] - 1)\n",
      "            return packet\n",
      "        else:\n",
      "            self._Connection['OutstandingResponses'][packet['MessageID']] = packet\n",
      "            return self.recvSMB(packetID) \n",
      "\n",
      "    def negotiateSession(self, preferredDialect = None):\n",
      "        packet = self.SMB_PACKET()\n",
      "        packet['Command'] = SMB2_NEGOTIATE\n",
      "        negSession = SMB2Negotiate()\n",
      "\n",
      "        negSession['SecurityMode'] = SMB2_NEGOTIATE_SIGNING_ENABLED \n",
      "        if self.RequireMessageSigning is True:\n",
      "            negSession['SecurityMode'] |= SMB2_NEGOTIATE_SIGNING_REQUIRED\n",
      "        negSession['Capabilities'] = SMB2_GLOBAL_CAP_ENCRYPTION\n",
      "        negSession['ClientGuid'] = self.ClientGuid\n",
      "        if preferredDialect is not None:\n",
      "            negSession['Dialects'] = [preferredDialect]\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/lex128/mtasa-blue/vendor/curl/tests/python_dependencies/impacket/smb3.py",
    "code": [
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "            #cipher.verify(transformHeader['Signature'])\n",
      "            packet = SMB2Packet(plainText)\n",
      "        else:\n",
      "            # In all SMB dialects for a response this field is interpreted as the Status field. \n",
      "            # This field can be set to any value. For a list of valid status codes, \n",
      "            # see [MS-ERREF] section 2.3.\n",
      "            packet = SMB2Packet(data.get_trailer())\n",
      "\n",
      "        # Loop while we receive pending requests\n",
      "        if packet['Status'] == STATUS_PENDING:\n",
      "            status = STATUS_PENDING\n",
      "            while status == STATUS_PENDING:\n",
      "                data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "                if data.get_trailer().startswith('\\xfeSMB'):\n",
      "                    packet = SMB2Packet(data.get_trailer())\n",
      "                else:\n",
      "                    # Packet is encrypted\n",
      "                    transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "                    from Crypto.Cipher import AES\n",
      "                    try: \n",
      "                        AES.MODE_CCM\n",
      "                    except:\n",
      "                        LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                        raise \n",
      "                    cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "                    cipher.update(str(transformHeader)[20:])\n",
      "                    plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "                    #cipher.verify(transformHeader['Signature'])\n",
      "                    packet = SMB2Packet(plainText)\n",
      "                status = packet['Status']\n",
      "\n",
      "        if packet['MessageID'] == packetID or packetID is None:\n",
      "        #    if self._Session['SigningRequired'] is True:\n",
      "        #        self.signSMB(packet)\n",
      "            # Let's update the sequenceWindow based on the CreditsCharged\n",
      "            self._Connection['SequenceWindow'] += (packet['CreditCharge'] - 1)\n",
      "            return packet\n",
      "        else:\n",
      "            self._Connection['OutstandingResponses'][packet['MessageID']] = packet\n",
      "            return self.recvSMB(packetID) \n",
      "\n",
      "    def negotiateSession(self, preferredDialect = None):\n",
      "        packet = self.SMB_PACKET()\n",
      "        packet['Command'] = SMB2_NEGOTIATE\n",
      "        negSession = SMB2Negotiate()\n",
      "\n",
      "        negSession['SecurityMode'] = SMB2_NEGOTIATE_SIGNING_ENABLED \n",
      "        if self.RequireMessageSigning is True:\n",
      "            negSession['SecurityMode'] |= SMB2_NEGOTIATE_SIGNING_REQUIRED\n",
      "        negSession['Capabilities'] = SMB2_GLOBAL_CAP_ENCRYPTION\n",
      "        negSession['ClientGuid'] = self.ClientGuid\n",
      "        if preferredDialect is not None:\n",
      "            negSession['Dialects'] = [preferredDialect]\n",
      "        else:\n",
      "            negSession['Dialects'] = [SMB2_DIALECT_002, SMB2_DIALECT_21, SMB2_DIALECT_30]\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/spirrello/spirrello-pynet-work/applied_python/lib64/python2.7/site-packages/Crypto/Cipher/AES.py",
    "code": [
      "# the extent that dedication to the public domain is not available,\n",
      "# everyone is granted a worldwide, perpetual, royalty-free,\n",
      "# non-exclusive license to exercise all rights associated with the\n",
      "# contents of this file for any purpose whatsoever.\n",
      "# No rights are reserved.\n",
      "#\n",
      "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n",
      "# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n",
      "# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n",
      "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n",
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"AES symmetric cipher\n",
      "\n",
      "AES `(Advanced Encryption Standard)`__ is a symmetric block cipher standardized\n",
      "by NIST_ . It has a fixed data block size of 16 bytes.\n",
      "Its keys can be 128, 192, or 256 bits long.\n",
      "\n",
      "AES is very fast and secure, and it is the de facto standard for symmetric\n",
      "encryption.\n",
      "\n",
      "As an example, encryption can be done as follows:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto import Random\n",
      "    >>>\n",
      "    >>> key = b'Sixteen byte key'\n",
      "    >>> iv = Random.new().read(AES.block_size)\n",
      "    >>> cipher = AES.new(key, AES.MODE_CFB, iv)\n",
      "    >>> msg = iv + cipher.encrypt(b'Attack at dawn')\n",
      "\n",
      ".. __: http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n",
      ".. _NIST: http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf\n",
      "\n",
      ":undocumented: __revision__, __package__\n",
      "\"\"\"\n",
      "\n",
      "__revision__ = \"$Id$\"\n",
      "\n",
      "from Crypto.Cipher import blockalgo\n",
      "from Crypto.Cipher import _AES\n",
      "\n",
      "class AESCipher (blockalgo.BlockAlgo):\n",
      "    \"\"\"AES cipher object\"\"\"\n",
      "\n",
      "    def __init__(self, key, *args, **kwargs):\n",
      "        \"\"\"Initialize an AES cipher object\n",
      "        \n",
      "        See also `new()` at the module level.\"\"\"\n",
      "        blockalgo.BlockAlgo.__init__(self, _AES, key, *args, **kwargs)\n",
      "\n",
      "def new(key, *args, **kwargs):\n",
      "    \"\"\"Create a new AES cipher\n",
      "\n",
      "    :Parameters:\n",
      "      key : byte string\n",
      "        The secret key to use in the symmetric cipher.\n",
      "        It must be 16 (*AES-128*), 24 (*AES-192*), or 32 (*AES-256*) bytes long.\n",
      "    :Keywords:\n",
      "      mode : a *MODE_** constant\n"
    ],
    "target": 30,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/spirrello/spirrello-pynet-work/applied_python/lib/python2.7/site-packages/ansible/utils/vault.py",
    "code": [
      "            d += d_i\n",
      "\n",
      "        key = d[:key_length]\n",
      "        iv = d[key_length:key_length+iv_length]\n",
      "\n",
      "        return key, iv\n",
      "\n",
      "    def encrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read plaintext data from in_file and write encrypted to out_file \"\"\"\n",
      "\n",
      "\n",
      "        # combine sha + data\n",
      "        this_sha = sha256(data).hexdigest()\n",
      "        tmp_data = this_sha + \"\\n\" + data\n",
      "\n",
      "        in_file = BytesIO(tmp_data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "\n",
      "        # Get a block of random data. EL does not have Crypto.Random.new() \n",
      "        # so os.urandom is used for cross platform purposes\n",
      "        salt = os.urandom(bs - len('Salted__'))\n",
      "\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        out_file.write('Salted__' + salt)\n",
      "        finished = False\n",
      "        while not finished:\n",
      "            chunk = in_file.read(1024 * bs)\n",
      "            if len(chunk) == 0 or len(chunk) % bs != 0:\n",
      "                padding_length = (bs - len(chunk) % bs) or bs\n",
      "                chunk += padding_length * chr(padding_length)\n",
      "                finished = True\n",
      "            out_file.write(cipher.encrypt(chunk))\n",
      "\n",
      "        out_file.seek(0)\n",
      "        enc_data = out_file.read()\n",
      "        tmp_data = hexlify(enc_data)\n",
      "\n",
      "        return tmp_data\n",
      "\n",
      " \n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = ''.join(data.split('\\n'))\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n"
    ],
    "target": 26,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/spirrello/spirrello-pynet-work/applied_python/lib/python2.7/site-packages/ansible/utils/vault.py",
    "code": [
      "                chunk += padding_length * chr(padding_length)\n",
      "                finished = True\n",
      "            out_file.write(cipher.encrypt(chunk))\n",
      "\n",
      "        out_file.seek(0)\n",
      "        enc_data = out_file.read()\n",
      "        tmp_data = hexlify(enc_data)\n",
      "\n",
      "        return tmp_data\n",
      "\n",
      " \n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = ''.join(data.split('\\n'))\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        salt = in_file.read(bs)[len('Salted__'):]\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        next_chunk = ''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n",
      "            chunk, next_chunk = next_chunk, cipher.decrypt(in_file.read(1024 * bs))\n",
      "            if len(next_chunk) == 0:\n",
      "                padding_length = ord(chunk[-1])\n",
      "                chunk = chunk[:-padding_length]\n",
      "                finished = True\n",
      "            out_file.write(chunk)\n",
      "\n",
      "        # reset the stream pointer to the beginning\n",
      "        out_file.seek(0)\n",
      "        new_data = out_file.read()\n",
      "\n",
      "        # split out sha and verify decryption\n",
      "        split_data = new_data.split(\"\\n\")\n",
      "        this_sha = split_data[0]\n",
      "        this_data = '\\n'.join(split_data[1:])\n",
      "        test_sha = sha256(this_data).hexdigest()\n",
      "\n",
      "        if this_sha != test_sha:\n",
      "            raise errors.AnsibleError(\"Decryption failed\")\n",
      "\n",
      "        #return out_file.read()\n",
      "        return this_data\n",
      "\n",
      "\n",
      "class VaultAES256(object):\n",
      "\n",
      "    \"\"\"\n"
    ],
    "target": 26,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/spirrello/spirrello-pynet-work/applied_python/lib/python2.7/site-packages/ansible/utils/vault.py",
    "code": [
      "        key2 = derivedkey[keylength:(keylength * 2)]\n",
      "        iv = derivedkey[(keylength * 2):(keylength * 2) + ivlength]\n",
      "\n",
      "        return key1, key2, hexlify(iv)\n",
      "\n",
      "\n",
      "    def encrypt(self, data, password):\n",
      "\n",
      "        salt = os.urandom(32)\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += padding_length * chr(padding_length)\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=long(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)                \n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = \"%s\\n%s\\n%s\" % ( hexlify(salt), hmac.hexdigest(), hexlify(cryptedData) )\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = ''.join(data.split(\"\\n\"))\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH \n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, hmacDecrypt.hexdigest()):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=long(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n"
    ],
    "target": 26,
    "len": 3
  }
]